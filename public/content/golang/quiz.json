[
  {
    "question": "What is a goroutine in Go?",
    "options": [
      "A type of loop",
      "A lightweight thread managed by the Go runtime",
      "A data structure",
      "A package manager"
    ],
    "correctAnswer": 1,
    "explanation": "A goroutine is a lightweight thread of execution managed by the Go runtime. Goroutines are much cheaper than OS threads and thousands can run concurrently."
  },
  {
    "question": "What is the purpose of channels in Go?",
    "options": [
      "To store data permanently",
      "To enable communication and synchronization between goroutines",
      "To import packages",
      "To handle errors"
    ],
    "correctAnswer": 1,
    "explanation": "Channels are the pipes that connect concurrent goroutines. They allow you to send and receive values between goroutines, providing both communication and synchronization."
  },
  {
    "question": "What does 'defer' keyword do in Go?",
    "options": [
      "Delays execution until the surrounding function returns",
      "Creates a goroutine",
      "Handles errors",
      "Imports a package"
    ],
    "correctAnswer": 0,
    "explanation": "The defer keyword postpones the execution of a function until the surrounding function returns. It's commonly used for cleanup operations like closing files or unlocking mutexes."
  },
  {
    "question": "What's the difference between buffered and unbuffered channels?",
    "options": [
      "Buffered channels can hold values without a receiver, unbuffered require immediate receive",
      "Buffered channels are faster",
      "Unbuffered channels don't work",
      "There is no difference"
    ],
    "correctAnswer": 0,
    "explanation": "Unbuffered channels block the sender until a receiver is ready. Buffered channels allow sending up to N values without blocking, where N is the buffer size."
  },
  {
    "question": "What does the 'select' statement do in Go?",
    "options": [
      "Selects a random number",
      "Waits on multiple channel operations",
      "Filters arrays",
      "Chooses a goroutine"
    ],
    "correctAnswer": 1,
    "explanation": "The select statement lets a goroutine wait on multiple channel operations. It blocks until one of its cases can proceed, enabling powerful concurrent patterns."
  },
  {
    "question": "What is the zero value of a slice in Go?",
    "options": [
      "An empty slice []",
      "nil",
      "0",
      "false"
    ],
    "correctAnswer": 1,
    "explanation": "The zero value of a slice is nil. A nil slice has length and capacity 0 and has no underlying array. However, you can still call len() and cap() on it safely."
  },
  {
    "question": "What are the basic data types in Go?",
    "options": [
      "Only int and string",
      "bool, string, int, float64, complex128",
      "Any type from other languages",
      "Go has no types"
    ],
    "correctAnswer": 1,
    "explanation": "Go has basic types including bool, string, int/int8/int16/int32/int64, uint variants, float32/float64, complex64/complex128, byte, and rune."
  },
  {
    "question": "What is the difference between := and var?",
    "options": [
      "No difference",
      ":= is short declaration only in functions, var works anywhere",
      "var is deprecated",
      ":= is slower"
    ],
    "correctAnswer": 1,
    "explanation": ":= is short variable declaration syntax that only works inside functions and infers type. var can be used at package or function level and allows explicit type declaration."
  },
  {
    "question": "What is a slice in Go?",
    "options": [
      "A fixed-size array",
      "A dynamic-size, flexible view into arrays",
      "A string operation",
      "A goroutine"
    ],
    "correctAnswer": 1,
    "explanation": "A slice is a dynamically-sized, flexible view into the elements of an array. It has a pointer, length, and capacity. Slices are more common than arrays."
  },
  {
    "question": "How do you create a slice with initial capacity?",
    "options": [
      "slice := []int",
      "slice := make([]int, 0, 10)",
      "slice := new([]int)",
      "slice := array[:]"
    ],
    "correctAnswer": 1,
    "explanation": "make([]int, 0, 10) creates a slice with length 0 and capacity 10. The first number is length, second is capacity (optional)."
  },
  {
    "question": "What is the difference between array and slice?",
    "options": [
      "No difference",
      "Arrays have fixed size, slices are dynamic",
      "Arrays are deprecated",
      "Slices are slower"
    ],
    "correctAnswer": 1,
    "explanation": "Arrays have a fixed size that's part of their type. Slices are dynamic, can grow/shrink, and are references to underlying arrays. Slices are more flexible."
  },
  {
    "question": "What does the range keyword do?",
    "options": [
      "Creates a range of numbers",
      "Iterates over elements in arrays, slices, maps, channels",
      "Defines a numeric range",
      "Validates ranges"
    ],
    "correctAnswer": 1,
    "explanation": "range iterates over elements in arrays, slices, strings, maps, or channels. Returns index/key and value for each iteration."
  },
  {
    "question": "What is a map in Go?",
    "options": [
      "Geographic map",
      "Hash table that maps keys to values",
      "Array index",
      "Function mapper"
    ],
    "correctAnswer": 1,
    "explanation": "A map is Go's built-in hash table/dictionary type that maps keys of one type to values of another type. Created with make(map[KeyType]ValueType)."
  },
  {
    "question": "What is the zero value of a map?",
    "options": [
      "Empty map {}",
      "nil",
      "0",
      "false"
    ],
    "correctAnswer": 1,
    "explanation": "The zero value of a map is nil. A nil map has no keys and can't have keys added. Use make() to create a usable map."
  },
  {
    "question": "How do you check if a key exists in a map?",
    "options": [
      "map.has(key)",
      "value, ok := map[key]",
      "map.contains(key)",
      "key in map"
    ],
    "correctAnswer": 1,
    "explanation": "Use the two-value assignment: value, ok := map[key]. If key exists, ok is true and value is the map value. Otherwise, ok is false and value is zero value."
  },
  {
    "question": "What is a struct in Go?",
    "options": [
      "A class",
      "A collection of fields/properties grouped together",
      "A function",
      "An interface"
    ],
    "correctAnswer": 1,
    "explanation": "A struct is a composite data type that groups together zero or more named fields of arbitrary types under a single name. Similar to classes but without inheritance."
  },
  {
    "question": "How do you define a method on a struct?",
    "options": [
      "func (s Struct) method() {}",
      "Struct.method = func() {}",
      "method Struct() {}",
      "def method(self)"
    ],
    "correctAnswer": 0,
    "explanation": "Methods are functions with a receiver argument between func keyword and function name: func (s Struct) method() {}. The receiver can be value or pointer type."
  },
  {
    "question": "What's the difference between value and pointer receivers?",
    "options": [
      "No difference",
      "Pointer receivers can modify the receiver, value receivers can't",
      "Value receivers are faster",
      "Pointer receivers are deprecated"
    ],
    "correctAnswer": 1,
    "explanation": "Pointer receivers (*T) can modify the receiver and avoid copying large structs. Value receivers (T) operate on a copy and can't modify the original."
  },
  {
    "question": "What is an interface in Go?",
    "options": [
      "A class",
      "A set of method signatures that a type can implement",
      "A network interface",
      "A user interface"
    ],
    "correctAnswer": 1,
    "explanation": "An interface is a type that specifies a set of method signatures. A type implements an interface by implementing its methods (implicitly, no 'implements' keyword)."
  },
  {
    "question": "What is the empty interface interface{}?",
    "options": [
      "A broken interface",
      "Can hold values of any type",
      "An error",
      "A null interface"
    ],
    "correctAnswer": 1,
    "explanation": "The empty interface interface{} has no methods, so all types implement it. It can hold values of any type. Similar to 'any' in other languages (Go 1.18+ has 'any' alias)."
  },
  {
    "question": "How do you check the type of an interface value?",
    "options": [
      "typeof(value)",
      "value.(Type) and type assertion or type switch",
      "value.type()",
      "getType(value)"
    ],
    "correctAnswer": 1,
    "explanation": "Use type assertion: value.(Type) or type switch: switch v := i.(type). Type assertion returns value and boolean indicating success."
  },
  {
    "question": "What is a pointer in Go?",
    "options": [
      "A cursor",
      "A variable that stores memory address of another variable",
      "An array index",
      "A reference"
    ],
    "correctAnswer": 1,
    "explanation": "A pointer holds the memory address of a value. Use & to get pointer to value and * to dereference pointer. Go has pointers but no pointer arithmetic."
  },
  {
    "question": "What does the & operator do?",
    "options": [
      "Bitwise AND",
      "Gets the memory address (pointer) of a variable",
      "Logical AND",
      "Concatenation"
    ],
    "correctAnswer": 1,
    "explanation": "The & operator generates a pointer to its operand. &x gives you the memory address of x, creating a pointer to x."
  },
  {
    "question": "What does the * operator do with pointers?",
    "options": [
      "Multiplication",
      "Dereferences pointer to access the value it points to",
      "Creates pointer",
      "Pointer arithmetic"
    ],
    "correctAnswer": 1,
    "explanation": "The * operator dereferences a pointer, giving access to the value at that address. *p accesses the value pointed to by pointer p."
  },
  {
    "question": "What is error handling in Go?",
    "options": [
      "Try-catch blocks",
      "Functions return error as last return value",
      "Exceptions",
      "No error handling"
    ],
    "correctAnswer": 1,
    "explanation": "Go uses explicit error handling. Functions return error as the last return value. Caller checks if error is nil to determine success or failure."
  },
  {
    "question": "What is the error interface?",
    "options": [
      "A bug",
      "An interface with Error() string method",
      "An exception type",
      "A logging mechanism"
    ],
    "correctAnswer": 1,
    "explanation": "The error interface is a built-in interface with a single method: Error() string. Any type implementing this method satisfies the error interface."
  },
  {
    "question": "How do you create a custom error?",
    "options": [
      "throw new Error()",
      "errors.New('message') or fmt.Errorf()",
      "error('message')",
      "raise Exception"
    ],
    "correctAnswer": 1,
    "explanation": "Use errors.New('message') for simple errors or fmt.Errorf('format %v', value) for formatted errors. Can also create custom error types."
  },
  {
    "question": "What does panic do in Go?",
    "options": [
      "Logs a warning",
      "Stops normal execution and begins panicking",
      "Creates an error",
      "Exits gracefully"
    ],
    "correctAnswer": 1,
    "explanation": "panic stops normal execution of current goroutine and begins panicking. Deferred functions run, then program crashes. Use for unrecoverable errors."
  },
  {
    "question": "What does recover do?",
    "options": [
      "Recovers memory",
      "Regains control of panicking goroutine when called in defer",
      "Restores data",
      "Fixes errors"
    ],
    "correctAnswer": 1,
    "explanation": "recover regains control of a panicking goroutine. Must be called inside a deferred function. Returns the value passed to panic or nil if not panicking."
  },
  {
    "question": "What is the defer, panic, recover pattern?",
    "options": [
      "Design pattern",
      "Error handling mechanism similar to try-catch-finally",
      "Concurrency pattern",
      "Testing pattern"
    ],
    "correctAnswer": 1,
    "explanation": "defer/panic/recover is Go's mechanism similar to try-catch-finally. defer runs cleanup, panic raises errors, recover catches panics in deferred functions."
  },
  {
    "question": "What is a package in Go?",
    "options": [
      "A zip file",
      "A way to organize and reuse code",
      "A container",
      "A module"
    ],
    "correctAnswer": 1,
    "explanation": "A package is a collection of Go source files in the same directory. Packages are Go's way of organizing and reusing code. Every Go file belongs to a package."
  },
  {
    "question": "What is the init function?",
    "options": [
      "Constructor",
      "Special function that runs automatically when package is imported",
      "Initializer method",
      "Setup function"
    ],
    "correctAnswer": 1,
    "explanation": "init() is a special function that runs automatically when the package is imported, before main(). Used for initialization. Multiple init() functions can exist."
  },
  {
    "question": "What is the main package?",
    "options": [
      "Most important package",
      "Entry point package that defines executable program",
      "Main library",
      "Root package"
    ],
    "correctAnswer": 1,
    "explanation": "The main package defines an executable program (not a library). Must have a main() function which is the entry point of the program."
  },
  {
    "question": "How do you export identifiers from a package?",
    "options": [
      "export keyword",
      "Capitalize the first letter",
      "public keyword",
      "Use exports object"
    ],
    "correctAnswer": 1,
    "explanation": "In Go, identifiers are exported by capitalizing the first letter. Lowercase identifiers are private to the package. No explicit export keyword needed."
  },
  {
    "question": "What are Go modules?",
    "options": [
      "Code modules",
      "Dependency management system for Go projects",
      "Import statements",
      "Package managers"
    ],
    "correctAnswer": 1,
    "explanation": "Go modules is the official dependency management system. go.mod file defines module path and dependencies. Introduced in Go 1.11, standard since 1.13."
  },
  {
    "question": "What does go mod init do?",
    "options": [
      "Initializes variables",
      "Creates a new go.mod file for a module",
      "Installs modules",
      "Imports modules"
    ],
    "correctAnswer": 1,
    "explanation": "go mod init <module-path> creates a new go.mod file, initializing a new module. The module path is typically the repository path where code will be published."
  },
  {
    "question": "What does go mod tidy do?",
    "options": [
      "Cleans code",
      "Adds missing and removes unused module dependencies",
      "Formats code",
      "Organizes imports"
    ],
    "correctAnswer": 1,
    "explanation": "go mod tidy adds missing module dependencies and removes unused ones from go.mod and go.sum. It ensures dependencies match the source code."
  },
  {
    "question": "What is go.sum file?",
    "options": [
      "Summary file",
      "Contains cryptographic checksums of module dependencies",
      "Sum calculations",
      "Build output"
    ],
    "correctAnswer": 1,
    "explanation": "go.sum contains cryptographic checksums of specific module versions. It ensures that future downloads produce the same bits, providing security and reproducibility."
  },
  {
    "question": "What is a WaitGroup?",
    "options": [
      "A waiting room",
      "Sync primitive to wait for collection of goroutines to finish",
      "A time delay",
      "A channel type"
    ],
    "correctAnswer": 1,
    "explanation": "sync.WaitGroup waits for a collection of goroutines to finish. Add() increments counter, Done() decrements, Wait() blocks until counter is zero."
  },
  {
    "question": "What is a Mutex?",
    "options": [
      "Musical term",
      "Mutual exclusion lock for protecting shared data",
      "Multiple execution",
      "A channel"
    ],
    "correctAnswer": 1,
    "explanation": "sync.Mutex (mutual exclusion) provides a locking mechanism to protect shared data from concurrent access. Lock() acquires, Unlock() releases the lock."
  },
  {
    "question": "What's the difference between Mutex and RWMutex?",
    "options": [
      "No difference",
      "RWMutex allows multiple readers or one writer, Mutex allows only one",
      "RWMutex is deprecated",
      "Mutex is faster"
    ],
    "correctAnswer": 1,
    "explanation": "sync.RWMutex allows multiple concurrent readers or a single writer. sync.Mutex allows only one goroutine at a time. RWMutex is better when reads are more frequent."
  },
  {
    "question": "What does close() do with channels?",
    "options": [
      "Deletes channel",
      "Closes channel indicating no more values will be sent",
      "Stops goroutine",
      "Blocks channel"
    ],
    "correctAnswer": 1,
    "explanation": "close(ch) closes a channel, indicating no more values will be sent. Receivers can detect closure with v, ok := <-ch. Only sender should close, never receiver."
  },
  {
    "question": "What happens when you receive from a closed channel?",
    "options": [
      "Error",
      "Returns zero value and false for ok",
      "Blocks forever",
      "Panics"
    ],
    "correctAnswer": 1,
    "explanation": "Receiving from a closed channel immediately returns the zero value of the channel's type and false for the second ok value. Never panics on receive."
  },
  {
    "question": "What happens when you send to a closed channel?",
    "options": [
      "Nothing",
      "Panics",
      "Returns error",
      "Blocks"
    ],
    "correctAnswer": 1,
    "explanation": "Sending to a closed channel causes a panic. This is why only the sender should close channels, and only when absolutely necessary."
  },
  {
    "question": "What is the context package used for?",
    "options": [
      "Text context",
      "Carries deadlines, cancellation signals, and request-scoped values",
      "Application context",
      "Background jobs"
    ],
    "correctAnswer": 1,
    "explanation": "context package carries deadlines, cancellation signals, and request-scoped values across API boundaries and between goroutines. Essential for managing goroutine lifecycles."
  },
  {
    "question": "What does context.Background() return?",
    "options": [
      "Background color",
      "An empty, non-nil context used as root context",
      "A goroutine",
      "Background process"
    ],
    "correctAnswer": 1,
    "explanation": "context.Background() returns non-nil, empty Context. Used as root context for main function, initialization, and tests. Never canceled, has no values or deadline."
  },
  {
    "question": "What does context.WithTimeout do?",
    "options": [
      "Sets timeout",
      "Returns context that automatically cancels after specified duration",
      "Delays execution",
      "Waits for duration"
    ],
    "correctAnswer": 1,
    "explanation": "context.WithTimeout returns a context and cancel function. The context automatically cancels after the specified duration, useful for limiting operation time."
  },
  {
    "question": "What does context.WithCancel return?",
    "options": [
      "Cancel button",
      "A context and cancel function to manually cancel context",
      "Cancellation token",
      "Stop signal"
    ],
    "correctAnswer": 1,
    "explanation": "context.WithCancel returns a copy of parent context and a cancel function. Calling cancel closes Done channel, signaling operations to stop."
  },
  {
    "question": "How do you test if a channel is closed?",
    "options": [
      "ch.closed()",
      "value, ok := <-ch; ok is false if closed",
      "isClosed(ch)",
      "ch == nil"
    ],
    "correctAnswer": 1,
    "explanation": "Use two-value receive: value, ok := <-ch. If ok is false, channel is closed and value is zero value. This is the idiomatic way to detect closure."
  },
  {
    "question": "What is the blank identifier _?",
    "options": [
      "Space character",
      "Used to ignore values you don't need",
      "Empty string",
      "Null value"
    ],
    "correctAnswer": 1,
    "explanation": "The blank identifier _ is a special identifier that ignores values. Used when syntax requires a variable but you don't need the value (e.g., for _, v := range slice)."
  },
  {
    "question": "What does := operator do?",
    "options": [
      "Assignment only",
      "Short variable declaration with type inference",
      "Comparison",
      "Equality check"
    ],
    "correctAnswer": 1,
    "explanation": ":= is short variable declaration that declares and initializes variables with type inference. Only works inside functions, not at package level."
  },
  {
    "question": "What is the difference between = and :=?",
    "options": [
      "No difference",
      "= assigns to existing variables, := declares and assigns new variables",
      "= is older syntax",
      ":= is slower"
    ],
    "correctAnswer": 1,
    "explanation": "= is simple assignment to existing variables. := declares new variables and assigns values (type inferred). Can't use := at package level."
  },
  {
    "question": "What is a variadic function?",
    "options": [
      "Variable function",
      "Function that accepts variable number of arguments",
      "Varying return types",
      "Multiple functions"
    ],
    "correctAnswer": 1,
    "explanation": "Variadic function accepts variable number of arguments using ...Type syntax. Example: func sum(nums ...int). Arguments are received as a slice."
  },
  {
    "question": "How do you pass a slice to a variadic function?",
    "options": [
      "Just pass the slice",
      "Use ... operator: function(slice...)",
      "Convert to array",
      "Loop and pass elements"
    ],
    "correctAnswer": 1,
    "explanation": "Use ... operator after slice name: function(slice...). This unpacks the slice elements as individual arguments to the variadic function."
  },
  {
    "question": "What is type alias in Go?",
    "options": [
      "Alternate name",
      "An alternative name for an existing type using =",
      "New type",
      "Type conversion"
    ],
    "correctAnswer": 1,
    "explanation": "Type alias creates an alternative name for existing type: type MyInt = int. It's identical to the original type, not a new type."
  },
  {
    "question": "What is a type definition versus type alias?",
    "options": [
      "Same thing",
      "Type definition creates new type, alias is just another name",
      "No difference",
      "Alias is deprecated"
    ],
    "correctAnswer": 1,
    "explanation": "type MyInt int creates a new type (requires conversion). type MyInt = int creates an alias (same type). Definitions give type safety, aliases don't."
  },
  {
    "question": "What does make() do?",
    "options": [
      "Makes variables",
      "Allocates and initializes slices, maps, and channels",
      "Makes structs",
      "Compiles code"
    ],
    "correctAnswer": 1,
    "explanation": "make() allocates and initializes slices, maps, and channels. Unlike new(), make returns initialized (not zeroed) value of type T, not *T."
  },
  {
    "question": "What does new() do?",
    "options": [
      "Creates new variables",
      "Allocates zeroed memory and returns pointer",
      "Makes slices",
      "Initializes structs"
    ],
    "correctAnswer": 1,
    "explanation": "new(T) allocates zeroed storage for a new item of type T and returns its address, a value of type *T. The value is zeroed but not initialized."
  },
  {
    "question": "What's the difference between make and new?",
    "options": [
      "No difference",
      "make initializes slices/maps/channels and returns type T, new zeros memory and returns *T",
      "new is deprecated",
      "make is faster"
    ],
    "correctAnswer": 1,
    "explanation": "make() is for slices, maps, channels and returns initialized value of type T. new() works with any type, returns pointer to zeroed memory *T."
  },
  {
    "question": "What is embedding in Go?",
    "options": [
      "Nested loops",
      "Including one struct/interface in another for composition",
      "Inheritance",
      "Import statements"
    ],
    "correctAnswer": 1,
    "explanation": "Embedding is Go's composition mechanism. An embedded type's methods are promoted to the outer type. It's composition without inheritance."
  },
  {
    "question": "What is the len() function?",
    "options": [
      "Length of string only",
      "Returns length of arrays, slices, maps, strings, channels",
      "Line count",
      "Loop length"
    ],
    "correctAnswer": 1,
    "explanation": "len() returns the number of elements in arrays, slices, maps, strings, or buffered elements in channels. Built-in function that works with various types."
  },
  {
    "question": "What is the cap() function?",
    "options": [
      "Capacity of strings",
      "Returns capacity of slices and channels",
      "Capital letters",
      "Maximum value"
    ],
    "correctAnswer": 1,
    "explanation": "cap() returns capacity (maximum size without reallocation) of slices, arrays, and channels. For slices, it's the size of the underlying array."
  },
  {
    "question": "What is the append() function?",
    "options": [
      "Adds to strings",
      "Adds elements to slice end, returns new slice",
      "Appends files",
      "Concatenates arrays"
    ],
    "correctAnswer": 1,
    "explanation": "append() adds elements to the end of a slice. Returns a new slice. If capacity exceeded, a new underlying array is allocated with larger capacity."
  },
  {
    "question": "What is copy() function for?",
    "options": [
      "Duplicates variables",
      "Copies elements from source slice to destination slice",
      "Copies files",
      "Clones objects"
    ],
    "correctAnswer": 1,
    "explanation": "copy(dst, src) copies elements from source slice to destination slice. Returns number of elements copied (minimum of len(dst) and len(src))."
  },
  {
    "question": "What is testing package used for?",
    "options": [
      "Production tests",
      "Writing unit tests and benchmarks",
      "Test data",
      "Testing environments"
    ],
    "correctAnswer": 1,
    "explanation": "testing package provides support for automated testing. Test files end with _test.go. Test functions start with Test, benchmarks with Benchmark."
  },
  {
    "question": "How do you run tests in Go?",
    "options": [
      "test run",
      "go test",
      "run tests",
      "go check"
    ],
    "correctAnswer": 1,
    "explanation": "go test runs all tests in the current package. Use go test ./... to test all packages recursively. Tests must be in *_test.go files."
  },
  {
    "question": "What is t.Run() in tests?",
    "options": [
      "Runs tests",
      "Defines a subtest with a name",
      "Runs goroutines",
      "Executes functions"
    ],
    "correctAnswer": 1,
    "explanation": "t.Run() runs a subtest with a given name. Useful for table-driven tests where you can group related test cases and run them individually."
  },
  {
    "question": "What does t.Error() do in tests?",
    "options": [
      "Creates errors",
      "Reports error but continues test execution",
      "Stops test",
      "Throws exception"
    ],
    "correctAnswer": 1,
    "explanation": "t.Error() marks test as failed and logs message but continues executing the test. Use t.Fatal() to stop test immediately after failure."
  },
  {
    "question": "What's the difference between t.Error() and t.Fatal()?",
    "options": [
      "No difference",
      "t.Error() continues execution, t.Fatal() stops immediately",
      "t.Fatal() is deprecated",
      "t.Error() is for errors only"
    ],
    "correctAnswer": 1,
    "explanation": "t.Error() marks failure but continues test. t.Fatal() marks failure and stops test immediately. Use Fatal for critical failures where continuing is pointless."
  },
  {
    "question": "What is table-driven testing?",
    "options": [
      "Database testing",
      "Using slice of test cases with input/expected output pairs",
      "Testing tables",
      "Excel testing"
    ],
    "correctAnswer": 1,
    "explanation": "Table-driven testing uses a slice of structs containing test inputs and expected outputs. Iterate and run each case, making tests more maintainable."
  },
  {
    "question": "What is reflection in Go?",
    "options": [
      "Mirror image",
      "Runtime inspection of types and values using reflect package",
      "Code reflection",
      "Self-documentation"
    ],
    "correctAnswer": 1,
    "explanation": "Reflection allows runtime inspection and manipulation of types and values. reflect package provides TypeOf() and ValueOf() for examining interface values."
  },
  {
    "question": "What is the reflect.TypeOf() function?",
    "options": [
      "Type conversion",
      "Returns the reflection Type of the value",
      "Type checking",
      "Type definition"
    ],
    "correctAnswer": 1,
    "explanation": "reflect.TypeOf() returns the reflection Type that represents the dynamic type of the interface value. Used for runtime type inspection."
  },
  {
    "question": "What is the reflect.ValueOf() function?",
    "options": [
      "Value conversion",
      "Returns the reflection Value of the interface value",
      "Gets value",
      "Value checking"
    ],
    "correctAnswer": 1,
    "explanation": "reflect.ValueOf() returns a new reflect.Value initialized to the concrete value stored in the interface. Allows inspection and manipulation of values."
  },
  {
    "question": "What is the go keyword?",
    "options": [
      "Go language",
      "Starts a new goroutine",
      "Goto statement",
      "Go function"
    ],
    "correctAnswer": 1,
    "explanation": "The go keyword starts a new goroutine. go function() executes function concurrently in a new lightweight thread managed by Go runtime."
  },
  {
    "question": "What is a buffered channel created with?",
    "options": [
      "make(chan Type)",
      "make(chan Type, capacity)",
      "new(chan Type)",
      "chan Type{size}"
    ],
    "correctAnswer": 1,
    "explanation": "Buffered channels are created with make(chan Type, capacity). The capacity is buffer size. make(chan Type) or make(chan Type, 0) creates unbuffered channel."
  },
  {
    "question": "What happens when a goroutine tries to send on a full buffered channel?",
    "options": [
      "Message is dropped",
      "Goroutine blocks until space is available",
      "Creates larger buffer",
      "Returns error"
    ],
    "correctAnswer": 1,
    "explanation": "When a buffered channel is full, sending goroutine blocks until another goroutine receives from channel, making space available in the buffer."
  },
  {
    "question": "What is a deadlock in Go?",
    "options": [
      "Locked code",
      "All goroutines are blocked waiting, program can't proceed",
      "Security lock",
      "Mutex lock"
    ],
    "correctAnswer": 1,
    "explanation": "Deadlock occurs when all goroutines are blocked waiting for something that will never happen. Go runtime detects deadlocks and panics with 'fatal error: all goroutines are asleep'."
  },
  {
    "question": "What is the select default case?",
    "options": [
      "Default channel",
      "Executed when no other case is ready, prevents blocking",
      "Default value",
      "Fallback option"
    ],
    "correctAnswer": 1,
    "explanation": "The default case in select is executed when no other case is ready. Makes select non-blocking. Useful for polling or implementing timeouts."
  },
  {
    "question": "What does time.After() return?",
    "options": [
      "Time value",
      "A channel that sends time after duration",
      "Timer object",
      "Delay function"
    ],
    "correctAnswer": 1,
    "explanation": "time.After(duration) returns a channel that sends the current time after the specified duration. Commonly used in select for timeouts."
  },
  {
    "question": "What is the difference between time.Sleep() and time.After()?",
    "options": [
      "No difference",
      "Sleep blocks goroutine, After returns channel for select",
      "After is deprecated",
      "Sleep is faster"
    ],
    "correctAnswer": 1,
    "explanation": "time.Sleep() blocks the current goroutine. time.After() returns a channel for use in select, allowing timeout patterns without blocking."
  },
  {
    "question": "What is a race condition?",
    "options": [
      "Racing goroutines",
      "Multiple goroutines access shared data concurrently without synchronization",
      "Speed competition",
      "Timing issue"
    ],
    "correctAnswer": 1,
    "explanation": "Race condition occurs when multiple goroutines access shared data concurrently and at least one modifies it, without proper synchronization. Results are unpredictable."
  },
  {
    "question": "How do you detect race conditions?",
    "options": [
      "Visual inspection",
      "Run tests with -race flag: go test -race",
      "Use debugger",
      "Log everything"
    ],
    "correctAnswer": 1,
    "explanation": "Go's race detector finds race conditions at runtime. Run with -race flag: go run -race or go test -race. Reports concurrent conflicting accesses."
  },
  {
    "question": "What is the sync.Once type?",
    "options": [
      "One-time variable",
      "Ensures action is performed exactly once across multiple goroutines",
      "Single goroutine",
      "One channel"
    ],
    "correctAnswer": 1,
    "explanation": "sync.Once ensures a function is executed exactly once, even when called from multiple goroutines. Useful for one-time initialization."
  },
  {
    "question": "What is the sync.Pool type?",
    "options": [
      "Connection pool",
      "Cache for reusing objects to reduce memory allocations",
      "Thread pool",
      "Goroutine pool"
    ],
    "correctAnswer": 1,
    "explanation": "sync.Pool is a cache for temporary objects that can be reused. Reduces memory allocations and garbage collection pressure. Objects may be removed automatically."
  },
  {
    "question": "What is the atomic package for?",
    "options": [
      "Physics calculations",
      "Atomic operations on primitive types for lock-free synchronization",
      "Small operations",
      "Molecular operations"
    ],
    "correctAnswer": 1,
    "explanation": "sync/atomic provides low-level atomic memory operations for primitive types. Useful for lock-free data structures and counters without mutexes."
  },
  {
    "question": "What is a channel direction?",
    "options": [
      "Data flow direction",
      "Restricting channel to send-only or receive-only",
      "Channel orientation",
      "Message direction"
    ],
    "correctAnswer": 1,
    "explanation": "Channel direction restricts channel use. chan<- T is send-only, <-chan T is receive-only. Used in function signatures to enforce correct usage and prevent mistakes."
  },
  {
    "question": "What does struct{}{} represent?",
    "options": [
      "Empty struct value",
      "Zero-size empty struct value, uses no memory",
      "Null struct",
      "Broken syntax"
    ],
    "correctAnswer": 1,
    "explanation": "struct{}{} is the value of empty struct type. Takes zero bytes of storage. Useful for signaling in channels when no data needs to be sent."
  },
  {
    "question": "What is the iota identifier?",
    "options": [
      "Iterator variable",
      "Constant generator that increments in const blocks",
      "Index variable",
      "Interface identifier"
    ],
    "correctAnswer": 1,
    "explanation": "iota is a predeclared identifier used in const declarations. Represents successive untyped integer constants starting from 0, incrementing by 1 each line."
  },
  {
    "question": "What is Go's convention for package naming?",
    "options": [
      "CamelCase",
      "Short, lowercase, single-word names",
      "snake_case",
      "kebab-case"
    ],
    "correctAnswer": 1,
    "explanation": "Package names should be short, concise, lowercase, single-word names without underscores or mixed caps. Should be evocative and clear about purpose."
  },
  {
    "question": "What is the purpose of go fmt?",
    "options": [
      "Format strings",
      "Automatically formats Go source code to standard style",
      "Format output",
      "File formatting"
    ],
    "correctAnswer": 1,
    "explanation": "go fmt formats Go source code according to standard style. Ensures consistent code formatting across projects. gofmt is the underlying tool."
  },
  {
    "question": "What does go vet do?",
    "options": [
      "Veterinary checks",
      "Examines code for suspicious constructs and potential bugs",
      "Version check",
      "Validates syntax"
    ],
    "correctAnswer": 1,
    "explanation": "go vet examines Go source code and reports suspicious constructs like unreachable code, incorrect function signatures, or common mistakes. Static analysis tool."
  },
  {
    "question": "Output: What is printed by `fmt.Println(len(make([]int, 2, 5)), cap(make([]int, 2, 5)))`?",
    "options": [
      "2 2",
      "2 5",
      "5 5",
      "0 5"
    ],
    "correctAnswer": 1,
    "explanation": "Length is initialized as 2 while capacity is 5."
  },
  {
    "question": "Output: `m := map[string]int{\"a\":1}; v, ok := m[\"b\"];` what are `v` and `ok`?",
    "options": [
      "1 true",
      "0 false",
      "0 true",
      "panic"
    ],
    "correctAnswer": 1,
    "explanation": "Missing key returns zero value and `ok=false`."
  },
  {
    "question": "Tricky: Which statement about interfaces is correct?",
    "options": [
      "Types must explicitly declare implemented interfaces",
      "Interface implementation is implicit in Go",
      "Only structs can implement interfaces",
      "Interfaces cannot be composed"
    ],
    "correctAnswer": 1,
    "explanation": "Go uses structural typing with implicit interface satisfaction."
  },
  {
    "question": "Tricky: What usually causes goroutine leaks?",
    "options": [
      "Using WaitGroup",
      "Blocked sends/receives with no cancellation path",
      "Using buffered channels",
      "Using select statement"
    ],
    "correctAnswer": 1,
    "explanation": "Leaks happen when goroutines block forever due to missing receiver/sender or no cancellation."
  },
  {
    "question": "Which is idiomatic for operation timeout in Go services?",
    "options": [
      "Infinite retry loop",
      "context.WithTimeout + select/propagation",
      "Thread sleep in loop",
      "panic and recover"
    ],
    "correctAnswer": 1,
    "explanation": "Context-based deadlines are idiomatic for cancellable operations across call boundaries."
  },
  {
    "question": "Output: What prints? `s := []int{1,2}; t := s; t[0]=9; fmt.Println(s[0])`",
    "options": [
      "1",
      "9",
      "0",
      "panic"
    ],
    "correctAnswer": 1,
    "explanation": "Slices share backing arrays, so mutation through one view is visible in the other."
  },
  {
    "question": "Which map operation is concurrency-safe without locking?",
    "options": [
      "Concurrent writes",
      "Concurrent read and write",
      "Only read-only concurrent access",
      "None, not even reads"
    ],
    "correctAnswer": 2,
    "explanation": "Read-only concurrent access is safe; writes require synchronization."
  },
  {
    "question": "Output: What prints? `x := 1; defer fmt.Println(x); x = 2`",
    "options": [
      "1",
      "2",
      "panic",
      "depends"
    ],
    "correctAnswer": 0,
    "explanation": "Deferred call arguments are evaluated at defer time, so it prints original value 1."
  },
  {
    "question": "Which package is standard for SQL abstraction in Go?",
    "options": [
      "database/core",
      "database/sql",
      "sql/go",
      "db/stdlib"
    ],
    "correctAnswer": 1,
    "explanation": "database/sql is the standard SQL abstraction package."
  },
  {
    "question": "sql.Open verifies connectivity immediately?",
    "options": [
      "Yes",
      "No, use Ping/PingContext",
      "Only for postgres",
      "Only after first query"
    ],
    "correctAnswer": 1,
    "explanation": "Use Ping for connectivity check."
  },
  {
    "question": "redis.Nil usually means:",
    "options": [
      "Redis down",
      "Auth failed",
      "Missing key",
      "Timeout"
    ],
    "correctAnswer": 2,
    "explanation": "redis.Nil indicates key not found."
  },
  {
    "question": "Status code for successful creation is:",
    "options": [
      "200",
      "201",
      "204",
      "400"
    ],
    "correctAnswer": 1,
    "explanation": "Use 201 Created."
  },
  {
    "question": "Which built-in may require reassignment of result?",
    "options": [
      "len",
      "cap",
      "append",
      "delete"
    ],
    "correctAnswer": 2,
    "explanation": "append can return a new slice header/backing array."
  },
  {
    "question": "Writing to nil map causes:",
    "options": [
      "No-op",
      "Compile error",
      "Runtime panic",
      "Deadlock"
    ],
    "correctAnswer": 2,
    "explanation": "Nil map write panics."
  },
  {
    "question": "db.QueryRowContext missing row should be checked against:",
    "options": [
      "io.EOF",
      "sql.ErrNoRows",
      "redis.Nil",
      "nil"
    ],
    "correctAnswer": 1,
    "explanation": "Missing SQL row returns sql.ErrNoRows."
  },
  {
    "question": "SetNX behavior in Redis is:",
    "options": [
      "Always overwrite",
      "Set only when key absent",
      "Delete if exists",
      "Set without expiry only"
    ],
    "correctAnswer": 1,
    "explanation": "SetNX writes only if key does not already exist."
  },
  {
    "question": "Malformed JSON request body should usually return:",
    "options": [
      "200",
      "201",
      "400",
      "500"
    ],
    "correctAnswer": 2,
    "explanation": "Malformed body is a client error: 400 Bad Request."
  },
  {
    "question": "Output-oriented: len(make([]int, 0, 5)) equals:",
    "options": [
      "0",
      "5",
      "1",
      "panic"
    ],
    "correctAnswer": 0,
    "explanation": "Length is 0, capacity is 5."
  },
  {
    "question": "Output-oriented: cap(make([]int, 0, 5)) equals:",
    "options": [
      "0",
      "5",
      "1",
      "panic"
    ],
    "correctAnswer": 1,
    "explanation": "Capacity is 5."
  },
  {
    "question": "delete(map, missingKey) behavior is:",
    "options": [
      "panic",
      "no-op",
      "error returned",
      "deletes all keys"
    ],
    "correctAnswer": 1,
    "explanation": "Delete on missing key is safe."
  },
  {
    "question": "Why pass r.Context() to repository layer?",
    "options": [
      "For syntax",
      "For timeout/cancel propagation",
      "For static typing",
      "For panic recovery"
    ],
    "correctAnswer": 1,
    "explanation": "Request context carries deadlines and cancellation."
  }
]