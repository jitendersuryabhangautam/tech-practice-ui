{
  "id": "docker-build",
  "title": "Building Images",
  "category": "Docker Basics",
  "description": "Build Docker images from Dockerfile and manage them.",
  "explanation": "Building Docker images is the process of creating runnable containers from Dockerfiles. Understanding build context, layer caching, tagging strategies, and registry operations is essential for efficient CI/CD pipelines.\n\nInterview focus:\n- Build context and optimization\n- Image tagging and versioning strategies\n- Registry operations (push/pull)\n- BuildKit features\n- Multi-platform builds\n- Build caching and optimization",
  "command": "# Build image from Dockerfile\ndocker build -t myapp:1.0 .\n\n# Build with build arguments\ndocker build --build-arg VERSION=1.0 -t myapp:1.0 .\n\n# Build with specific Dockerfile\ndocker build -f Dockerfile.prod -t myapp:prod .\n\n# Build without cache\ndocker build --no-cache -t myapp:1.0 .\n\n# Tag an image\ndocker tag myapp:1.0 myapp:latest\ndocker tag myapp:1.0 myregistry.com/myapp:1.0\n\n# Push image to registry\ndocker push myregistry.com/myapp:1.0\n\n# Save image to tar file\ndocker save myapp:1.0 > myapp.tar\n\n# Load image from tar file\ndocker load < myapp.tar",
  "example": "# Build arg in Dockerfile\nARG NODE_VERSION=18\nFROM node:${NODE_VERSION}\nARG APP_VERSION\nENV VERSION=${APP_VERSION}\n\n# Build with args\ndocker build --build-arg NODE_VERSION=20 --build-arg APP_VERSION=2.0 -t myapp .\n\n# Multi-platform build\ndocker buildx build --platform linux/amd/64,linux/arm64 -t myapp .",
  "useCase": "Creating deployable images, versioning, registry management",
  "interviewQuestions": [
    {
      "question": "What is the Docker build context?",
      "answer": "Build context is the set of files at the specified PATH or URL sent to Docker daemon. Everything in context is available to COPY/ADD. Large contexts slow builds. Use .dockerignore to exclude unnecessary files."
    },
    {
      "question": "How does Docker determine if it can use cache for a layer?",
      "answer": "Docker checks if instruction and files haven't changed. For COPY/ADD, checks file checksums. For RUN, checks command string. If parent layers changed, cache is invalidated for all subsequent layers."
    },
    {
      "question": "What is the difference between docker save and docker export?",
      "answer": "docker save saves images with all layers, tags, and history (use with docker load). docker export exports container filesystem as flat tar (loses history, use with docker import). Save for images, export for containers."
    },
    {
      "question": "Explain semantic versioning for Docker image tags.",
      "answer": "Use major.minor.patch format (e.g., 1.2.3). Tag with specific version, update minor/major tags: myapp:1.2.3, myapp:1.2, myapp:1, myapp:latest. Allows users to pin to specific version or track updates."
    },
    {
      "question": "What is Docker BuildKit and its advantages?",
      "answer": "BuildKit is the improved Docker build backend. Features: parallel builds, build secrets, SSH forwarding, better caching, build progress output. Enable with DOCKER_BUILDKIT=1 or in daemon config."
    },
    {
      "question": "How do you handle image tags in CI/CD?",
      "answer": "Tag with commit SHA, branch name, semantic version. Example: myapp:sha-abc123, myapp:main, myapp:v1.2.3, myapp:latest. Use immutable tags (SHA) for production, mutable (latest) for dev."
    },
    {
      "question": "What is a Docker registry and how does authentication work?",
      "answer": "Registry stores Docker images (Docker Hub, ECR, GCR). docker login stores credentials. docker push uploads images, docker pull downloads. Private registries require authentication via login or config.json."
    },
    {
      "question": "How do you build images for multiple architectures?",
      "answer": "Use docker buildx with --platform flag: docker buildx build --platform linux/amd64,linux/arm64,linux/arm/v7 -t myapp --push. Requires BuildKit and buildx. Creates manifest list."
    },
    {
      "question": "What is the purpose of docker build --target?",
      "answer": "In multi-stage builds, --target stops at specific stage. Example: docker build --target development for dev image with debug tools, --target production for optimized prod image. Same Dockerfile, different outputs."
    },
    {
      "question": "How do you inspect image layers and history?",
      "answer": "Use docker history imagename to see layers, commands, and sizes. Use docker inspect for detailed JSON metadata. Tools like dive can analyze and optimize layer sizes interactively."
    }
  ],
  "exercises": [
    {
      "type": "command",
      "question": "Build image tagged as myapp:v2.1.0 from current directory",
      "answer": "docker build -t myapp:v2.1.0 ."
    },
    {
      "type": "command",
      "question": "Build without cache using Dockerfile.production, tag as myapp:prod",
      "answer": "docker build --no-cache -f Dockerfile.production -t myapp:prod ."
    },
    {
      "type": "scenario",
      "question": "You need to pass DB_VERSION=postgres:15 at build time. How?",
      "answer": "Add ARG DB_VERSION in Dockerfile. Build with: docker build --build-arg DB_VERSION=postgres:15 -t myapp ."
    },
    {
      "type": "command",
      "question": "Tag existing image localhost:5000/myapp:1.0 to push to Docker Hub as username/myapp:latest",
      "answer": "docker tag localhost:5000/myapp:1.0 username/myapp:latest"
    },
    {
      "type": "troubleshoot",
      "question": "Build is very slow, sending 2GB context. How to diagnose and fix?",
      "answer": "Check build context size with docker build output. Add .dockerignore to exclude node_modules, .git, logs, test files. Only include necessary files."
    },
    {
      "type": "scenario",
      "question": "How to save image to file for offline transfer to another machine?",
      "answer": "docker save myapp:1.0 -o myapp.tar (or > myapp.tar). Transfer file. Load with: docker load -i myapp.tar (or < myapp.tar)."
    },
    {
      "type": "explain",
      "question": "What's the benefit of tagging with both specific version and latest?",
      "answer": "Specific version for reproducibility and rollback. Latest for convenience and dev environments. Tag both: docker tag myapp:1.2.3 myapp:latest."
    },
    {
      "type": "command",
      "question": "View detailed build history and layer sizes for nginx image",
      "answer": "docker history nginx"
    },
    {
      "type": "scenario",
      "question": "Build only the 'builder' stage from multi-stage Dockerfile",
      "answer": "docker build --target builder -t myapp-builder ."
    },
    {
      "type": "security",
      "question": "Why shouldn't you use docker commit for production images?",
      "answer": "Not reproducible, no version control, includes all container changes (may include secrets/temp files), can't leverage caching. Always use Dockerfile."
    }
  ],
  "programExercises": [
    {
      "type": "program",
      "question": "Program 1: Build image with version tag and latest tag in one command",
      "code": "docker build -t myapp:1.0.0 -t myapp:latest .\n# Or build once then tag:\ndocker build -t myapp:1.0.0 .\ndocker tag myapp:1.0.0 myapp:latest",
      "output": "Image tagged with both specific version and latest"
    },
    {
      "type": "program",
      "question": "Program 2: Build with build arg, verify ENV is set in container",
      "code": "docker build --build-arg APP_ENV=production -t myapp .\ndocker run --rm myapp env | grep APP_ENV",
      "output": "Shows APP_ENV=production in container environment"
    },
    {
      "type": "program",
      "question": "Program 3: Save image to tar, remove image, reload from tar",
      "code": "docker save myapp:1.0 -o myapp.tar\ndocker rmi myapp:1.0\ndocker load -i myapp.tar\ndocker images | grep myapp",
      "output": "Image successfully restored from tar file"
    },
    {
      "type": "program",
      "question": "Program 4: View image history to identify largest layers",
      "code": "docker history myapp --format \"table {{.Size}}\\t{{.CreatedBy}}\" --no-trunc",
      "output": "Shows layer sizes and commands that created them"
    },
    {
      "type": "program",
      "question": "Program 5: Build without cache, compare build time with cached build",
      "code": "time docker build --no-cache -t myapp:nocache .\ntime docker build -t myapp:cached .",
      "output": "Shows significant time difference, cached build much faster"
    },
    {
      "type": "program",
      "question": "Program 6: Tag image for different registries (Docker Hub and private)",
      "code": "docker tag myapp:1.0 username/myapp:1.0\ndocker tag myapp:1.0 registry.company.com/myapp:1.0\ndocker images | grep myapp",
      "output": "Same image ID with multiple registry tags"
    },
    {
      "type": "program",
      "question": "Program 7: Build target stage from multi-stage Dockerfile",
      "code": "docker build --target development -t myapp:dev .\ndocker build --target production -t myapp:prod .\ndocker images | grep myapp",
      "output": "Two different images from same Dockerfile, different stages"
    }
  ]
}