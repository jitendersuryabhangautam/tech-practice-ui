{
  "id": "networks",
  "title": "Docker Networks",
  "category": "Docker Networking & Volumes",
  "description": "Container networking for communication between containers.",
  "explanation": "Docker networking enables containers to communicate with each other and external systems. Docker creates isolated network namespaces for each container and provides pluggable network drivers for different use cases.\n\nNetwork drivers:\n- bridge (default): Creates a virtual bridge on the host. Containers on the same bridge talk via IP. User-defined bridges also provide DNS resolution by container name. Best for single-host multi-container apps.\n- host: Removes network isolation — container shares the host's network stack directly. No port mapping needed (or possible). Best for performance-critical apps or when you need to bind to many ports.\n- overlay: Multi-host networking for Docker Swarm or container orchestration. Uses VXLAN to encapsulate traffic between hosts. Enables cross-node container communication.\n- macvlan: Assigns a MAC address to each container, making it appear as a physical device on the network. Containers get IPs from the physical network's DHCP. Best for legacy apps that expect to be directly on the LAN.\n- none: Disables all networking. Container is completely isolated. Use for security-sensitive batch jobs.\n\nDNS resolution: User-defined bridge networks (not the default bridge) provide automatic DNS. Container name = hostname. This is why you should always create custom networks instead of using the default bridge.\n\nPort mapping: `-p 8080:80` maps host port 8080 to container port 80. `-p 80` maps container port 80 to a random host port. `-P` publishes all EXPOSE'd ports to random host ports. Use `docker port <container>` to see mappings.\n\nNetwork isolation: Containers on different networks cannot communicate. Connect a container to multiple networks with `docker network connect`. This pattern is used to create DMZ-like architectures (frontend talks to backend, backend talks to database, frontend cannot reach database).\n\nCommon gotcha: The default bridge network does NOT support DNS. Containers must use IP addresses. Always create a user-defined bridge: `docker network create mynet`.",
  "command": "# List networks\ndocker network ls\n\n# Create network\ndocker network create my-network\n\n# Create bridge network\ndocker network create --driver bridge my-bridge\n\n# Inspect network\ndocker network inspect my-network\n\n# Connect container to network\ndocker network connect my-network container-name\n\n# Disconnect container from network\ndocker network disconnect my-network container-name\n\n# Run container on specific network\ndocker run -d --network my-network --name web nginx\n\n# Remove network\ndocker network rm my-network",
  "example": "# Create custom bridge network\ndocker network create --subnet=172.18.0.0/16 my-custom-network\n\n# Run containers on same network\ndocker run -d --network my-network --name db postgres\ndocker run -d --network my-network --name web -p 80:80 nginx\n\n# Containers can communicate using names\n# From 'web' container: curl http://db:5432\n\n# Host network (share host's network)\ndocker run -d --network host nginx",
  "useCase": "Microservices communication, container isolation, service discovery",
  "interviewQuestions": [
    {
      "question": "What are the different Docker network drivers?",
      "answer": "Bridge (default, isolated network), host (share host network), overlay (multi-host Swarm), macvlan (assign MAC addresses), none (no networking). Each suits different use cases."
    },
    {
      "question": "How do containers on the same custom bridge network communicate?",
      "answer": "By container name via Docker's embedded DNS server. Example: curl http://container-name:port. Default bridge requires --link or IP addresses. Custom bridge is recommended."
    },
    {
      "question": "What is the difference between -p and --expose?",
      "answer": "-p publishes port to host (accessible externally): -p 8080:80. --expose only documents port (doesn't publish). EXPOSE in Dockerfile also just documents, needs -P or -p to publish."
    },
    {
      "question": "When would you use host network mode?",
      "answer": "For maximum performance (no network overhead), when container needs host network stack, or binding to many ports. Drawback: loses network isolation, port conflicts possible."
    },
    {
      "question": "How does Docker DNS work?",
      "answer": "Docker runs embedded DNS server (127.0.0.11). Containers on custom networks can resolve each other by name. Maps container names to IP addresses automatically. Default bridge doesn't have DNS (needs --link)."
    },
    {
      "question": "What is an overlay network?",
      "answer": "Overlay networks span multiple Docker hosts in Swarm mode. Enables container communication across hosts. Uses VXLAN tunneling. Required for multi-host deployments and orchestration."
    },
    {
      "question": "How do you isolate containers from each other?",
      "answer": "Put them on different networks. Containers can only communicate if on same network. Use network segmentation for microservices. Connect containers to multiple networks if needed."
    },
    {
      "question": "What happens to container networking when you docker stop?",
      "answer": "Container keeps its IP and network connections but stops responding. Network interface stays registered. On restart with docker start, same IP is typically reassigned (not guaranteed)."
    },
    {
      "question": "How do you connect a running container to a new network?",
      "answer": "Use docker network connect: docker network connect my-network container-name. Container can be on multiple networks. Each network assigns separate IP address."
    },
    {
      "question": "What is the default Docker bridge network?",
      "answer": "docker0 bridge, created automatically. Containers use it by default. Limited features: no DNS, requires --link. Best practice: create custom bridge networks with docker network create."
    }
  ],
  "exercises": [
    {
      "type": "command",
      "question": "Create custom bridge network named app-network",
      "answer": "docker network create app-network"
    },
    {
      "type": "scenario",
      "question": "Run nginx and postgres on same network so nginx can connect to postgres by name",
      "answer": "docker network create mynet\ndocker run -d --network mynet --name db postgres\ndocker run -d --network mynet --name web nginx\n# Web can access: http://db:5432"
    },
    {
      "type": "command",
      "question": "Inspect network to see connected containers and subnet",
      "answer": "docker network inspect my-network"
    },
    {
      "type": "troubleshoot",
      "question": "Container can't resolve other container by name. Why?",
      "answer": "Likely on default bridge network (no DNS). Create custom bridge network and put both containers on it, or use --link (deprecated)."
    },
    {
      "type": "command",
      "question": "Connect running container named api to network named backend",
      "answer": "docker network connect backend api"
    },
    {
      "type": "explain",
      "question": "What is the output of docker network ls?",
      "answer": "Lists all networks: NETWORK ID, NAME, DRIVER, SCOPE. Shows bridge, host, none by default, plus any custom networks."
    },
    {
      "type": "scenario",
      "question": "You need container to access host services on localhost. How?",
      "answer": "Use host.docker.internal (Mac/Windows) or host network mode (--network host on Linux). Or use host IP address."
    },
    {
      "type": "security",
      "question": "Why is network isolation important?",
      "answer": "Prevents unauthorized access between containers. Apply least privilege: only connect containers that need to communicate. Separate frontend/backend/database networks."
    },
    {
      "type": "command",
      "question": "Remove network (but it fails if containers are connected)",
      "answer": "docker network rm my-network\n# If fails: disconnect containers first or docker network rm -f"
    },
    {
      "type": "scenario",
      "question": "Create network with custom subnet 10.0.0.0/24 and gateway 10.0.0.1",
      "answer": "docker network create --subnet=10.0.0.0/24 --gateway=10.0.0.1 my-network"
    }
  ],
  "programExercises": [
    {
      "type": "program",
      "question": "Program 1: Create network, run two containers, verify they can ping each other by name",
      "code": "docker network create testnet\ndocker run -d --network testnet --name c1 alpine sleep 3600\ndocker run -d --network testnet --name c2 alpine sleep 3600\ndocker exec c1 ping -c 2 c2",
      "output": "Successful ping from c1 to c2 using container name"
    },
    {
      "type": "program",
      "question": "Program 2: Inspect network to find container IP addresses",
      "code": "docker network inspect testnet --format=\"{{json .Containers}}\" | jq",
      "output": "JSON showing containers with their IPs on the network"
    },
    {
      "type": "program",
      "question": "Program 3: Run container on host network, verify it uses host IP",
      "code": "docker run --rm --network host alpine ip addr show\n# Compare with host:\nip addr show",
      "output": "Container shows same network interfaces as host"
    },
    {
      "type": "program",
      "question": "Program 4: Connect existing container to additional network",
      "code": "docker network create net1\ndocker network create net2\ndocker run -d --network net1 --name multi alpine sleep 3600\ndocker network connect net2 multi\ndocker inspect multi --format='{{range .NetworkSettings.Networks}}{{.IPAddress}} {{end}}'",
      "output": "Container has IP address on both networks"
    },
    {
      "type": "program",
      "question": "Program 5: Port mapping - map container port 80 to host port 8080",
      "code": "docker run -d -p 8080:80 --name web nginx\ncurl http://localhost:8080",
      "output": "Nginx welcome page accessible on host port 8080"
    },
    {
      "type": "program",
      "question": "Program 6: Test network isolation - containers on different networks can't communicate",
      "code": "docker network create net-a\ndocker network create net-b\ndocker run -d --network net-a --name container-a alpine sleep 3600\ndocker run -d --network net-b --name container-b alpine sleep 3600\ndocker exec container-a ping -c 2 container-b",
      "output": "Ping fails - containers isolated on separate networks"
    },
    {
      "type": "program",
      "question": "Program 7: Create network with custom subnet and run container in it",
      "code": "docker network create --subnet=192.168.100.0/24 custom-subnet\ndocker run -d --network custom-subnet --ip 192.168.100.10 --name static-ip nginx\ndocker inspect static-ip --format='{{.NetworkSettings.Networks.custom-subnet.IPAddress}}'",
      "output": "Container assigned static IP 192.168.100.10"
    },
    {
      "type": "program",
      "question": "Program 8: Test DNS resolution between containers on user-defined network",
      "code": "docker network create dns-test\ndocker run -d --network dns-test --name webserver nginx\ndocker run --rm --network dns-test alpine nslookup webserver",
      "output": "Name: webserver, Address: 172.x.x.x — DNS resolves container name to IP"
    },
    {
      "type": "program",
      "question": "Program 9: Use host network mode and compare with bridge",
      "code": "docker run -d --network host --name host-nginx nginx\nss -tlnp | grep :80\ndocker run -d -p 8080:80 --name bridge-nginx nginx\ndocker port bridge-nginx",
      "output": "Host mode: nginx binds directly to host port 80. Bridge mode: mapped 8080->80"
    },
    {
      "type": "program",
      "question": "Program 10: Inspect default bridge vs user-defined bridge network differences",
      "code": "docker network inspect bridge --format='{{.IPAM.Config}}'\ndocker network create my-bridge\ndocker network inspect my-bridge --format='Driver={{.Driver}} EnableIPv6={{.EnableIPv6}}'\ndocker network inspect my-bridge --format='{{json .Options}}'",
      "output": "Both use bridge driver, but user-defined enables DNS, ICC, and isolation by default"
    }
  ]
}