{
  "id": "join-index-partition-deep-dive",
  "title": "Joins + Indexes + Partitioning Deep Dive",
  "description": "Master join semantics, index design, and partition strategy for large PostgreSQL workloads.",
  "explanation": "Most production performance issues come from data shape and access path mismatch. Choose join types intentionally, index for filter + sort patterns, and partition only when table growth justifies operational complexity.",
  "code": "-- CANONICAL E-COMMERCE SCHEMA\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  first_name VARCHAR(100) NOT NULL,\n  last_name VARCHAR(100) NOT NULL,\n  email VARCHAR(255) UNIQUE NOT NULL,\n  role VARCHAR(20) NOT NULL DEFAULT 'customer',\n  created_at TIMESTAMP DEFAULT NOW(),\n  updated_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE TABLE products (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(255) NOT NULL,\n  sku VARCHAR(100) UNIQUE NOT NULL,\n  price DECIMAL(10,2) NOT NULL,\n  stock_quantity INT NOT NULL DEFAULT 0,\n  category VARCHAR(100),\n  image_url TEXT,\n  created_at TIMESTAMP DEFAULT NOW(),\n  updated_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE TABLE orders (\n  id SERIAL PRIMARY KEY,\n  order_number VARCHAR(50) UNIQUE NOT NULL,\n  user_id INT NOT NULL REFERENCES users(id),\n  total_amount DECIMAL(10,2) NOT NULL,\n  status VARCHAR(20) NOT NULL,\n  payment_method VARCHAR(20),\n  shipping_address JSONB,\n  billing_address JSONB,\n  created_at TIMESTAMP DEFAULT NOW(),\n  updated_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE TABLE order_items (\n  id SERIAL PRIMARY KEY,\n  order_id INT NOT NULL REFERENCES orders(id),\n  product_id INT NOT NULL REFERENCES products(id),\n  quantity INT NOT NULL,\n  price_at_time DECIMAL(10,2) NOT NULL\n);\n\nCREATE TABLE payments (\n  id SERIAL PRIMARY KEY,\n  order_id INT NOT NULL REFERENCES orders(id),\n  amount DECIMAL(10,2) NOT NULL,\n  payment_method VARCHAR(20) NOT NULL,\n  status VARCHAR(20) NOT NULL,\n  transaction_id VARCHAR(100),\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Composite and partial indexes for common access paths\nCREATE INDEX idx_orders_user_created ON orders(user_id, created_at DESC);\nCREATE INDEX idx_orders_completed_recent ON orders(created_at DESC) WHERE status = 'completed';\n\n-- Example partitioned table by month\nCREATE TABLE orders_part (\n  id BIGINT,\n  user_id BIGINT,\n  status TEXT,\n  created_at TIMESTAMP NOT NULL\n) PARTITION BY RANGE (created_at);\n\nCREATE TABLE orders_part_2026_01 PARTITION OF orders_part\nFOR VALUES FROM ('2026-01-01') TO ('2026-02-01');\n\nCREATE TABLE orders_part_2026_02 PARTITION OF orders_part\nFOR VALUES FROM ('2026-02-01') TO ('2026-03-01');",
  "example": "-- Partition pruning check\nEXPLAIN ANALYZE\nSELECT COUNT(*)\nFROM orders_part\nWHERE created_at >= '2026-02-01'\n  AND created_at < '2026-03-01';\n\n-- Join with selective predicate\nEXPLAIN ANALYZE\nSELECT o.id, u.email\nFROM orders o\nJOIN users u ON u.id = o.user_id\nWHERE o.status = 'completed'\n  AND o.created_at >= NOW() - INTERVAL '7 days';",
  "useCase": "High-volume order systems, low-latency dashboards, retention windows, and cost-aware performance tuning.",
  "category": "Performance & Optimization",
  "interviewQuestions": [
    {
      "question": "Why does composite index column order matter?",
      "answer": "PostgreSQL uses leftmost prefix rules; `(a,b)` helps queries on `a` and `a,b`, not `b` alone efficiently."
    },
    {
      "question": "When is partial index better than full index?",
      "answer": "When most queries target a subset like `status = 'completed'`, partial index reduces size and write overhead."
    },
    {
      "question": "What is partition pruning?",
      "answer": "Planner excludes irrelevant partitions when predicates constrain the partition key."
    }
  ],
  "exercises": [
    {
      "type": "implement",
      "question": "Design an index for `WHERE user_id = ? ORDER BY created_at DESC LIMIT 20`."
    },
    {
      "type": "scenario",
      "question": "Choose between BRIN and B-tree for very large append-only table and justify."
    },
    {
      "type": "debug",
      "question": "A partitioned table scans all partitions; identify likely predicate mistakes."
    }
  ],
  "programExercises": [
    {
      "question": "Anti-join users with no orders",
      "code": "SELECT u.id FROM users u LEFT JOIN orders o ON o.user_id = u.id WHERE o.id IS NULL;",
      "output": "Users who have not placed any order."
    }
  ]
}
