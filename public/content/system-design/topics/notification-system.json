{
  "id": "notification-system",
  "title": "Notification System Design",
  "category": "Company HLD",
  "description": "Design a scalable notification system handling push, SMS, email, and in-app notifications with delivery guarantees, user preferences, and rate limiting.",
  "explanation": "A notification system sits between event producers (services) and notification channels (push, email, SMS, in-app). It must handle billions of notifications daily, respect user preferences, ensure at-least-once delivery, and prevent spam.\n\n**Core Architecture**:\n1. **Notification Service (API)**: Receives notification requests from internal services.\n2. **Validation & Preference Engine**: Checks user preferences (opt-in, DND, frequency caps).\n3. **Priority Queue**: Urgent (OTP, payment) vs normal (marketing, social).\n4. **Channel Adapters**: Push (APNs/FCM), Email (SES/SendGrid), SMS (Twilio), In-App (WebSocket).\n5. **Delivery Tracker**: Tracks sent/delivered/failed status per notification.\n6. **Template Engine**: Renders notification content from templates + variables.\n\n**Notification Flow**:\n1. Producer service calls: POST /notify { userId, type, channel, template, data }.\n2. Notification Service validates payload, checks rate limits.\n3. Fetches user preferences: is this channel enabled? DND active?\n4. Enqueues to priority queue (Kafka topics: high/medium/low priority).\n5. Consumer picks message → Template Engine renders content.\n6. Channel Adapter sends via appropriate provider.\n7. Response tracked: delivered / bounced / failed.\n8. Retry on failure (exponential backoff, max 3 retries).\n\n**User Preferences Model**:\n- Global: notifications enabled/disabled.\n- Per channel: push=on, email=off, sms=on.\n- Per category: marketing=off, transactional=on, social=on.\n- DND schedule: no notifications between 10pm - 8am.\n- Frequency cap: max 5 marketing emails/day.\n\n**Rate Limiting**:\n- Per user: max N notifications per channel per time window.\n- Global: max throughput per channel (APNs rate limits, SMS provider limits).\n- Backpressure: if queue depth exceeds threshold, reject low-priority notifications.\n\n**Analytics**:\n- Delivery rate, open rate, click rate.\n- Channel performance comparison.\n- Notification fatigue detection.\n- A/B testing for templates.",
  "code": "// Notification system simulation\nclass NotificationSystem {\n  constructor() {\n    this.queue = { high: [], medium: [], low: [] };\n    this.preferences = new Map();\n    this.delivered = [];\n    this.rateLimits = new Map(); // userId:channel -> { count, windowStart }\n    this.templates = new Map();\n  }\n\n  registerTemplate(name, template) {\n    this.templates.set(name, template);\n  }\n\n  setPreference(userId, prefs) {\n    this.preferences.set(userId, { push: true, email: true, sms: true, dnd: null, ...prefs });\n  }\n\n  checkRateLimit(userId, channel, maxPerWindow = 5, windowMs = 3600000) {\n    const key = `${userId}:${channel}`;\n    const now = Date.now();\n    const limit = this.rateLimits.get(key) || { count: 0, windowStart: now };\n    if (now - limit.windowStart > windowMs) {\n      limit.count = 0;\n      limit.windowStart = now;\n    }\n    if (limit.count >= maxPerWindow) return false;\n    limit.count++;\n    this.rateLimits.set(key, limit);\n    return true;\n  }\n\n  notify(request) {\n    const { userId, channel, priority = 'medium', template, data } = request;\n    const prefs = this.preferences.get(userId) || {};\n    \n    // Check preference\n    if (prefs[channel] === false) return { status: 'BLOCKED', reason: 'User opted out' };\n    \n    // Check DND\n    if (prefs.dnd) {\n      const hour = new Date().getHours();\n      if (hour >= prefs.dnd.start || hour < prefs.dnd.end) {\n        return { status: 'DEFERRED', reason: 'DND active' };\n      }\n    }\n    \n    // Check rate limit\n    if (!this.checkRateLimit(userId, channel)) {\n      return { status: 'THROTTLED', reason: 'Rate limit exceeded' };\n    }\n    \n    // Render template\n    let content = template;\n    if (this.templates.has(template)) {\n      content = this.templates.get(template);\n      Object.entries(data || {}).forEach(([k, v]) => {\n        content = content.replace(`{{${k}}}`, v);\n      });\n    }\n    \n    // Enqueue\n    const notification = { id: `n_${Date.now()}`, userId, channel, content, priority, createdAt: Date.now() };\n    this.queue[priority].push(notification);\n    return { status: 'QUEUED', id: notification.id, priority };\n  }\n\n  processQueue() {\n    const results = [];\n    for (const priority of ['high', 'medium', 'low']) {\n      while (this.queue[priority].length > 0) {\n        const notif = this.queue[priority].shift();\n        notif.status = 'DELIVERED';\n        notif.deliveredAt = Date.now();\n        this.delivered.push(notif);\n        results.push({ id: notif.id, channel: notif.channel, status: 'DELIVERED' });\n      }\n    }\n    return results;\n  }\n}\n\nconst ns = new NotificationSystem();\nns.registerTemplate('welcome', 'Welcome {{name}}! Your account is ready.');\nns.setPreference('u1', { push: true, email: true, sms: false });\n\nconsole.log(ns.notify({ userId: 'u1', channel: 'push', priority: 'high', template: 'welcome', data: { name: 'Alice' } }));\nconsole.log(ns.notify({ userId: 'u1', channel: 'sms', template: 'OTP: 1234' }));\nconsole.log(ns.processQueue());",
  "example": "// Template engine with multi-channel rendering\nclass TemplateEngine {\n  constructor() { this.templates = new Map(); }\n  register(name, channels) {\n    this.templates.set(name, channels);\n  }\n  render(name, channel, data) {\n    const tmpl = this.templates.get(name)?.[channel];\n    if (!tmpl) return { error: `No template: ${name}/${channel}` };\n    let content = tmpl;\n    Object.entries(data).forEach(([k, v]) => {\n      content = content.replace(new RegExp(`{{${k}}}`, 'g'), v);\n    });\n    return { channel, content };\n  }\n}\n\nconst te = new TemplateEngine();\nte.register('order_shipped', {\n  push: 'Your order #{{orderId}} has shipped!',\n  email: 'Hi {{name}},\\nGreat news! Order #{{orderId}} is on its way. Track: {{trackUrl}}',\n  sms: 'Order #{{orderId}} shipped. Track at {{trackUrl}}',\n});\n\nconst data = { name: 'Alice', orderId: '12345', trackUrl: 'https://track.me/12345' };\nconsole.log(te.render('order_shipped', 'push', data));\nconsole.log(te.render('order_shipped', 'email', data));\nconsole.log(te.render('order_shipped', 'sms', data));",
  "useCase": "Mobile app push notifications, transactional emails, OTP delivery, marketing campaigns, real-time in-app alerts, order status updates, security alerts.",
  "interviewQuestions": [
    { "question": "How do you ensure at-least-once delivery?", "answer": "Use a persistent message queue (Kafka). Consumer processes notification, sends via channel adapter. On success → commit offset. On failure → message stays in queue for retry. Idempotency key on notification_id prevents duplicates at the channel adapter level. Dead-letter queue after max retries." },
    { "question": "How do you handle different notification priorities?", "answer": "Separate Kafka topics or priority lanes in queue: HIGH (OTP, security alerts — process immediately), MEDIUM (social, transactional — seconds delay OK), LOW (marketing — minutes delay OK). Each lane has its own consumer group. High-priority consumers run with more instances and resources." },
    { "question": "How do you prevent notification fatigue?", "answer": "Frequency caps: max N per channel per day/hour. Category budgets: max 3 marketing emails/week. Smart batching: combine multiple low-priority notifications into digest. User engagement tracking: reduce frequency for users who don't open. Time-of-day optimization: send when user is most active." },
    { "question": "How do you implement DND (Do Not Disturb)?", "answer": "Store DND schedule per user (start_hour, end_hour, timezone). Before sending: check if current time in user's timezone falls in DND window. If yes: for urgent (OTP) — send anyway; for normal — enqueue in delayed queue with scheduled delivery at DND end time. Respect timezone conversions." },
    { "question": "How do you design the notification preference model?", "answer": "Hierarchical: Global toggle → Channel toggle (push/email/sms) → Category toggle (marketing/social/transactional) → Per-source toggle. Store as JSON document or normalized tables. Evaluate top-down: if global off, block all. If channel off, block that channel. Category and source granularity for fine control." },
    { "question": "How do you handle push notification token management?", "answer": "Each device registers token (FCM/APNs) → store in device_tokens table (user_id, device_id, token, platform, updated_at). On app update: refresh token. On uninstall: token becomes invalid → detect via provider feedback (APNs: 410 response, FCM: NotRegistered). Clean up stale tokens periodically. User can have multiple tokens (multiple devices)." },
    { "question": "How do you scale to billions of notifications per day?", "answer": "Kafka for durable queuing with partitioning. Partition by user_id for ordering. Multiple consumer groups per channel. Batch API calls to providers (FCM supports multicast to 500 tokens). Connection pooling to SMTP/SMS providers. Horizontal scaling of consumers. Pre-render templates at enqueue time to reduce consumer work." },
    { "question": "How do you track notification delivery and engagement?", "answer": "Delivery: track via provider callbacks (FCM delivery receipts, email open tracking pixel, SMS delivery reports). Store: notification_id, status (sent/delivered/opened/clicked), timestamps. Email: invisible 1x1 pixel image. Push: app reports open. Click: redirect through tracking URL. Aggregate for analytics dashboards." },
    { "question": "How do you implement notification templates?", "answer": "Template service: store templates with Mustache/Handlebars syntax. Variables: {{name}}, {{orderId}}. Per-channel variants: push (short), email (HTML), SMS (plain text). Versioning for A/B testing. Localization: template per locale. Render at send time: merge template + data → final content. Preview API for testing." },
    { "question": "How do you handle cross-channel notification deduplication?", "answer": "If order update sent via push and user opens it → don't send email. Strategy: send push first, wait 5 minutes, if not opened → send email. Implement with delayed queue and status check. Track 'acknowledged' flag per notification. Cancel pending lower-priority channel sends when user interacts with higher-priority channel." }
  ],
  "exercises": [
    { "type": "estimation", "question": "10M users, average 20 notifications/day across channels. Estimate throughput.", "answer": "Daily: 10M × 20 = 200M notifications. QPS: 200M / 86400 ≈ 2,315 notifications/sec. Peak (3x): 6,945/sec. Per channel (push 60%, email 30%, sms 10%): push peak ≈ 4,167/sec. Need several Kafka partitions and consumer instances per channel." },
    { "type": "design", "question": "Design the retry mechanism for failed notifications.", "answer": "On failure: requeue with retry_count++. Exponential backoff: delay = min(2^retry × 1s, 5min). Max retries: 3 for push, 2 for SMS (expensive), 3 for email. After max retries → dead-letter queue + alert. Different failure types: transient (retry) vs permanent (invalid token → remove token, don't retry). Log failure reason for debugging." },
    { "type": "scenario", "question": "Black Friday sale: notification to 50M users simultaneously. How?", "answer": "Pre-render all notifications (template + user data). Partition into batches (10K users each = 5,000 batches). Enqueue batches to Kafka. Scale consumers to 100+ instances. Use FCM topic messaging for Android (subscribe all to 'sale' topic → single API call). Stagger: send over 30 minutes, not all at once. Monitor provider rate limits." },
    { "type": "tricky", "question": "Why not send all notifications synchronously from the producing service?", "answer": "1) Tight coupling: producer blocks on send. 2) No retry logic. 3) No preference checking. 4) Channel providers have rate limits — need queuing. 5) One slow channel blocks others. 6) No priority handling. 7) No deduplication. 8) No analytics. Async queue decouples producers from delivery, enabling all these features." },
    { "type": "design", "question": "Design in-app notification center (like Instagram's activity feed).", "answer": "Store: notifications table (id, user_id, type, content, read, created_at). API: GET /notifications?unread=true&limit=20. Mark read: PUT /notifications/:id/read. Badge count: Redis counter per user (increment on new, reset on open). Real-time: WebSocket push for new notifications while app is open. Pagination: cursor-based on created_at." },
    { "type": "estimation", "question": "Email notification: 1M emails/hour via SES. SES limit: 200 emails/sec. How many sender instances needed?", "answer": "Required: 1M/3600 = 278 emails/sec. SES limit per account: 200/sec (can request increase). With 200/sec limit: need burst buffer or request limit increase to 300/sec. Alternative: multiple SES endpoints/regions. With 2 regions at 200/sec each = 400/sec capacity (1.44M/hour) — sufficient with headroom." },
    { "type": "debug", "question": "Push notifications are delivered but users report not receiving them. What could be wrong?", "answer": "1) Stale device tokens (user reinstalled app, token changed). 2) User disabled push at OS level. 3) Battery optimization killing app process. 4) Notification channel importance too low on Android. 5) App in background → OS throttles notifications. 6) Content too long → truncated and looks empty. 7) APNs sandbox vs production environment mismatch." },
    { "type": "design", "question": "Design a notification digest system.", "answer": "Collect: buffer low-priority notifications per user (Redis list). Schedule: cron job every hour checks buffers. If buffer size > threshold OR time elapsed > max_wait → create digest. Template: 'You have 5 new likes and 3 comments'. Send one email/push instead of 8 individual ones. User preference: real-time vs digest per category. Clear buffer on send." },
    { "type": "scenario", "question": "User changes email at 2pm. Notification sent at 1:59pm to old email. How to handle?", "answer": "Eventual consistency: notification sent to email at time of send. Not a bug — this is expected. To minimize: notification service should look up email at send time, not at enqueue time. For critical notifications: lookup fresh data from user service right before channel adapter sends. Cache TTL for user data should be short (5min). For legal/compliance: audit log of which email was used." },
    { "type": "design", "question": "Design A/B testing for notification templates.", "answer": "A/B service assigns user to variant (A or B) by user_id hash % 100. Template service returns variant-specific template. Track metrics per variant: delivery rate, open rate, click rate, conversion rate. Statistical significance: need ~1000 opens per variant. Auto-select winner after confidence threshold reached. Gradual rollout: 10% → 50% → 100%." }
  ],
  "programExercises": [
    {
      "question": "Program 1: Multi-channel notification dispatcher",
      "code": "class NotificationDispatcher {\n  constructor() { this.channels = new Map(); this.log = []; }\n  registerChannel(name, handler) { this.channels.set(name, handler); }\n  dispatch(userId, channel, message) {\n    const handler = this.channels.get(channel);\n    if (!handler) return { error: `Unknown channel: ${channel}` };\n    const result = handler(userId, message);\n    this.log.push({ userId, channel, message, result, time: Date.now() });\n    return result;\n  }\n  getLog(userId) {\n    return this.log.filter(l => l.userId === userId).map(l => `[${l.channel}] ${l.message} → ${l.result}`);\n  }\n}\n\nconst nd = new NotificationDispatcher();\nnd.registerChannel('push', (uid, msg) => `Push sent to ${uid}: ${msg}`);\nnd.registerChannel('email', (uid, msg) => `Email sent to ${uid}: ${msg}`);\nnd.registerChannel('sms', (uid, msg) => `SMS sent to ${uid}: ${msg}`);\n\nconsole.log(nd.dispatch('alice', 'push', 'New message!'));\nconsole.log(nd.dispatch('alice', 'email', 'Weekly digest'));\nconsole.log(nd.dispatch('alice', 'webhook', 'Test'));\nconsole.log(nd.getLog('alice'));",
      "output": "Push sent to alice: New message!\nEmail sent to alice: Weekly digest\n{ error: 'Unknown channel: webhook' }\n[\n  '[push] New message! → Push sent to alice: New message!',\n  '[email] Weekly digest → Email sent to alice: Weekly digest'\n]"
    },
    {
      "question": "Program 2: User preference evaluator",
      "code": "class PreferenceEngine {\n  constructor() { this.prefs = new Map(); }\n  setPreferences(userId, prefs) { this.prefs.set(userId, prefs); }\n  canSend(userId, channel, category) {\n    const p = this.prefs.get(userId);\n    if (!p) return { allowed: true, reason: 'No preferences set (default allow)' };\n    if (p.globalOff) return { allowed: false, reason: 'Global notifications disabled' };\n    if (p.channels?.[channel] === false) return { allowed: false, reason: `${channel} channel disabled` };\n    if (p.categories?.[category] === false) return { allowed: false, reason: `${category} category disabled` };\n    return { allowed: true, reason: 'All checks passed' };\n  }\n}\n\nconst pe = new PreferenceEngine();\npe.setPreferences('alice', {\n  globalOff: false,\n  channels: { push: true, email: true, sms: false },\n  categories: { marketing: false, transactional: true, social: true },\n});\n\nconsole.log(pe.canSend('alice', 'push', 'social'));\nconsole.log(pe.canSend('alice', 'sms', 'transactional'));\nconsole.log(pe.canSend('alice', 'email', 'marketing'));\nconsole.log(pe.canSend('bob', 'push', 'marketing'));",
      "output": "{ allowed: true, reason: 'All checks passed' }\n{ allowed: false, reason: 'sms channel disabled' }\n{ allowed: false, reason: 'marketing category disabled' }\n{ allowed: true, reason: 'No preferences set (default allow)' }"
    },
    {
      "question": "Program 3: Token-bucket rate limiter for notifications",
      "code": "class TokenBucket {\n  constructor(capacity, refillRate) {\n    this.capacity = capacity;\n    this.tokens = capacity;\n    this.refillRate = refillRate; // tokens per second\n    this.lastRefill = Date.now();\n  }\n  refill() {\n    const now = Date.now();\n    const elapsed = (now - this.lastRefill) / 1000;\n    this.tokens = Math.min(this.capacity, this.tokens + elapsed * this.refillRate);\n    this.lastRefill = now;\n  }\n  consume(n = 1) {\n    this.refill();\n    if (this.tokens >= n) {\n      this.tokens -= n;\n      return { allowed: true, remaining: Math.floor(this.tokens) };\n    }\n    return { allowed: false, remaining: Math.floor(this.tokens), retryAfterMs: Math.ceil((n - this.tokens) / this.refillRate * 1000) };\n  }\n}\n\nclass NotifRateLimiter {\n  constructor() { this.buckets = new Map(); }\n  getBucket(userId, channel) {\n    const key = `${userId}:${channel}`;\n    if (!this.buckets.has(key)) this.buckets.set(key, new TokenBucket(10, 1)); // 10 burst, 1/sec refill\n    return this.buckets.get(key);\n  }\n  check(userId, channel) {\n    return this.getBucket(userId, channel).consume();\n  }\n}\n\nconst rl = new NotifRateLimiter();\nfor (let i = 0; i < 12; i++) {\n  console.log(`Attempt ${i + 1}:`, rl.check('alice', 'push'));\n}",
      "output": "Attempt 1: { allowed: true, remaining: 9 }\nAttempt 2: { allowed: true, remaining: 8 }\n...\nAttempt 10: { allowed: true, remaining: 0 }\nAttempt 11: { allowed: false, remaining: 0, retryAfterMs: 1000 }\nAttempt 12: { allowed: false, remaining: 0, retryAfterMs: 1000 }"
    },
    {
      "question": "Program 4: Notification priority queue",
      "code": "class PriorityNotificationQueue {\n  constructor() {\n    this.lanes = { high: [], medium: [], low: [] };\n    this.processed = [];\n  }\n  enqueue(notification) {\n    const priority = notification.priority || 'medium';\n    this.lanes[priority].push({ ...notification, enqueuedAt: Date.now() });\n    return { queued: true, priority, position: this.lanes[priority].length };\n  }\n  process(maxBatch = 5) {\n    const batch = [];\n    for (const priority of ['high', 'medium', 'low']) {\n      while (batch.length < maxBatch && this.lanes[priority].length > 0) {\n        const n = this.lanes[priority].shift();\n        batch.push({ ...n, processedAt: Date.now(), priority });\n      }\n    }\n    this.processed.push(...batch);\n    return batch.map(n => ({ id: n.id, priority: n.priority, to: n.userId }));\n  }\n  stats() {\n    return {\n      queued: { high: this.lanes.high.length, medium: this.lanes.medium.length, low: this.lanes.low.length },\n      processed: this.processed.length,\n    };\n  }\n}\n\nconst pq = new PriorityNotificationQueue();\npq.enqueue({ id: 1, userId: 'alice', priority: 'low', msg: 'Weekly digest' });\npq.enqueue({ id: 2, userId: 'bob', priority: 'high', msg: 'OTP: 123456' });\npq.enqueue({ id: 3, userId: 'carol', priority: 'medium', msg: 'New follower' });\npq.enqueue({ id: 4, userId: 'dave', priority: 'high', msg: 'Password reset' });\nconsole.log('Stats:', pq.stats());\nconsole.log('Batch 1:', pq.process(3));\nconsole.log('Batch 2:', pq.process(3));\nconsole.log('Stats:', pq.stats());",
      "output": "Stats: { queued: { high: 2, medium: 1, low: 1 }, processed: 0 }\nBatch 1: [\n  { id: 2, priority: 'high', to: 'bob' },\n  { id: 4, priority: 'high', to: 'dave' },\n  { id: 3, priority: 'medium', to: 'carol' }\n]\nBatch 2: [ { id: 1, priority: 'low', to: 'alice' } ]\nStats: { queued: { high: 0, medium: 0, low: 0 }, processed: 4 }"
    },
    {
      "question": "Program 5: Template renderer with variable substitution",
      "code": "class TemplateRenderer {\n  constructor() { this.templates = new Map(); }\n  register(name, template) { this.templates.set(name, template); }\n  render(name, vars) {\n    let tmpl = this.templates.get(name);\n    if (!tmpl) return { error: `Template not found: ${name}` };\n    const missing = [];\n    const result = tmpl.replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n      if (vars[key] !== undefined) return vars[key];\n      missing.push(key);\n      return match;\n    });\n    return missing.length ? { error: 'Missing variables', missing } : { content: result };\n  }\n}\n\nconst tr = new TemplateRenderer();\ntr.register('welcome', 'Welcome {{name}}! Your account {{email}} is ready.');\ntr.register('otp', 'Your OTP is {{code}}. Valid for {{minutes}} minutes.');\ntr.register('order', 'Order #{{orderId}} {{status}}. ETA: {{eta}}.');\n\nconsole.log(tr.render('welcome', { name: 'Alice', email: 'alice@mail.com' }));\nconsole.log(tr.render('otp', { code: '482910', minutes: '5' }));\nconsole.log(tr.render('order', { orderId: '123' })); // missing vars\nconsole.log(tr.render('unknown', {}));",
      "output": "{ content: 'Welcome Alice! Your account alice@mail.com is ready.' }\n{ content: 'Your OTP is 482910. Valid for 5 minutes.' }\n{ error: 'Missing variables', missing: [ 'status', 'eta' ] }\n{ error: 'Template not found: unknown' }"
    },
    {
      "question": "Program 6: Notification digest aggregator",
      "code": "class DigestAggregator {\n  constructor(threshold, maxWaitMs) {\n    this.threshold = threshold;\n    this.maxWaitMs = maxWaitMs;\n    this.buffers = new Map();\n  }\n  add(userId, notification) {\n    if (!this.buffers.has(userId)) {\n      this.buffers.set(userId, { items: [], firstAdded: Date.now() });\n    }\n    this.buffers.get(userId).items.push(notification);\n  }\n  shouldFlush(userId) {\n    const buf = this.buffers.get(userId);\n    if (!buf) return false;\n    return buf.items.length >= this.threshold || (Date.now() - buf.firstAdded) >= this.maxWaitMs;\n  }\n  flush(userId) {\n    const buf = this.buffers.get(userId);\n    if (!buf) return null;\n    this.buffers.delete(userId);\n    const types = {};\n    buf.items.forEach(n => { types[n.type] = (types[n.type] || 0) + 1; });\n    return {\n      userId,\n      count: buf.items.length,\n      summary: Object.entries(types).map(([t, c]) => `${c} ${t}`).join(', '),\n      items: buf.items,\n    };\n  }\n}\n\nconst da = new DigestAggregator(3, 60000);\nda.add('alice', { type: 'like', from: 'bob' });\nda.add('alice', { type: 'comment', from: 'carol' });\nconsole.log('Should flush?', da.shouldFlush('alice'));\nda.add('alice', { type: 'like', from: 'dave' });\nconsole.log('Should flush?', da.shouldFlush('alice'));\nconsole.log(da.flush('alice'));",
      "output": "Should flush? false\nShould flush? true\n{\n  userId: 'alice',\n  count: 3,\n  summary: '2 like, 1 comment',\n  items: [\n    { type: 'like', from: 'bob' },\n    { type: 'comment', from: 'carol' },\n    { type: 'like', from: 'dave' }\n  ]\n}"
    },
    {
      "question": "Program 7: Device token manager",
      "code": "class DeviceTokenManager {\n  constructor() { this.tokens = new Map(); }\n  register(userId, deviceId, token, platform) {\n    if (!this.tokens.has(userId)) this.tokens.set(userId, []);\n    const devices = this.tokens.get(userId);\n    const existing = devices.findIndex(d => d.deviceId === deviceId);\n    if (existing >= 0) devices[existing] = { deviceId, token, platform, updatedAt: Date.now() };\n    else devices.push({ deviceId, token, platform, updatedAt: Date.now() });\n  }\n  unregister(userId, deviceId) {\n    const devices = this.tokens.get(userId);\n    if (!devices) return false;\n    const idx = devices.findIndex(d => d.deviceId === deviceId);\n    if (idx >= 0) { devices.splice(idx, 1); return true; }\n    return false;\n  }\n  getTokens(userId) {\n    return (this.tokens.get(userId) || []).map(d => ({ token: d.token, platform: d.platform }));\n  }\n}\n\nconst dtm = new DeviceTokenManager();\ndtm.register('alice', 'iphone-1', 'apns_abc123', 'ios');\ndtm.register('alice', 'pixel-1', 'fcm_xyz789', 'android');\ndtm.register('alice', 'iphone-1', 'apns_newtoken', 'ios'); // token refresh\nconsole.log(dtm.getTokens('alice'));\ndtm.unregister('alice', 'pixel-1');\nconsole.log(dtm.getTokens('alice'));",
      "output": "[\n  { token: 'apns_newtoken', platform: 'ios' },\n  { token: 'fcm_xyz789', platform: 'android' }\n]\n[ { token: 'apns_newtoken', platform: 'ios' } ]"
    },
    {
      "question": "Program 8: Retry with exponential backoff",
      "code": "class RetryHandler {\n  constructor(maxRetries, baseDelayMs) {\n    this.maxRetries = maxRetries;\n    this.baseDelay = baseDelayMs;\n  }\n  async execute(fn, label) {\n    let attempt = 0;\n    while (attempt <= this.maxRetries) {\n      try {\n        const result = fn(attempt);\n        return { success: true, result, attempts: attempt + 1 };\n      } catch (e) {\n        attempt++;\n        if (attempt > this.maxRetries) {\n          return { success: false, error: e.message, attempts: attempt, status: 'DEAD_LETTER' };\n        }\n        const delay = this.baseDelay * Math.pow(2, attempt - 1);\n        console.log(`  [${label}] Attempt ${attempt} failed: ${e.message}. Retry in ${delay}ms`);\n      }\n    }\n  }\n}\n\nconst rh = new RetryHandler(3, 100);\n\n// Simulate: fails first 2 times, succeeds on 3rd\nlet callCount = 0;\nconsole.log(rh.execute((attempt) => {\n  callCount++;\n  if (callCount < 3) throw new Error('Provider timeout');\n  return 'Notification delivered!';\n}, 'push-notif'));\n\n// Simulate: always fails\nconsole.log(rh.execute(() => { throw new Error('Invalid token'); }, 'bad-token'));",
      "output": "  [push-notif] Attempt 1 failed: Provider timeout. Retry in 100ms\n  [push-notif] Attempt 2 failed: Provider timeout. Retry in 200ms\n{ success: true, result: 'Notification delivered!', attempts: 3 }\n  [bad-token] Attempt 1 failed: Invalid token. Retry in 100ms\n  [bad-token] Attempt 2 failed: Invalid token. Retry in 200ms\n  [bad-token] Attempt 3 failed: Invalid token. Retry in 400ms\n{ success: false, error: 'Invalid token', attempts: 4, status: 'DEAD_LETTER' }"
    },
    {
      "question": "Program 9: Notification analytics tracker",
      "code": "class NotifAnalytics {\n  constructor() { this.events = []; }\n  track(notifId, event) {\n    this.events.push({ notifId, event, time: Date.now() });\n  }\n  getMetrics() {\n    const counts = {};\n    this.events.forEach(e => { counts[e.event] = (counts[e.event] || 0) + 1; });\n    const sent = counts.sent || 0;\n    return {\n      total: this.events.length,\n      sent,\n      delivered: counts.delivered || 0,\n      opened: counts.opened || 0,\n      clicked: counts.clicked || 0,\n      deliveryRate: sent ? ((counts.delivered || 0) / sent * 100).toFixed(1) + '%' : 'N/A',\n      openRate: sent ? ((counts.opened || 0) / sent * 100).toFixed(1) + '%' : 'N/A',\n      clickRate: (counts.opened || 0) ? ((counts.clicked || 0) / counts.opened * 100).toFixed(1) + '%' : 'N/A',\n    };\n  }\n}\n\nconst na = new NotifAnalytics();\n// Simulate funnel\nfor (let i = 0; i < 100; i++) na.track(`n${i}`, 'sent');\nfor (let i = 0; i < 92; i++) na.track(`n${i}`, 'delivered');\nfor (let i = 0; i < 45; i++) na.track(`n${i}`, 'opened');\nfor (let i = 0; i < 12; i++) na.track(`n${i}`, 'clicked');\nconsole.log(na.getMetrics());",
      "output": "{\n  total: 249,\n  sent: 100,\n  delivered: 92,\n  opened: 45,\n  clicked: 12,\n  deliveryRate: '92.0%',\n  openRate: '45.0%',\n  clickRate: '26.7%'\n}"
    },
    {
      "question": "Program 10: Cross-channel deduplication",
      "code": "class CrossChannelDedup {\n  constructor(dedupeWindowMs) {\n    this.windowMs = dedupeWindowMs;\n    this.sent = new Map(); // notifKey -> { channel, time }\n  }\n  shouldSend(userId, notifKey, channel, priority) {\n    const key = `${userId}:${notifKey}`;\n    const existing = this.sent.get(key);\n    if (!existing) {\n      this.sent.set(key, { channel, time: Date.now() });\n      return { send: true, reason: 'First channel for this notification' };\n    }\n    if (Date.now() - existing.time > this.windowMs) {\n      this.sent.set(key, { channel, time: Date.now() });\n      return { send: true, reason: 'Dedupe window expired' };\n    }\n    if (priority === 'high') {\n      return { send: true, reason: 'High priority overrides dedup' };\n    }\n    return { send: false, reason: `Already sent via ${existing.channel}` };\n  }\n}\n\nconst ccd = new CrossChannelDedup(300000); // 5 min window\nconsole.log(ccd.shouldSend('alice', 'order_123', 'push', 'medium'));\nconsole.log(ccd.shouldSend('alice', 'order_123', 'email', 'medium'));\nconsole.log(ccd.shouldSend('alice', 'order_123', 'sms', 'high'));\nconsole.log(ccd.shouldSend('bob', 'order_123', 'push', 'medium'));",
      "output": "{ send: true, reason: 'First channel for this notification' }\n{ send: false, reason: 'Already sent via push' }\n{ send: true, reason: 'High priority overrides dedup' }\n{ send: true, reason: 'First channel for this notification' }"
    }
  ]
}