{
  "id": "payment-system",
  "title": "Payment System Design",
  "category": "Company HLD",
  "description": "Design a payment processing system handling transactions, payment gateways, idempotency, reconciliation, fraud detection, and multi-currency support at scale.",
  "explanation": "A payment system handles the flow of money between buyers, sellers, and financial institutions. It must be correct (never lose money), available (process payments 24/7), and secure (PCI-DSS compliant).\n\n**Core Components**:\n1. **Payment Service (API)**: Entry point for payment requests. Validates, persists, orchestrates.\n2. **Payment Gateway**: Connects to external payment processors (Stripe, Razorpay, PayPal).\n3. **Ledger Service**: Double-entry bookkeeping — every debit has a matching credit.\n4. **Wallet Service**: Manages user balance, refunds, credits.\n5. **Reconciliation Service**: Matches internal records with bank/gateway settlements.\n6. **Fraud Detection**: ML-based risk scoring on every transaction.\n7. **Notification Service**: Payment confirmations, receipts, failure alerts.\n\n**Payment Flow (e-commerce)**:\n1. User clicks 'Pay' → POST /payments { orderId, amount, method, idempotencyKey }.\n2. Payment Service creates payment record (status: INITIATED). Stores idempotency key.\n3. Sends to Payment Gateway → gateway calls card network / UPI / bank.\n4. Gateway responds: SUCCESS / FAILURE / PENDING.\n5. If SUCCESS → update status to COMPLETED → debit buyer, credit seller in Ledger.\n6. If FAILURE → update status to FAILED → notify user.\n7. If PENDING → poll or wait for webhook callback.\n8. Return response to user.\n\n**Idempotency**:\n- Critical: if client retries (network timeout), payment must not be charged twice.\n- Client sends idempotency_key (UUID) with every request.\n- Server: check if idempotency_key exists in DB. If yes → return cached response.\n- If no → process payment → store result with idempotency_key.\n- Key retention: 24-72 hours.\n\n**Double-Entry Ledger**:\n- Every transaction creates 2 entries: DEBIT from one account + CREDIT to another.\n- Sum of all debits = Sum of all credits (always balanced).\n- Accounts: buyer_wallet, seller_wallet, platform_fees, taxes, gateway_fees.\n- Example: buyer pays ₹100 → debit buyer_wallet ₹100, credit seller_wallet ₹85, credit platform_fees ₹10, credit gateway_fees ₹5.\n\n**Reconciliation**:\n- Daily: compare internal ledger with gateway settlement reports.\n- Match: payment_id, amount, timestamp, status.\n- Discrepancies: missing transactions, amount mismatches, duplicate charges.\n- Auto-resolve where possible. Flag for manual review otherwise.",
  "code": "// Payment processing system simulation\nclass PaymentSystem {\n  constructor() {\n    this.payments = new Map();\n    this.idempotencyStore = new Map();\n    this.ledger = [];\n    this.wallets = new Map();\n    this.paymentCounter = 0;\n  }\n\n  createWallet(userId, balance = 0) {\n    this.wallets.set(userId, { userId, balance, createdAt: Date.now() });\n  }\n\n  getBalance(userId) {\n    return this.wallets.get(userId)?.balance ?? 0;\n  }\n\n  processPayment(request) {\n    const { buyerId, sellerId, amount, idempotencyKey } = request;\n    \n    // Idempotency check\n    if (this.idempotencyStore.has(idempotencyKey)) {\n      return { ...this.idempotencyStore.get(idempotencyKey), cached: true };\n    }\n\n    const paymentId = `pay_${++this.paymentCounter}`;\n    const buyer = this.wallets.get(buyerId);\n    const seller = this.wallets.get(sellerId);\n\n    if (!buyer || !seller) return { status: 'FAILED', error: 'Wallet not found' };\n    if (buyer.balance < amount) return { status: 'FAILED', error: 'Insufficient balance' };\n\n    // Platform fee (10%)\n    const platformFee = amount * 0.10;\n    const sellerAmount = amount - platformFee;\n\n    // Execute\n    buyer.balance -= amount;\n    seller.balance += sellerAmount;\n\n    // Double-entry ledger\n    this.ledger.push(\n      { paymentId, account: buyerId, type: 'DEBIT', amount, description: `Payment to ${sellerId}` },\n      { paymentId, account: sellerId, type: 'CREDIT', amount: sellerAmount, description: `Payment from ${buyerId}` },\n      { paymentId, account: 'PLATFORM', type: 'CREDIT', amount: platformFee, description: 'Platform fee' }\n    );\n\n    const result = {\n      paymentId,\n      status: 'COMPLETED',\n      amount,\n      platformFee: parseFloat(platformFee.toFixed(2)),\n      sellerReceives: parseFloat(sellerAmount.toFixed(2)),\n      buyerBalance: buyer.balance,\n    };\n\n    this.payments.set(paymentId, result);\n    this.idempotencyStore.set(idempotencyKey, result);\n    return result;\n  }\n\n  refund(paymentId) {\n    const payment = this.payments.get(paymentId);\n    if (!payment || payment.status !== 'COMPLETED') return { error: 'Cannot refund' };\n    payment.status = 'REFUNDED';\n    return { paymentId, status: 'REFUNDED', amount: payment.amount };\n  }\n\n  getLedger(account) {\n    return this.ledger.filter(e => e.account === account);\n  }\n}\n\nconst ps = new PaymentSystem();\nps.createWallet('buyer1', 1000);\nps.createWallet('seller1', 0);\n\nconsole.log(ps.processPayment({ buyerId: 'buyer1', sellerId: 'seller1', amount: 200, idempotencyKey: 'idem_1' }));\nconsole.log('Retry (idempotent):', ps.processPayment({ buyerId: 'buyer1', sellerId: 'seller1', amount: 200, idempotencyKey: 'idem_1' }));\nconsole.log('Buyer balance:', ps.getBalance('buyer1'));\nconsole.log('Seller balance:', ps.getBalance('seller1'));\nconsole.log('Ledger:', ps.getLedger('seller1'));",
  "example": "// Multi-currency payment with exchange rates\nclass MultiCurrencyPayment {\n  constructor() {\n    this.rates = {}; // from -> to -> rate\n  }\n  setRate(from, to, rate) {\n    if (!this.rates[from]) this.rates[from] = {};\n    this.rates[from][to] = rate;\n    // Inverse\n    if (!this.rates[to]) this.rates[to] = {};\n    this.rates[to][from] = 1 / rate;\n  }\n  convert(amount, from, to) {\n    if (from === to) return { amount, currency: to, rate: 1 };\n    const rate = this.rates[from]?.[to];\n    if (!rate) return { error: `No rate for ${from} to ${to}` };\n    return { amount: parseFloat((amount * rate).toFixed(2)), currency: to, rate };\n  }\n  processInternational(amount, fromCurrency, toCurrency, feePercent = 2.5) {\n    const converted = this.convert(amount, fromCurrency, toCurrency);\n    if (converted.error) return converted;\n    const fee = parseFloat((converted.amount * feePercent / 100).toFixed(2));\n    return {\n      original: { amount, currency: fromCurrency },\n      converted: { amount: converted.amount, currency: toCurrency },\n      rate: converted.rate,\n      fee,\n      total: parseFloat((converted.amount + fee).toFixed(2)),\n    };\n  }\n}\n\nconst mc = new MultiCurrencyPayment();\nmc.setRate('USD', 'INR', 83.5);\nmc.setRate('USD', 'EUR', 0.92);\nmc.setRate('INR', 'EUR', 0.011);\n\nconsole.log(mc.processInternational(100, 'USD', 'INR'));\nconsole.log(mc.processInternational(5000, 'INR', 'USD'));",
  "useCase": "E-commerce payments, subscription billing, peer-to-peer transfers, marketplace payouts, international remittance, in-app purchases, invoice payments.",
  "interviewQuestions": [
    { "question": "How do you ensure exactly-once payment processing?", "answer": "Idempotency key: client generates unique key per payment attempt. Server: check if key exists → if yes, return cached result. If no, process and store. Database: UNIQUE constraint on idempotency_key. At gateway level: use gateway's own idempotency mechanism. Combined: client idempotency key + server-side deduplication + gateway idempotency = exactly-once semantics." },
    { "question": "How does a double-entry ledger work?", "answer": "Every transaction creates balanced entries: total debits = total credits. Example: ₹100 payment. Debit: buyer's account ₹100. Credit: seller ₹85, platform ₹10, gateway ₹5. Total debit = 100, total credit = 100. Benefit: self-validating (sum check), complete audit trail, supports reconciliation. Schema: (entry_id, transaction_id, account_id, type: DEBIT|CREDIT, amount, timestamp)." },
    { "question": "How do you handle payment failures and retries?", "answer": "On failure: distinguish transient (timeout, 5xx) vs permanent (insufficient funds, invalid card). Transient: auto-retry with exponential backoff (max 3 retries). Permanent: mark FAILED, notify user. Timeout: payment might have succeeded at gateway — query gateway for status before retrying. Never blindly retry without checking current status. State machine: INITIATED → PROCESSING → COMPLETED/FAILED." },
    { "question": "How does reconciliation work?", "answer": "Daily batch: (1) Fetch settlement report from payment gateway. (2) Compare each settlement entry with internal ledger. (3) Match by gateway_transaction_id. (4) Classify: Matched, Missing internally, Missing at gateway, Amount mismatch. (5) Auto-resolve: missing settlements usually arrive next day. (6) Flag discrepancies for manual review. KPI: reconciliation rate should be >99.9%." },
    { "question": "How do you design fraud detection?", "answer": "Layers: (1) Rule-based: block known fraud patterns (velocity checks, geo-impossibility, large amounts from new accounts). (2) ML model: features = amount, time, device, location, merchant category, user history. Output: risk score 0-1. If >0.8: block. If 0.5-0.8: 2FA challenge. If <0.5: allow. (3) Real-time: score computed in <100ms during payment flow. (4) Batch: offline model retraining on labeled fraud data." },
    { "question": "How do you handle refunds?", "answer": "Full refund: reverse entire payment. Partial refund: reverse part of payment. Process: (1) Validate: original payment exists and is refundable. (2) Call gateway refund API with original transaction_id. (3) Ledger: debit seller, credit buyer. (4) Update payment status to REFUNDED. (5) Notify user. Timing: refunds can take 5-10 business days (bank processing). Store refund_id linked to original payment_id." },
    { "question": "How do you handle distributed transactions across services?", "answer": "Saga pattern: sequence of local transactions with compensating actions. Example: Order → Payment → Inventory. If Payment succeeds but Inventory fails → compensate by refunding payment. Implementation: orchestrator sends commands to each service in sequence. On failure: send compensating commands in reverse. Alternative: outbox pattern — write to DB + outbox table atomically, relay outbox events." },
    { "question": "How do you ensure PCI-DSS compliance?", "answer": "Never store raw card numbers in your database. Use tokenization: card number → token (via gateway). Store only token + last 4 digits + expiry. All card data in transit: HTTPS/TLS. Minimize scope: use hosted payment forms (Stripe.js, Razorpay checkout) — card data goes directly to gateway, never touches your server. Regular security audits. Access logging. Encryption at rest." },
    { "question": "How do you handle multi-currency payments?", "answer": "Store amounts in smallest unit (cents/paise) to avoid floating point issues. Exchange rates: real-time API (or cached for 5 min). Conversion at time of payment: lock rate for 15 min. Display: show amount in buyer's currency + converted amount. Settlement: settle in seller's currency. Ledger: record both currencies. FX fee: 1.5-3% on conversion." },
    { "question": "How do you design a subscription billing system?", "answer": "Components: Plan (price, interval, trial), Subscription (user, plan, status, next_billing_date), Invoice (generated per billing cycle). Flow: cron job runs daily → find subscriptions where next_billing_date = today → create invoice → attempt payment. If success: extend subscription. If failure: retry 3 times over 7 days (dunning). If all fail: cancel subscription. Proration: when user upgrades mid-cycle." }
  ],
  "exercises": [
    { "type": "estimation", "question": "Payment platform: 10M transactions/day. Average transaction: 3KB event. Estimate storage and throughput.", "answer": "Daily: 10M × 3KB = 30GB/day. Monthly: 900GB. Yearly: 10.8TB (need archival after 90 days). QPS: 10M / 86400 ≈ 116 TPS. Peak (3x): 348 TPS. Ledger entries: 2-4x transactions (double-entry) = 20-40M entries/day. Not enormous — single PostgreSQL handles this. Add read replicas for queries." },
    { "type": "design", "question": "Design the payment state machine.", "answer": "States: CREATED → PROCESSING → AUTHORIZED → CAPTURED → COMPLETED → (REFUND_INITIATED → REFUNDED). Failure states: FAILED (terminal), TIMED_OUT (retriable). Transitions: CREATED → PROCESSING (sent to gateway). PROCESSING → AUTHORIZED (gateway confirms hold). AUTHORIZED → CAPTURED (actual charge). For 2-step: authorize now, capture later (e.g., hold on booking, charge on checkout). Each transition logged with timestamp." },
    { "type": "scenario", "question": "Payment gateway timeout after 30 seconds. Money may or may not have been charged. What do you do?", "answer": "1) Do NOT retry blindly (may double-charge). 2) Query gateway: GET /payments/{gateway_txn_id}/status. 3) If gateway says SUCCESS → mark COMPLETED. 4) If gateway says NOT_FOUND → safe to retry (money not charged). 5) If gateway is also timing out → mark PENDING in our DB. 6) Background job: poll gateway every 5 min for PENDING payments. 7) After 24 hours: if still unknown → escalate for manual reconciliation." },
    { "type": "tricky", "question": "Why use Event Sourcing for payments instead of simple CRUD?", "answer": "Payments are financial records — you should NEVER update or delete. Event sourcing: store every state change as an immutable event. (PaymentCreated, PaymentProcessing, PaymentCompleted, RefundInitiated). Benefits: (1) Complete audit trail. (2) Can replay events to rebuild state. (3) Debugging: see exactly what happened. (4) Compliance: regulators want full history. (5) Reconciliation: compare event stream with gateway. CRUD loses intermediate states." },
    { "type": "design", "question": "Design the settlement system for a marketplace.", "answer": "After buyer pays: money goes to escrow (platform holds). Settlement triggers: (1) Delivery confirmed (e-commerce). (2) Service completed (ride-hailing). (3) Time-based (7 days after order). Settlement: deduct platform commission → transfer to seller. Batch: nightly settlement run. For each seller: sum completed orders → create payout. Payout via bank transfer (NEFT/IMPS). Track payout status: PENDING → PROCESSING → SETTLED." },
    { "type": "estimation", "question": "Razorpay processes 40K TPS peak. Each transaction needs 5ms of DB time. How many DB connections needed?", "answer": "Required: 40K TPS × 5ms = 200 seconds of DB time per second. So need 200 concurrent DB connections (if serialized). With connection pooling (PgBouncer): 200 pool connections can serve 40K TPS at 5ms each. DB servers: 2-3 PostgreSQL instances with connection pooling. Read replicas for queries. Write primary for transactions." },
    { "type": "debug", "question": "Users report being charged twice for same order. How to investigate and fix?", "answer": "Investigate: (1) Check idempotency_key — did client send same key? If different keys → client bug (retried with new key). (2) Check gateway: does gateway show 2 charges? If yes → we sent 2 requests. (3) Check timing: race condition — 2 requests processed before idempotency check. Fix: (1) Use DB unique constraint on idempotency_key (atomic). (2) Distributed lock before processing. (3) For the duplicate charge: auto-refund via reconciliation." },
    { "type": "design", "question": "Design a wallet system with top-up and spend.", "answer": "Tables: wallet(user_id PK, balance, currency). wallet_transactions(id, wallet_id, type: CREDIT|DEBIT, amount, ref_id, created_at). Top-up: verify bank transfer → credit wallet. Spend: check balance → debit wallet. Atomicity: use DB transaction with SELECT FOR UPDATE (pessimistic lock) or optimistic lock (version column). Balance check + debit must be atomic to prevent overdraft." },
    { "type": "scenario", "question": "Black Friday: payment volume spikes 10x. How does the system handle it?", "answer": "1) Pre-scale: add more payment service instances based on predicted load. 2) Queue: async processing via Kafka — smooth out spikes. 3) Circuit breaker: if gateway is overwhelmed, fail fast instead of timeout. 4) Fallback gateway: route to secondary gateway if primary is slow. 5) Rate limit: cap at maximum safe TPS per gateway. 6) Priority: process high-value orders first. 7) Cache: cache exchange rates, merchant configs." },
    { "type": "output", "question": "Buyer pays ₹1000. Platform fee: 10%. Gateway fee: 2%. Tax on platform fee: 18% GST. What does seller receive?", "answer": "Total: ₹1000. Gateway fee: ₹1000 × 2% = ₹20. Net after gateway: ₹980. Platform fee: ₹980 × 10% = ₹98. GST on platform fee: ₹98 × 18% = ₹17.64. Seller receives: ₹980 - ₹98 = ₹882. Ledger: Debit buyer ₹1000. Credit gateway_account ₹20. Credit platform_revenue ₹98. Credit tax_account ₹17.64 (from platform revenue). Credit seller ₹882. Total credits = 1000 ✓" }
  ],
  "programExercises": [
    {
      "question": "Program 1: Idempotent payment processor",
      "code": "class IdempotentPayments {\n  constructor() { this.store = new Map(); this.payments = []; }\n  process(idempotencyKey, amount, from, to) {\n    if (this.store.has(idempotencyKey)) {\n      return { ...this.store.get(idempotencyKey), idempotent: true };\n    }\n    const payment = {\n      id: `pay_${this.payments.length + 1}`,\n      amount, from, to,\n      status: 'COMPLETED',\n      processedAt: Date.now(),\n    };\n    this.payments.push(payment);\n    this.store.set(idempotencyKey, payment);\n    return { ...payment, idempotent: false };\n  }\n}\n\nconst ip = new IdempotentPayments();\nconsole.log(ip.process('key_1', 100, 'alice', 'bob'));\nconsole.log(ip.process('key_1', 100, 'alice', 'bob')); // duplicate\nconsole.log(ip.process('key_2', 200, 'alice', 'carol'));\nconsole.log('Total payments:', ip.payments.length);",
      "output": "{ id: 'pay_1', amount: 100, from: 'alice', to: 'bob', status: 'COMPLETED', ..., idempotent: false }\n{ id: 'pay_1', amount: 100, from: 'alice', to: 'bob', status: 'COMPLETED', ..., idempotent: true }\n{ id: 'pay_2', amount: 200, from: 'alice', to: 'carol', status: 'COMPLETED', ..., idempotent: false }\nTotal payments: 2"
    },
    {
      "question": "Program 2: Double-entry ledger",
      "code": "class Ledger {\n  constructor() { this.entries = []; }\n  record(txnId, debits, credits) {\n    const totalDebit = debits.reduce((s, d) => s + d.amount, 0);\n    const totalCredit = credits.reduce((s, c) => s + c.amount, 0);\n    if (Math.abs(totalDebit - totalCredit) > 0.001) {\n      return { error: 'Unbalanced!', debit: totalDebit, credit: totalCredit };\n    }\n    debits.forEach(d => this.entries.push({ txnId, account: d.account, type: 'DEBIT', amount: d.amount }));\n    credits.forEach(c => this.entries.push({ txnId, account: c.account, type: 'CREDIT', amount: c.amount }));\n    return { txnId, entries: debits.length + credits.length, balanced: true };\n  }\n  balance(account) {\n    let credits = 0, debits = 0;\n    this.entries.filter(e => e.account === account).forEach(e => {\n      if (e.type === 'CREDIT') credits += e.amount;\n      else debits += e.amount;\n    });\n    return { account, credits, debits, net: credits - debits };\n  }\n  verify() {\n    let totalDebits = 0, totalCredits = 0;\n    this.entries.forEach(e => {\n      if (e.type === 'DEBIT') totalDebits += e.amount;\n      else totalCredits += e.amount;\n    });\n    return { totalDebits, totalCredits, balanced: Math.abs(totalDebits - totalCredits) < 0.001 };\n  }\n}\n\nconst l = new Ledger();\nconsole.log(l.record('txn1',\n  [{ account: 'buyer', amount: 100 }],\n  [{ account: 'seller', amount: 85 }, { account: 'platform', amount: 15 }]\n));\nconsole.log(l.balance('buyer'));\nconsole.log(l.balance('seller'));\nconsole.log(l.verify());",
      "output": "{ txnId: 'txn1', entries: 3, balanced: true }\n{ account: 'buyer', credits: 0, debits: 100, net: -100 }\n{ account: 'seller', credits: 85, debits: 0, net: 85 }\n{ totalDebits: 100, totalCredits: 100, balanced: true }"
    },
    {
      "question": "Program 3: Payment state machine",
      "code": "class PaymentStateMachine {\n  constructor() {\n    this.states = {\n      CREATED: ['PROCESSING'],\n      PROCESSING: ['AUTHORIZED', 'FAILED'],\n      AUTHORIZED: ['CAPTURED', 'VOIDED'],\n      CAPTURED: ['COMPLETED'],\n      COMPLETED: ['REFUND_INITIATED'],\n      REFUND_INITIATED: ['REFUNDED'],\n      FAILED: [],\n      VOIDED: [],\n      REFUNDED: [],\n    };\n    this.payments = new Map();\n  }\n  create(id) {\n    this.payments.set(id, { id, state: 'CREATED', history: ['CREATED'] });\n    return { id, state: 'CREATED' };\n  }\n  transition(id, to) {\n    const p = this.payments.get(id);\n    if (!p) return { error: 'Not found' };\n    if (!this.states[p.state]?.includes(to)) {\n      return { error: `Invalid: ${p.state} → ${to}` };\n    }\n    p.state = to;\n    p.history.push(to);\n    return { id, state: to, steps: p.history.length };\n  }\n  getHistory(id) {\n    return this.payments.get(id)?.history || [];\n  }\n}\n\nconst psm = new PaymentStateMachine();\npsm.create('P1');\nconsole.log(psm.transition('P1', 'PROCESSING'));\nconsole.log(psm.transition('P1', 'AUTHORIZED'));\nconsole.log(psm.transition('P1', 'COMPLETED')); // invalid!\nconsole.log(psm.transition('P1', 'CAPTURED'));\nconsole.log(psm.transition('P1', 'COMPLETED'));\nconsole.log('History:', psm.getHistory('P1'));",
      "output": "{ id: 'P1', state: 'PROCESSING', steps: 2 }\n{ id: 'P1', state: 'AUTHORIZED', steps: 3 }\n{ error: 'Invalid: AUTHORIZED → COMPLETED' }\n{ id: 'P1', state: 'CAPTURED', steps: 4 }\n{ id: 'P1', state: 'COMPLETED', steps: 5 }\nHistory: [ 'CREATED', 'PROCESSING', 'AUTHORIZED', 'CAPTURED', 'COMPLETED' ]"
    },
    {
      "question": "Program 4: Wallet with atomic operations",
      "code": "class Wallet {\n  constructor() { this.accounts = new Map(); this.txLog = []; }\n  create(userId, balance = 0) {\n    this.accounts.set(userId, { userId, balance, version: 0 });\n  }\n  topUp(userId, amount) {\n    const acc = this.accounts.get(userId);\n    if (!acc) return { error: 'Account not found' };\n    acc.balance += amount;\n    acc.version++;\n    this.txLog.push({ type: 'TOP_UP', userId, amount, balance: acc.balance });\n    return { userId, newBalance: acc.balance };\n  }\n  transfer(from, to, amount) {\n    const sender = this.accounts.get(from);\n    const receiver = this.accounts.get(to);\n    if (!sender || !receiver) return { error: 'Account not found' };\n    if (sender.balance < amount) return { error: 'Insufficient balance' };\n    // Atomic: debit + credit\n    sender.balance -= amount;\n    receiver.balance += amount;\n    sender.version++;\n    receiver.version++;\n    this.txLog.push({ type: 'TRANSFER', from, to, amount });\n    return { from: { id: from, balance: sender.balance }, to: { id: to, balance: receiver.balance } };\n  }\n  getBalance(userId) {\n    return this.accounts.get(userId)?.balance ?? null;\n  }\n}\n\nconst w = new Wallet();\nw.create('alice', 500);\nw.create('bob', 200);\nconsole.log(w.topUp('alice', 100));\nconsole.log(w.transfer('alice', 'bob', 300));\nconsole.log(w.transfer('alice', 'bob', 400)); // insufficient\nconsole.log('Alice:', w.getBalance('alice'), 'Bob:', w.getBalance('bob'));",
      "output": "{ userId: 'alice', newBalance: 600 }\n{ from: { id: 'alice', balance: 300 }, to: { id: 'bob', balance: 500 } }\n{ error: 'Insufficient balance' }\nAlice: 300 Bob: 500"
    },
    {
      "question": "Program 5: Reconciliation engine",
      "code": "class ReconciliationEngine {\n  reconcile(internal, gateway) {\n    const internalMap = new Map(internal.map(t => [t.id, t]));\n    const gatewayMap = new Map(gateway.map(t => [t.id, t]));\n    const matched = [], missingInGateway = [], missingInInternal = [], mismatched = [];\n\n    for (const [id, t] of internalMap) {\n      const g = gatewayMap.get(id);\n      if (!g) { missingInGateway.push(t); continue; }\n      if (t.amount !== g.amount || t.status !== g.status) {\n        mismatched.push({ id, internal: t, gateway: g });\n      } else {\n        matched.push(id);\n      }\n    }\n    for (const [id] of gatewayMap) {\n      if (!internalMap.has(id)) missingInInternal.push(gatewayMap.get(id));\n    }\n\n    return {\n      matched: matched.length,\n      missingInGateway: missingInGateway.length,\n      missingInInternal: missingInInternal.length,\n      mismatched: mismatched.length,\n      rate: (matched.length / internal.length * 100).toFixed(1) + '%',\n      issues: [...missingInGateway.map(t => `Missing at gateway: ${t.id}`),\n               ...missingInInternal.map(t => `Missing internally: ${t.id}`),\n               ...mismatched.map(m => `Mismatch: ${m.id} (internal: ${m.internal.amount}, gateway: ${m.gateway.amount})`),\n      ],\n    };\n  }\n}\n\nconst re = new ReconciliationEngine();\nconsole.log(re.reconcile(\n  [\n    { id: 'T1', amount: 100, status: 'COMPLETED' },\n    { id: 'T2', amount: 200, status: 'COMPLETED' },\n    { id: 'T3', amount: 300, status: 'COMPLETED' },\n    { id: 'T4', amount: 150, status: 'COMPLETED' },\n  ],\n  [\n    { id: 'T1', amount: 100, status: 'COMPLETED' },\n    { id: 'T2', amount: 210, status: 'COMPLETED' }, // mismatch\n    { id: 'T5', amount: 500, status: 'COMPLETED' }, // extra\n  ]\n));",
      "output": "{\n  matched: 1,\n  missingInGateway: 2,\n  missingInInternal: 1,\n  mismatched: 1,\n  rate: '25.0%',\n  issues: [\n    'Missing at gateway: T3',\n    'Missing at gateway: T4',\n    'Missing internally: T5',\n    'Mismatch: T2 (internal: 200, gateway: 210)'\n  ]\n}"
    },
    {
      "question": "Program 6: Fraud rule engine",
      "code": "class FraudRuleEngine {\n  constructor() { this.rules = []; this.history = new Map(); }\n  addRule(name, check) { this.rules.push({ name, check }); }\n  recordTransaction(userId, amount) {\n    if (!this.history.has(userId)) this.history.set(userId, []);\n    this.history.get(userId).push({ amount, time: Date.now() });\n  }\n  evaluate(transaction) {\n    const violations = [];\n    for (const rule of this.rules) {\n      const result = rule.check(transaction, this.history);\n      if (result) violations.push({ rule: rule.name, detail: result });\n    }\n    const riskScore = Math.min(violations.length / this.rules.length, 1.0);\n    return {\n      transaction: transaction.id,\n      violations,\n      riskScore: parseFloat(riskScore.toFixed(2)),\n      action: riskScore > 0.6 ? 'BLOCK' : riskScore > 0.3 ? 'REVIEW' : 'ALLOW',\n    };\n  }\n}\n\nconst fre = new FraudRuleEngine();\nfre.addRule('high_amount', (t) => t.amount > 50000 ? `Amount ${t.amount} exceeds 50000` : null);\nfre.addRule('velocity', (t, h) => {\n  const recent = (h.get(t.userId) || []).filter(x => Date.now() - x.time < 3600000);\n  return recent.length >= 5 ? `${recent.length} transactions in 1 hour` : null;\n});\nfre.addRule('new_account', (t) => t.accountAge < 24 ? `Account age: ${t.accountAge}h` : null);\n\n// Record some history\nfor (let i = 0; i < 6; i++) fre.recordTransaction('user1', 100);\n\nconsole.log(fre.evaluate({ id: 'T1', userId: 'user1', amount: 100, accountAge: 48 }));\nconsole.log(fre.evaluate({ id: 'T2', userId: 'user2', amount: 75000, accountAge: 2 }));",
      "output": "{\n  transaction: 'T1',\n  violations: [ { rule: 'velocity', detail: '6 transactions in 1 hour' } ],\n  riskScore: 0.33,\n  action: 'REVIEW'\n}\n{\n  transaction: 'T2',\n  violations: [\n    { rule: 'high_amount', detail: 'Amount 75000 exceeds 50000' },\n    { rule: 'new_account', detail: 'Account age: 2h' }\n  ],\n  riskScore: 0.67,\n  action: 'BLOCK'\n}"
    },
    {
      "question": "Program 7: Subscription billing engine",
      "code": "class SubscriptionBilling {\n  constructor() { this.subs = new Map(); this.invoices = []; }\n  subscribe(userId, plan, startDate) {\n    this.subs.set(userId, {\n      userId, plan, status: 'ACTIVE',\n      startDate, nextBilling: new Date(startDate.getTime() + 30 * 86400000),\n      failedAttempts: 0,\n    });\n  }\n  runBilling(today) {\n    const results = [];\n    for (const [userId, sub] of this.subs) {\n      if (sub.status !== 'ACTIVE' || sub.nextBilling > today) continue;\n      const success = Math.random() > 0.2; // 80% success rate\n      if (success) {\n        sub.nextBilling = new Date(today.getTime() + 30 * 86400000);\n        sub.failedAttempts = 0;\n        this.invoices.push({ userId, amount: sub.plan.price, status: 'PAID', date: today });\n        results.push({ userId, status: 'PAID', nextBilling: sub.nextBilling.toISOString().split('T')[0] });\n      } else {\n        sub.failedAttempts++;\n        if (sub.failedAttempts >= 3) {\n          sub.status = 'CANCELLED';\n          results.push({ userId, status: 'CANCELLED', reason: 'Max retries exceeded' });\n        } else {\n          results.push({ userId, status: 'RETRY', attempt: sub.failedAttempts });\n        }\n      }\n    }\n    return results;\n  }\n}\n\nconst sb = new SubscriptionBilling();\nconst start = new Date('2024-01-01');\nsb.subscribe('alice', { name: 'Pro', price: 499 }, start);\nsb.subscribe('bob', { name: 'Basic', price: 199 }, start);\n\n// Simulate billing day (Feb 1)\nconst billingDay = new Date('2024-01-31');\nconsole.log('Billing results:', sb.runBilling(billingDay));",
      "output": "Billing results: [\n  { userId: 'alice', status: 'PAID', nextBilling: '2024-03-01' },\n  { userId: 'bob', status: 'PAID', nextBilling: '2024-03-01' }\n]"
    },
    {
      "question": "Program 8: Exchange rate converter",
      "code": "class ExchangeRates {\n  constructor() { this.rates = new Map(); }\n  setRate(from, to, rate) {\n    this.rates.set(`${from}:${to}`, rate);\n    this.rates.set(`${to}:${from}`, 1 / rate);\n  }\n  convert(amount, from, to) {\n    if (from === to) return { amount, from, to, rate: 1 };\n    const rate = this.rates.get(`${from}:${to}`);\n    if (!rate) return { error: `No rate: ${from} → ${to}` };\n    return {\n      original: { amount, currency: from },\n      converted: { amount: parseFloat((amount * rate).toFixed(2)), currency: to },\n      rate: parseFloat(rate.toFixed(4)),\n    };\n  }\n}\n\nconst fx = new ExchangeRates();\nfx.setRate('USD', 'INR', 83.5);\nfx.setRate('USD', 'EUR', 0.92);\nfx.setRate('GBP', 'USD', 1.27);\n\nconsole.log(fx.convert(100, 'USD', 'INR'));\nconsole.log(fx.convert(5000, 'INR', 'USD'));\nconsole.log(fx.convert(50, 'GBP', 'USD'));\nconsole.log(fx.convert(100, 'INR', 'GBP')); // no direct rate",
      "output": "{\n  original: { amount: 100, currency: 'USD' },\n  converted: { amount: 8350, currency: 'INR' },\n  rate: 83.5\n}\n{\n  original: { amount: 5000, currency: 'INR' },\n  converted: { amount: 59.88, currency: 'USD' },\n  rate: 0.012\n}\n{\n  original: { amount: 50, currency: 'GBP' },\n  converted: { amount: 63.5, currency: 'USD' },\n  rate: 1.27\n}\n{ error: 'No rate: INR → GBP' }"
    },
    {
      "question": "Program 9: Payment retry with exponential backoff",
      "code": "class PaymentRetry {\n  constructor(maxRetries) { this.maxRetries = maxRetries; this.log = []; }\n  process(paymentId, simulateFailures = 0) {\n    let attempt = 0;\n    let failCount = 0;\n    while (attempt <= this.maxRetries) {\n      attempt++;\n      const delay = attempt === 1 ? 0 : Math.pow(2, attempt - 1) * 1000;\n      \n      if (failCount < simulateFailures) {\n        failCount++;\n        this.log.push({ paymentId, attempt, delay: `${delay}ms`, result: 'FAILED' });\n        continue;\n      }\n      \n      this.log.push({ paymentId, attempt, delay: `${delay}ms`, result: 'SUCCESS' });\n      return { paymentId, status: 'COMPLETED', attempts: attempt };\n    }\n    return { paymentId, status: 'DEAD_LETTER', attempts: attempt - 1 };\n  }\n}\n\nconst pr = new PaymentRetry(3);\nconsole.log(pr.process('P1', 0));  // succeeds first time\nconsole.log(pr.process('P2', 2));  // fails twice, succeeds third\nconsole.log(pr.process('P3', 5));  // always fails\nconsole.log('Log:', pr.log);",
      "output": "{ paymentId: 'P1', status: 'COMPLETED', attempts: 1 }\n{ paymentId: 'P2', status: 'COMPLETED', attempts: 3 }\n{ paymentId: 'P3', status: 'DEAD_LETTER', attempts: 3 }\nLog: [\n  { paymentId: 'P1', attempt: 1, delay: '0ms', result: 'SUCCESS' },\n  { paymentId: 'P2', attempt: 1, delay: '0ms', result: 'FAILED' },\n  { paymentId: 'P2', attempt: 2, delay: '2000ms', result: 'FAILED' },\n  { paymentId: 'P2', attempt: 3, delay: '4000ms', result: 'SUCCESS' },\n  { paymentId: 'P3', attempt: 1, delay: '0ms', result: 'FAILED' },\n  { paymentId: 'P3', attempt: 2, delay: '2000ms', result: 'FAILED' },\n  { paymentId: 'P3', attempt: 3, delay: '4000ms', result: 'FAILED' }\n]"
    },
    {
      "question": "Program 10: Payment analytics dashboard",
      "code": "class PaymentAnalytics {\n  constructor() { this.transactions = []; }\n  record(tx) { this.transactions.push(tx); }\n  summary() {\n    const total = this.transactions.length;\n    const completed = this.transactions.filter(t => t.status === 'COMPLETED');\n    const failed = this.transactions.filter(t => t.status === 'FAILED');\n    const refunded = this.transactions.filter(t => t.status === 'REFUNDED');\n    const volume = completed.reduce((s, t) => s + t.amount, 0);\n    const avgTx = completed.length ? volume / completed.length : 0;\n    const byMethod = {};\n    completed.forEach(t => { byMethod[t.method] = (byMethod[t.method] || 0) + t.amount; });\n    return {\n      totalTransactions: total,\n      completed: completed.length,\n      failed: failed.length,\n      refunded: refunded.length,\n      successRate: (completed.length / total * 100).toFixed(1) + '%',\n      totalVolume: volume,\n      avgTransaction: parseFloat(avgTx.toFixed(2)),\n      byMethod,\n    };\n  }\n}\n\nconst pa = new PaymentAnalytics();\npa.record({ id: 1, amount: 500, status: 'COMPLETED', method: 'UPI' });\npa.record({ id: 2, amount: 1200, status: 'COMPLETED', method: 'card' });\npa.record({ id: 3, amount: 300, status: 'FAILED', method: 'UPI' });\npa.record({ id: 4, amount: 800, status: 'COMPLETED', method: 'UPI' });\npa.record({ id: 5, amount: 1500, status: 'COMPLETED', method: 'card' });\npa.record({ id: 6, amount: 200, status: 'REFUNDED', method: 'UPI' });\n\nconsole.log(pa.summary());",
      "output": "{\n  totalTransactions: 6,\n  completed: 4,\n  failed: 1,\n  refunded: 1,\n  successRate: '66.7%',\n  totalVolume: 4000,\n  avgTransaction: 1000,\n  byMethod: { UPI: 1300, card: 2700 }\n}"
    }
  ]
}