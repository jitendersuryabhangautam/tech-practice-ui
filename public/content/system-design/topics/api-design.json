{
  "id": "api-design",
  "title": "API Design & Versioning",
  "category": "Foundations",
  "description": "API design encompasses the principles, patterns, and best practices for building robust, scalable, and developer-friendly interfaces including REST, GraphQL, gRPC, versioning, pagination, and authentication.",
  "explanation": "API (Application Programming Interface) design is the process of defining how clients communicate with backend services. Good API design balances developer experience, performance, maintainability, and security.\n\nREST (Representational State Transfer) is the most common API style, built on HTTP verbs (GET, POST, PUT, DELETE, PATCH) and resource-based URLs. RESTful design uses nouns for resources (/users, /orders), proper HTTP status codes, and stateless interactions. HATEOAS (Hypermedia as the Engine of Application State) embeds navigation links in responses, making APIs self-documenting.\n\nGraphQL is a query language that lets clients request exactly the data they need. It solves REST's over-fetching and under-fetching problems with a single endpoint and typed schema. However, it introduces complexity in caching, authorization per field, and query cost analysis.\n\ngRPC uses Protocol Buffers (protobuf) for binary serialization, offering high performance and strong typing. It supports streaming (unary, server, client, bidirectional) and is ideal for internal microservice communication.\n\nAPI Gateway pattern provides a single entry point that handles routing, authentication, rate limiting, and request transformation. It simplifies client interactions with microservices.\n\nVersioning strategies include URL path (/v1/users), custom headers (Accept-Version: v2), query parameters (?version=2), and content negotiation. URL path versioning is the most explicit and commonly used.\n\nPagination approaches: cursor-based pagination uses an opaque cursor token for the next page (ideal for real-time feeds, no skipping issues), while offset-based uses page/offset parameters (simpler but suffers from data shifting). Idempotency keys ensure that retrying a request doesn't cause duplicate side effects, critical for payment APIs.\n\nAuthentication methods include OAuth 2.0 (authorization framework with access/refresh tokens), JWT (self-contained tokens with claims), and API keys (simple but less secure). Error handling should follow consistent conventions with proper HTTP status codes, error codes, and human-readable messages.",
  "code": "// REST API Design Example with Express-like patterns\nclass APIRouter {\n  constructor(basePath, version) {\n    this.basePath = basePath;\n    this.version = version;\n    this.routes = [];\n    this.middleware = [];\n  }\n\n  // Resource route builder\n  resource(name) {\n    const path = `/${this.version}/${name}`;\n    return {\n      list:   () => ({ method: 'GET',    path }),\n      get:    (id) => ({ method: 'GET',    path: `${path}/${id}` }),\n      create: () => ({ method: 'POST',   path }),\n      update: (id) => ({ method: 'PUT',    path: `${path}/${id}` }),\n      patch:  (id) => ({ method: 'PATCH',  path: `${path}/${id}` }),\n      delete: (id) => ({ method: 'DELETE', path: `${path}/${id}` }),\n    };\n  }\n\n  // Cursor-based pagination helper\n  paginate(items, cursor, limit = 10) {\n    let startIdx = 0;\n    if (cursor) {\n      startIdx = items.findIndex(i => i.id === cursor) + 1;\n    }\n    const page = items.slice(startIdx, startIdx + limit);\n    const nextCursor = page.length === limit ? page[page.length - 1].id : null;\n    return {\n      data: page,\n      pagination: {\n        nextCursor,\n        hasMore: nextCursor !== null,\n        limit\n      }\n    };\n  }\n\n  // Idempotency key handler\n  idempotencyCheck(key, store) {\n    if (store.has(key)) {\n      return { cached: true, response: store.get(key) };\n    }\n    return { cached: false };\n  }\n\n  // Standard error response builder\n  static errorResponse(statusCode, code, message, details = null) {\n    return {\n      status: statusCode,\n      error: {\n        code,\n        message,\n        ...(details && { details }),\n        timestamp: new Date().toISOString()\n      }\n    };\n  }\n\n  // HATEOAS link builder\n  static hateoasLinks(resource, id, basePath) {\n    return {\n      self: { href: `${basePath}/${resource}/${id}` },\n      collection: { href: `${basePath}/${resource}` },\n      update: { href: `${basePath}/${resource}/${id}`, method: 'PUT' },\n      delete: { href: `${basePath}/${resource}/${id}`, method: 'DELETE' }\n    };\n  }\n}",
  "example": "// Using the API Router\nconst api = new APIRouter('/api', 'v1');\n\n// RESTful routes\nconst users = api.resource('users');\nconsole.log('List users:', users.list());\nconsole.log('Get user:', users.get('123'));\nconsole.log('Create user:', users.create());\n\n// Cursor-based pagination\nconst items = Array.from({ length: 25 }, (_, i) => ({ id: `item-${i}`, name: `Item ${i}` }));\nconst page1 = api.paginate(items, null, 5);\nconsole.log('Page 1:', page1.data.length, 'items, next:', page1.pagination.nextCursor);\nconst page2 = api.paginate(items, page1.pagination.nextCursor, 5);\nconsole.log('Page 2:', page2.data.length, 'items, next:', page2.pagination.nextCursor);\n\n// Error responses\nconsole.log('404:', APIRouter.errorResponse(404, 'NOT_FOUND', 'User not found'));\nconsole.log('422:', APIRouter.errorResponse(422, 'VALIDATION_ERROR', 'Invalid input', [\n  { field: 'email', message: 'must be valid email' }\n]));\n\n// HATEOAS\nconsole.log('Links:', APIRouter.hateoasLinks('users', '123', '/api/v1'));\n\n// Idempotency\nconst store = new Map();\nstore.set('key-abc', { orderId: 'ord-1', status: 'created' });\nconsole.log('Idempotent check:', api.idempotencyCheck('key-abc', store));",
  "useCase": "Used when designing public or internal APIs to ensure consistency, developer-friendliness, proper versioning, security, and scalability across services.",
  "interviewQuestions": [
    {
      "question": "What are the key principles of RESTful API design?",
      "answer": "REST principles include: 1) Resource-based URLs using nouns (/users, /orders). 2) Proper HTTP methods (GET for read, POST for create, PUT for full update, PATCH for partial, DELETE for removal). 3) Statelessness — each request contains all needed information. 4) Proper HTTP status codes (200, 201, 204, 400, 404, 500). 5) Consistent response format. 6) HATEOAS for discoverability. 7) Content negotiation via Accept headers."
    },
    {
      "question": "What are the pros and cons of GraphQL vs REST?",
      "answer": "GraphQL pros: clients request exactly what they need (no over/under-fetching), single endpoint, strong typing, built-in documentation (introspection), excellent for complex UIs with varied data needs. Cons: caching is harder (single endpoint), complex authorization per field, query cost analysis needed to prevent expensive queries, learning curve, tooling overhead. REST is simpler, better cacheable (HTTP caching), and more widely understood."
    },
    {
      "question": "When would you choose gRPC over REST?",
      "answer": "Choose gRPC for: internal microservice communication (high performance, strong typing), streaming use cases (real-time data, server push), polyglot environments (protobuf generates clients for many languages), when bandwidth is critical (binary serialization is 5-10x smaller than JSON). Stick with REST for: public APIs (broader tooling), browser clients (gRPC-web exists but adds complexity), simple CRUD operations, when human-readability matters."
    },
    {
      "question": "What are the different API versioning strategies and their trade-offs?",
      "answer": "URL path versioning (/v1/users): most explicit, easy to route and cache, but clutters URLs. Header versioning (Accept-Version: v2): clean URLs, but harder to test in browsers. Query parameter (?version=2): simple but pollutes query string. Content negotiation (Accept: application/vnd.api.v2+json): standard compliant but complex. URL path is the most widely used due to its simplicity and explicitness."
    },
    {
      "question": "Explain cursor-based vs offset-based pagination.",
      "answer": "Offset-based (page=3&limit=10): simple, supports jumping to any page, but suffers from data shifting (inserts/deletes between pages cause duplicates or missed items), and performance degrades with large offsets (OFFSET in SQL scans rows). Cursor-based (after=abc123&limit=10): uses an opaque token pointing to the last item, consistent with real-time data, efficient (WHERE id > cursor), but can't jump to arbitrary pages. Cursor-based is preferred for feeds and infinite scroll."
    },
    {
      "question": "What are idempotency keys and why are they important?",
      "answer": "Idempotency keys are unique identifiers (typically UUIDs) sent by clients in request headers to ensure that retrying a request produces the same result without side effects. The server stores the key with the response, and on retry, returns the cached response. Critical for payment APIs — if a network error occurs after the server processes a payment but before the client receives the response, retrying with the same idempotency key returns the original result instead of charging twice."
    },
    {
      "question": "Compare OAuth 2.0, JWT, and API keys for API authentication.",
      "answer": "API keys: simple string tokens, easy to implement, but hard to scope permissions, can't represent user context, and if leaked, full access until revoked. JWT: self-contained tokens with claims (user ID, roles, expiry), no server-side session storage needed, but can't be easily revoked before expiry. OAuth 2.0: authorization framework supporting multiple grant types (auth code, client credentials), provides scoped access tokens and refresh tokens, supports third-party authorization. Use API keys for server-to-server, JWT for stateless auth, OAuth for third-party access."
    },
    {
      "question": "What is the API Gateway pattern and what problems does it solve?",
      "answer": "An API Gateway is a single entry point for all client requests that routes them to appropriate microservices. It solves: 1) Client complexity — clients call one endpoint instead of many services. 2) Cross-cutting concerns — centralized authentication, rate limiting, logging, CORS. 3) Protocol translation — REST to gRPC, WebSocket aggregation. 4) Response aggregation — combining data from multiple services. 5) API versioning. Trade-offs: single point of failure, added latency, can become a bottleneck."
    },
    {
      "question": "How should API error responses be structured?",
      "answer": "A consistent error response should include: HTTP status code (4xx for client errors, 5xx for server errors), machine-readable error code ('VALIDATION_ERROR', 'NOT_FOUND'), human-readable message, optional details array for field-level errors, request ID for debugging, and documentation link. Example: { error: { code: 'VALIDATION_ERROR', message: 'Invalid input', details: [{ field: 'email', message: 'must be valid' }], requestId: 'req-123' } }. Never expose internal errors or stack traces."
    },
    {
      "question": "What is HATEOAS and is it worth implementing?",
      "answer": "HATEOAS (Hypermedia as the Engine of Application State) means API responses include links to related actions and resources, making the API self-navigating. Example: a user response includes links to their orders, profile update endpoint, and delete action. Pros: self-documenting, clients can discover capabilities dynamically, reduces coupling. Cons: increases response size, most clients hardcode URLs anyway, added complexity. It's part of REST maturity level 3 but rarely fully implemented in practice. It's most valuable for public APIs with diverse clients."
    }
  ],
  "exercises": [
    {
      "type": "design",
      "question": "Design a RESTful API for a social media platform with users, posts, comments, and likes. Include authentication, pagination, and versioning.",
      "answer": "Base URL: /api/v1. Resources: GET /users/:id, POST /users (register), POST /auth/login (returns JWT), GET /posts?cursor=x&limit=20, POST /posts (auth required), GET /posts/:id/comments?cursor=x, POST /posts/:id/comments, POST /posts/:id/like, DELETE /posts/:id/like. Auth: JWT in Authorization header. Pagination: cursor-based for feeds. Versioning: URL path. Rate limits: 100 req/min for reads, 20 req/min for writes. Error format: { error: { code, message, details } }."
    },
    {
      "type": "scenario",
      "question": "Your API team wants to deprecate v1 and release v2 with breaking changes. How do you manage the migration without disrupting existing clients?",
      "answer": "1) Announce deprecation timeline (e.g., 6 months). 2) Add Deprecation and Sunset headers to v1 responses. 3) Provide a migration guide documenting all changes. 4) Run v1 and v2 in parallel. 5) Monitor v1 usage and proactively contact high-volume users. 6) Add v1 rate limit reduction schedule. 7) Provide SDK updates with v2 support. 8) After sunset date, return 410 Gone with migration URL. Never hard-cut without warning."
    },
    {
      "type": "estimation",
      "question": "An API serves 100,000 requests per second. Each response is 2KB. Calculate CDN bandwidth costs at $0.02/GB.",
      "answer": "100K req/s * 2KB = 200MB/s = 200 * 86400 = 17.28 TB/day = 518.4 TB/month. At $0.02/GB: 518,400 GB * $0.02 = $10,368/month. With 70% cache hit rate at CDN: origin serves 30% = 155.52 TB, CDN serves 362.88 TB. CDN cost: 362,880 GB * $0.02 = $7,257.60/month for CDN bandwidth alone. Savings from reduced origin load offset this cost."
    },
    {
      "type": "debug",
      "question": "Your REST API returns 200 for all responses, including errors. The team argues this makes client parsing simpler. What's wrong with this approach?",
      "answer": "Problems: 1) HTTP intermediaries (caches, proxies, CDNs) use status codes — caching a 200 error response means clients see stale errors. 2) Monitoring and alerting tools use status codes to track error rates. 3) Retry logic in HTTP clients is status-code-based. 4) It violates HTTP semantics, confusing developers. 5) Load balancers use 5xx to detect unhealthy backends. Fix: use proper status codes (400, 404, 422, 500) with a consistent error body format."
    },
    {
      "type": "tricky",
      "question": "Should PUT or PATCH be used to update a user's email? What about updating the entire user profile?",
      "answer": "For updating just the email: use PATCH — it's a partial update, sending only the changed field ({ email: 'new@example.com' }). For updating the entire profile: use PUT — it replaces the complete resource (send all fields). PUT is idempotent by definition (same request = same result). PATCH can be idempotent but isn't required to be. Common mistake: using PUT for partial updates, which should null out unsent fields according to REST semantics."
    },
    {
      "type": "design",
      "question": "Design a GraphQL schema for an e-commerce platform with products, categories, reviews, and shopping cart.",
      "answer": "Types: Product (id, name, price, description, category: Category, reviews: [Review], avgRating), Category (id, name, products: [Product]), Review (id, text, rating, author: User, createdAt), Cart (id, items: [CartItem], total), CartItem (product: Product, quantity, subtotal). Queries: products(filter, sort, first, after), product(id), categories, cart. Mutations: addToCart(productId, qty), removeFromCart(itemId), createReview(productId, text, rating). Use DataLoader for N+1 prevention, query depth limiting, and persisted queries for security."
    },
    {
      "type": "explain",
      "question": "Explain the N+1 problem in GraphQL and how to solve it.",
      "answer": "N+1 occurs when a query requests a list of N items (1 query) and then each item triggers a separate query for related data (N queries). Example: querying 50 posts, each needing its author — results in 1 + 50 queries. Solutions: 1) DataLoader — batches individual requests into a single query per tick (50 author queries become 1 WHERE id IN (...)). 2) Join Monster / Hasura — compile GraphQL to SQL joins. 3) Look-ahead — inspect the query AST and eager-load relationships. DataLoader is the standard solution."
    },
    {
      "type": "scenario",
      "question": "Your public API supports both JSON and XML responses. A client sends Accept: application/xml but your new endpoint only supports JSON. What should you return?",
      "answer": "Return HTTP 406 Not Acceptable with a JSON body (since that's your default) listing the supported content types: { error: { code: 'NOT_ACCEPTABLE', message: 'This endpoint only supports application/json', supportedTypes: ['application/json'] } }. Alternatively, you could return JSON with a warning header if you want to be lenient. The proper REST approach is 406 to let the client know content negotiation failed."
    },
    {
      "type": "estimation",
      "question": "You need to design an API that supports 50 million users with an average of 10 API calls per day. Estimate the infrastructure requirements.",
      "answer": "50M users * 10 calls/day = 500M requests/day. Assuming 80% in 8 peak hours: 400M / 8h = 50M/hour = ~13,889 req/s peak. At 2x safety margin: ~28K req/s capacity. With ~200ms avg response time: each server handles ~50 req/s = ~560 application servers. With 1KB avg response: 28K * 1KB = 28MB/s bandwidth. Database: assuming 30% write, 70% read = ~9.7K writes/s, ~19.4K reads/s. Need read replicas and caching (Redis) for hot data."
    },
    {
      "type": "debug",
      "question": "Your API uses JWT tokens with no expiration. A user's token is leaked in a GitHub commit. What's the impact and how do you fix it?",
      "answer": "Impact: unlimited access to the user's account until manually revoked. Without expiration, there's no automatic invalidation. Immediate fix: invalidate the token by adding it to a blacklist checked on every request. Long-term fixes: 1) Always set JWT expiration (e.g., 15 minutes). 2) Use refresh tokens (long-lived, stored securely) to get new access tokens. 3) Implement token rotation. 4) Add IP binding or device fingerprinting. 5) Implement GitHub secret scanning integration."
    }
  ],
  "programExercises": [
    {
      "question": "Program 1: Build a RESTful route matcher",
      "code": "class Router {\n  constructor() {\n    this.routes = [];\n  }\n\n  add(method, path, handler) {\n    const paramNames = [];\n    const regexPath = path.replace(/:([\\w]+)/g, (_, name) => {\n      paramNames.push(name);\n      return '([\\\\w-]+)';\n    });\n    this.routes.push({\n      method,\n      regex: new RegExp(`^${regexPath}$`),\n      paramNames,\n      handler\n    });\n  }\n\n  match(method, url) {\n    for (const route of this.routes) {\n      if (route.method !== method) continue;\n      const match = url.match(route.regex);\n      if (match) {\n        const params = {};\n        route.paramNames.forEach((name, i) => params[name] = match[i + 1]);\n        return { handler: route.handler, params };\n      }\n    }\n    return null;\n  }\n}\n\nconst router = new Router();\nrouter.add('GET', '/api/v1/users', 'listUsers');\nrouter.add('GET', '/api/v1/users/:id', 'getUser');\nrouter.add('POST', '/api/v1/users/:id/posts', 'createPost');\nrouter.add('GET', '/api/v1/users/:userId/posts/:postId', 'getPost');\n\nconsole.log(router.match('GET', '/api/v1/users'));\nconsole.log(router.match('GET', '/api/v1/users/42'));\nconsole.log(router.match('GET', '/api/v1/users/42/posts/7'));",
      "output": "{ handler: 'listUsers', params: {} }\n{ handler: 'getUser', params: { id: '42' } }\n{ handler: 'getPost', params: { userId: '42', postId: '7' } }"
    },
    {
      "question": "Program 2: Implement cursor-based pagination",
      "code": "function cursorPaginate(items, cursor, limit) {\n  let startIdx = 0;\n  if (cursor) {\n    const decoded = Buffer.from(cursor, 'base64').toString();\n    startIdx = items.findIndex(i => i.id === decoded) + 1;\n  }\n\n  const page = items.slice(startIdx, startIdx + limit);\n  const hasNext = startIdx + limit < items.length;\n  const endCursor = page.length > 0\n    ? Buffer.from(page[page.length - 1].id).toString('base64')\n    : null;\n\n  return {\n    edges: page.map(item => ({ node: item, cursor: Buffer.from(item.id).toString('base64') })),\n    pageInfo: { hasNextPage: hasNext, endCursor }\n  };\n}\n\nconst items = Array.from({ length: 10 }, (_, i) => ({ id: `item-${i}`, title: `Title ${i}` }));\n\nconst page1 = cursorPaginate(items, null, 3);\nconsole.log('Page 1 items:', page1.edges.map(e => e.node.id));\nconsole.log('Has next:', page1.pageInfo.hasNextPage);\n\nconst page2 = cursorPaginate(items, page1.pageInfo.endCursor, 3);\nconsole.log('Page 2 items:', page2.edges.map(e => e.node.id));\nconsole.log('Has next:', page2.pageInfo.hasNextPage);",
      "output": "Page 1 items: [ 'item-0', 'item-1', 'item-2' ]\nHas next: true\nPage 2 items: [ 'item-3', 'item-4', 'item-5' ]\nHas next: true"
    },
    {
      "question": "Program 3: Implement an API response builder with HATEOAS",
      "code": "class ResponseBuilder {\n  constructor(baseUrl) {\n    this.baseUrl = baseUrl;\n  }\n\n  success(data, links = {}) {\n    return { status: 200, data, _links: links };\n  }\n\n  created(data, links = {}) {\n    return { status: 201, data, _links: links };\n  }\n\n  error(status, code, message) {\n    return { status, error: { code, message } };\n  }\n\n  resourceLinks(resource, id) {\n    return {\n      self: `${this.baseUrl}/${resource}/${id}`,\n      collection: `${this.baseUrl}/${resource}`,\n      update: `${this.baseUrl}/${resource}/${id}`,\n      delete: `${this.baseUrl}/${resource}/${id}`\n    };\n  }\n}\n\nconst rb = new ResponseBuilder('/api/v1');\n\nconst user = { id: '42', name: 'Alice', email: 'alice@example.com' };\nconst response = rb.success(user, rb.resourceLinks('users', '42'));\nconsole.log(JSON.stringify(response, null, 2));\n\nconst errorResp = rb.error(404, 'NOT_FOUND', 'User not found');\nconsole.log(JSON.stringify(errorResp, null, 2));",
      "output": "{\n  \"status\": 200,\n  \"data\": {\n    \"id\": \"42\",\n    \"name\": \"Alice\",\n    \"email\": \"alice@example.com\"\n  },\n  \"_links\": {\n    \"self\": \"/api/v1/users/42\",\n    \"collection\": \"/api/v1/users\",\n    \"update\": \"/api/v1/users/42\",\n    \"delete\": \"/api/v1/users/42\"\n  }\n}\n{\n  \"status\": 404,\n  \"error\": {\n    \"code\": \"NOT_FOUND\",\n    \"message\": \"User not found\"\n  }\n}"
    },
    {
      "question": "Program 4: Implement an idempotency key handler",
      "code": "class IdempotencyStore {\n  constructor(ttlMs = 86400000) {\n    this.store = new Map();\n    this.ttlMs = ttlMs;\n  }\n\n  check(key) {\n    const entry = this.store.get(key);\n    if (entry && Date.now() - entry.createdAt < this.ttlMs) {\n      return { exists: true, response: entry.response };\n    }\n    return { exists: false };\n  }\n\n  save(key, response) {\n    this.store.set(key, { response, createdAt: Date.now() });\n  }\n\n  processRequest(key, handler) {\n    const cached = this.check(key);\n    if (cached.exists) {\n      return { ...cached.response, fromCache: true };\n    }\n    const response = handler();\n    this.save(key, response);\n    return { ...response, fromCache: false };\n  }\n}\n\nconst store = new IdempotencyStore();\n\n// First request - processes normally\nconst r1 = store.processRequest('pay-key-123', () => ({\n  orderId: 'ord-1',\n  amount: 99.99,\n  status: 'charged'\n}));\nconsole.log('Request 1:', r1);\n\n// Retry with same key - returns cached\nconst r2 = store.processRequest('pay-key-123', () => ({\n  orderId: 'ord-1',\n  amount: 99.99,\n  status: 'charged'\n}));\nconsole.log('Request 2 (retry):', r2);\n\n// Different key - processes normally\nconst r3 = store.processRequest('pay-key-456', () => ({\n  orderId: 'ord-2',\n  amount: 49.99,\n  status: 'charged'\n}));\nconsole.log('Request 3:', r3);",
      "output": "Request 1: { orderId: 'ord-1', amount: 99.99, status: 'charged', fromCache: false }\nRequest 2 (retry): { orderId: 'ord-1', amount: 99.99, status: 'charged', fromCache: true }\nRequest 3: { orderId: 'ord-2', amount: 49.99, status: 'charged', fromCache: false }"
    },
    {
      "question": "Program 5: Implement a query string parser and builder",
      "code": "class QueryBuilder {\n  constructor() {\n    this.params = new Map();\n  }\n\n  set(key, value) {\n    this.params.set(key, value);\n    return this;\n  }\n\n  filter(field, op, value) {\n    this.params.set(`filter[${field}][${op}]`, value);\n    return this;\n  }\n\n  sort(field, order = 'asc') {\n    this.params.set('sort', `${order === 'desc' ? '-' : ''}${field}`);\n    return this;\n  }\n\n  paginate(cursor, limit) {\n    if (cursor) this.params.set('cursor', cursor);\n    this.params.set('limit', limit);\n    return this;\n  }\n\n  build() {\n    const parts = [];\n    for (const [key, value] of this.params) {\n      parts.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);\n    }\n    return parts.length > 0 ? `?${parts.join('&')}` : '';\n  }\n\n  static parse(queryString) {\n    const params = {};\n    const cleaned = queryString.startsWith('?') ? queryString.slice(1) : queryString;\n    cleaned.split('&').forEach(pair => {\n      const [key, value] = pair.split('=').map(decodeURIComponent);\n      params[key] = value;\n    });\n    return params;\n  }\n}\n\nconst query = new QueryBuilder()\n  .filter('price', 'gte', '10')\n  .filter('category', 'eq', 'electronics')\n  .sort('price', 'desc')\n  .paginate(null, 20)\n  .build();\n\nconsole.log('Built query:', query);\nconsole.log('Parsed:', QueryBuilder.parse(query));",
      "output": "Built query: ?filter%5Bprice%5D%5Bgte%5D=10&filter%5Bcategory%5D%5Beq%5D=electronics&sort=-price&limit=20\nParsed: {\n  'filter[price][gte]': '10',\n  'filter[category][eq]': 'electronics',\n  sort: '-price',\n  limit: '20'\n}"
    },
    {
      "question": "Program 6: Implement a simple JWT encoder and decoder",
      "code": "class SimpleJWT {\n  static base64url(str) {\n    return Buffer.from(str).toString('base64')\n      .replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n  }\n\n  static base64urlDecode(str) {\n    str = str.replace(/-/g, '+').replace(/_/g, '/');\n    while (str.length % 4) str += '=';\n    return Buffer.from(str, 'base64').toString();\n  }\n\n  static sign(payload, secret) {\n    const header = { alg: 'HS256', typ: 'JWT' };\n    const h = this.base64url(JSON.stringify(header));\n    const p = this.base64url(JSON.stringify(payload));\n    // Simplified signature (not cryptographically secure)\n    const sig = this.base64url(secret + '.' + h + '.' + p);\n    return `${h}.${p}.${sig}`;\n  }\n\n  static decode(token) {\n    const [header, payload] = token.split('.');\n    return {\n      header: JSON.parse(this.base64urlDecode(header)),\n      payload: JSON.parse(this.base64urlDecode(payload))\n    };\n  }\n\n  static isExpired(token) {\n    const { payload } = this.decode(token);\n    if (!payload.exp) return false;\n    return Date.now() / 1000 > payload.exp;\n  }\n}\n\nconst token = SimpleJWT.sign({\n  sub: 'user-42',\n  name: 'Alice',\n  role: 'admin',\n  exp: Math.floor(Date.now() / 1000) + 3600\n}, 'my-secret');\n\nconsole.log('Token parts:', token.split('.').length);\nconst decoded = SimpleJWT.decode(token);\nconsole.log('Header:', decoded.header);\nconsole.log('User:', decoded.payload.sub, decoded.payload.name);\nconsole.log('Role:', decoded.payload.role);\nconsole.log('Expired:', SimpleJWT.isExpired(token));",
      "output": "Token parts: 3\nHeader: { alg: 'HS256', typ: 'JWT' }\nUser: user-42 Alice\nRole: admin\nExpired: false"
    },
    {
      "question": "Program 7: Implement API versioning with content negotiation",
      "code": "class VersionedAPI {\n  constructor() {\n    this.handlers = new Map(); // 'method:path:version' -> handler\n  }\n\n  register(method, path, version, handler) {\n    this.handlers.set(`${method}:${path}:${version}`, handler);\n  }\n\n  parseVersion(acceptHeader) {\n    // Parse: application/vnd.api.v2+json\n    const match = acceptHeader?.match(/vnd\\.api\\.v(\\d+)/);\n    return match ? parseInt(match[1]) : 1; // default v1\n  }\n\n  handle(method, path, headers = {}) {\n    const version = this.parseVersion(headers['accept']);\n    const key = `${method}:${path}:${version}`;\n    const handler = this.handlers.get(key);\n\n    if (handler) {\n      return { status: 200, version, data: handler() };\n    }\n    // Fallback to latest available version\n    for (let v = version - 1; v >= 1; v--) {\n      const fallbackKey = `${method}:${path}:${v}`;\n      if (this.handlers.has(fallbackKey)) {\n        return { status: 200, version: v, data: this.handlers.get(fallbackKey)(), fallback: true };\n      }\n    }\n    return { status: 404, error: 'Not found' };\n  }\n}\n\nconst api = new VersionedAPI();\napi.register('GET', '/users', 1, () => [{ id: 1, name: 'Alice' }]);\napi.register('GET', '/users', 2, () => [{ id: 1, firstName: 'Alice', lastName: 'Smith' }]);\n\nconsole.log('V1:', api.handle('GET', '/users', { accept: 'application/vnd.api.v1+json' }));\nconsole.log('V2:', api.handle('GET', '/users', { accept: 'application/vnd.api.v2+json' }));\nconsole.log('No version:', api.handle('GET', '/users', {}));",
      "output": "V1: { status: 200, version: 1, data: [ { id: 1, name: 'Alice' } ] }\nV2: {\n  status: 200,\n  version: 2,\n  data: [ { id: 1, firstName: 'Alice', lastName: 'Smith' } ]\n}\nNo version: { status: 200, version: 1, data: [ { id: 1, name: 'Alice' } ] }"
    },
    {
      "question": "Program 8: Implement a request validator",
      "code": "class RequestValidator {\n  constructor() {\n    this.rules = {};\n  }\n\n  schema(rules) {\n    this.rules = rules;\n    return this;\n  }\n\n  validate(data) {\n    const errors = [];\n\n    for (const [field, rule] of Object.entries(this.rules)) {\n      const value = data[field];\n\n      if (rule.required && (value === undefined || value === null || value === '')) {\n        errors.push({ field, message: `${field} is required` });\n        continue;\n      }\n\n      if (value === undefined) continue;\n\n      if (rule.type && typeof value !== rule.type) {\n        errors.push({ field, message: `${field} must be a ${rule.type}` });\n      }\n\n      if (rule.minLength && typeof value === 'string' && value.length < rule.minLength) {\n        errors.push({ field, message: `${field} must be at least ${rule.minLength} characters` });\n      }\n\n      if (rule.pattern && !rule.pattern.test(value)) {\n        errors.push({ field, message: `${field} format is invalid` });\n      }\n\n      if (rule.min !== undefined && value < rule.min) {\n        errors.push({ field, message: `${field} must be >= ${rule.min}` });\n      }\n    }\n\n    return { valid: errors.length === 0, errors };\n  }\n}\n\nconst validator = new RequestValidator().schema({\n  name: { required: true, type: 'string', minLength: 2 },\n  email: { required: true, type: 'string', pattern: /^[^@]+@[^@]+$/ },\n  age: { required: false, type: 'number', min: 18 }\n});\n\nconsole.log(validator.validate({ name: 'Al', email: 'alice@test.com', age: 25 }));\nconsole.log(validator.validate({ name: '', email: 'invalid', age: 15 }));\nconsole.log(validator.validate({ name: 'Bob', email: 'bob@test.com' }));",
      "output": "{ valid: true, errors: [] }\n{\n  valid: false,\n  errors: [\n    { field: 'name', message: 'name is required' },\n    { field: 'email', message: 'email format is invalid' },\n    { field: 'age', message: 'age must be >= 18' }\n  ]\n}\n{ valid: true, errors: [] }"
    },
    {
      "question": "Program 9: Implement an API rate limit header tracker",
      "code": "class RateLimitTracker {\n  constructor() {\n    this.apis = new Map();\n  }\n\n  updateFromHeaders(apiName, headers) {\n    this.apis.set(apiName, {\n      limit: parseInt(headers['x-ratelimit-limit']),\n      remaining: parseInt(headers['x-ratelimit-remaining']),\n      reset: parseInt(headers['x-ratelimit-reset']),\n      updatedAt: Date.now()\n    });\n  }\n\n  canMakeRequest(apiName, now = Date.now()) {\n    const info = this.apis.get(apiName);\n    if (!info) return { allowed: true, reason: 'no tracking data' };\n\n    // If reset time has passed, limits are refreshed\n    if (now / 1000 >= info.reset) {\n      return { allowed: true, reason: 'window reset' };\n    }\n\n    if (info.remaining > 0) {\n      return { allowed: true, remaining: info.remaining };\n    }\n\n    const waitSeconds = Math.ceil(info.reset - now / 1000);\n    return { allowed: false, retryAfterSeconds: waitSeconds };\n  }\n\n  getStatus() {\n    const status = {};\n    for (const [name, info] of this.apis) {\n      status[name] = `${info.remaining}/${info.limit}`;\n    }\n    return status;\n  }\n}\n\nconst tracker = new RateLimitTracker();\n\ntracker.updateFromHeaders('github', {\n  'x-ratelimit-limit': '5000',\n  'x-ratelimit-remaining': '4985',\n  'x-ratelimit-reset': String(Math.floor(Date.now() / 1000) + 3600)\n});\n\ntracker.updateFromHeaders('twitter', {\n  'x-ratelimit-limit': '300',\n  'x-ratelimit-remaining': '0',\n  'x-ratelimit-reset': String(Math.floor(Date.now() / 1000) + 120)\n});\n\nconsole.log('Status:', tracker.getStatus());\nconsole.log('GitHub:', tracker.canMakeRequest('github'));\nconsole.log('Twitter:', tracker.canMakeRequest('twitter'));",
      "output": "Status: { github: '4985/5000', twitter: '0/300' }\nGitHub: { allowed: true, remaining: 4985 }\nTwitter: { allowed: false, retryAfterSeconds: 120 }"
    },
    {
      "question": "Program 10: Implement a GraphQL-style field selector",
      "code": "function selectFields(data, fields) {\n  if (Array.isArray(data)) {\n    return data.map(item => selectFields(item, fields));\n  }\n\n  const result = {};\n  for (const field of fields) {\n    if (typeof field === 'string') {\n      if (field in data) result[field] = data[field];\n    } else if (typeof field === 'object') {\n      const [key] = Object.keys(field);\n      if (key in data) {\n        result[key] = selectFields(data[key], field[key]);\n      }\n    }\n  }\n  return result;\n}\n\nconst user = {\n  id: 1,\n  name: 'Alice',\n  email: 'alice@test.com',\n  age: 30,\n  address: {\n    street: '123 Main St',\n    city: 'Springfield',\n    zip: '12345',\n    country: 'US'\n  },\n  posts: [\n    { id: 1, title: 'Hello', content: 'World', likes: 10 },\n    { id: 2, title: 'GraphQL', content: 'Rocks', likes: 25 }\n  ]\n};\n\n// Select specific fields (like GraphQL query)\nconst result = selectFields(user, [\n  'name',\n  'email',\n  { address: ['city', 'country'] },\n  { posts: ['title', 'likes'] }\n]);\n\nconsole.log(JSON.stringify(result, null, 2));",
      "output": "{\n  \"name\": \"Alice\",\n  \"email\": \"alice@test.com\",\n  \"address\": {\n    \"city\": \"Springfield\",\n    \"country\": \"US\"\n  },\n  \"posts\": [\n    {\n      \"title\": \"Hello\",\n      \"likes\": 10\n    },\n    {\n      \"title\": \"GraphQL\",\n      \"likes\": 25\n    }\n  ]\n}"
    }
  ]
}
