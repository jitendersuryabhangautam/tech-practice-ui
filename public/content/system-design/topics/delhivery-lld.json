{
  "id": "delhivery-lld",
  "title": "Delhivery: Logistics & Delivery Network",
  "category": "Company LLD",
  "description": "Low-level design of Delhivery's package routing, warehouse management, last-mile delivery optimization, and real-time tracking.",
  "explanation": "Delhivery processes 2M+ shipments daily across India's logistics network. The system orchestrates the entire package lifecycle: pickup from seller, regional hub sorting, inter-city transport, last-mile delivery, and returns.\n\n**Package Lifecycle**:\n1. **Manifest**: Seller creates shipment → AWB (Air Waybill) number generated → label printed.\n2. **Pickup**: Delivery partner collects package from seller. Scanned at pickup → status: IN_TRANSIT.\n3. **First-Mile Hub**: Package arrives at local sorting facility. Scanned → sorted by destination zone.\n4. **Linehaul**: Long-distance transport (truck/air) between cities. Route: origin hub → regional hub → destination hub.\n5. **Last-Mile Hub**: Package arrives at delivery hub closest to customer. Sorted by delivery route.\n6. **Out for Delivery**: Assigned to delivery agent. GPS tracking active. Customer notified with ETA.\n7. **Delivery**: Agent delivers → scanned → POD (Proof of Delivery) captured (signature/photo/OTP).\n8. **Returns**: If customer refuses or returns, reverse logistics: customer → hub → seller.\n\n**Route Optimization**:\n- Hub network as a weighted graph. Edge weights = cost (distance, time, mode).\n- Inter-city: Dijkstra's or A* for cheapest route between hubs.\n- Last-mile: TSP (Traveling Salesman Problem) approximation for delivery route optimization.\n- Cluster deliveries by pincode/area for batch routing.\n\n**Warehouse/Hub Operations**:\n- Inbound: scan, weigh, measure, sort by destination zone.\n- Storage: packages assigned to bins/racks by zone for easy retrieval.\n- Outbound: pick packages for next transport, load in delivery sequence.\n- SLA tracking: flag packages approaching delivery deadline.\n\n**Capacity Planning**:\n- Hub capacity: max packages per day based on sorting speed and space.\n- Vehicle capacity: weight and volume constraints. Bin-packing algorithm.\n- Demand forecasting: ML model predicts next-day volumes per hub.\n\n**Cost Calculation**:\n- Based on: weight (actual vs volumetric, whichever is higher), distance (zone-based), speed (express vs standard), package type (fragile, oversized).\n- Volumetric weight = (L × W × H) / 5000.",
  "code": "// Package tracking system\nclass ShipmentTracker {\n  constructor() {\n    this.shipments = new Map();\n    this.awbCounter = 1000;\n  }\n\n  createShipment(seller, destination, weight, dimensions) {\n    const awb = `DL${++this.awbCounter}`;\n    const volumetricWeight = (dimensions.l * dimensions.w * dimensions.h) / 5000;\n    const shipment = {\n      awb,\n      seller,\n      destination,\n      actualWeight: weight,\n      volumetricWeight: +volumetricWeight.toFixed(2),\n      chargeableWeight: Math.max(weight, volumetricWeight),\n      status: 'MANIFESTED',\n      timeline: [{ status: 'MANIFESTED', location: seller.city, at: new Date().toISOString() }],\n      currentLocation: seller.city,\n    };\n    this.shipments.set(awb, shipment);\n    return { awb, chargeableWeight: shipment.chargeableWeight };\n  }\n\n  scan(awb, location, status) {\n    const s = this.shipments.get(awb);\n    if (!s) return { error: 'AWB not found' };\n    s.status = status;\n    s.currentLocation = location;\n    s.timeline.push({ status, location, at: new Date().toISOString() });\n    return { awb, status, location, steps: s.timeline.length };\n  }\n\n  track(awb) {\n    const s = this.shipments.get(awb);\n    if (!s) return null;\n    return {\n      awb: s.awb,\n      status: s.status,\n      currentLocation: s.currentLocation,\n      destination: s.destination.city,\n      timeline: s.timeline,\n    };\n  }\n}\n\nconst tracker = new ShipmentTracker();\nconst { awb } = tracker.createShipment(\n  { name: 'SellerA', city: 'Delhi' },\n  { name: 'CustomerB', city: 'Mumbai', pincode: '400001' },\n  2.5,\n  { l: 30, w: 20, h: 15 }\n);\nconsole.log('Created:', awb);\ntracker.scan(awb, 'Delhi Hub', 'PICKED_UP');\ntracker.scan(awb, 'Delhi Sort Center', 'IN_TRANSIT');\ntracker.scan(awb, 'Mumbai Hub', 'REACHED_DEST_HUB');\ntracker.scan(awb, 'Mumbai', 'OUT_FOR_DELIVERY');\ntracker.scan(awb, 'Mumbai', 'DELIVERED');\nconsole.log(tracker.track(awb));",
  "example": "// Delivery route optimizer (TSP approximation - Nearest Neighbor)\nfunction optimizeRoute(depot, deliveries) {\n  const unvisited = [...deliveries];\n  const route = [depot];\n  let current = depot;\n  let totalDist = 0;\n\n  while (unvisited.length > 0) {\n    let nearest = null;\n    let minDist = Infinity;\n    for (const d of unvisited) {\n      const dist = Math.sqrt(Math.pow(d.lat - current.lat, 2) + Math.pow(d.lng - current.lng, 2));\n      if (dist < minDist) { minDist = dist; nearest = d; }\n    }\n    route.push(nearest);\n    totalDist += minDist;\n    current = nearest;\n    unvisited.splice(unvisited.indexOf(nearest), 1);\n  }\n  // Return to depot\n  totalDist += Math.sqrt(Math.pow(depot.lat - current.lat, 2) + Math.pow(depot.lng - current.lng, 2));\n  route.push(depot);\n\n  return {\n    route: route.map(r => r.id || 'DEPOT'),\n    totalDistance: +(totalDist * 111).toFixed(2) + ' km',\n    stops: deliveries.length,\n  };\n}\n\nconst depot = { id: 'DEPOT', lat: 28.614, lng: 77.209 };\nconst deliveries = [\n  { id: 'D1', lat: 28.620, lng: 77.215 },\n  { id: 'D2', lat: 28.618, lng: 77.205 },\n  { id: 'D3', lat: 28.625, lng: 77.220 },\n  { id: 'D4', lat: 28.610, lng: 77.200 },\n];\nconsole.log(optimizeRoute(depot, deliveries));",
  "useCase": "Logistics and delivery networks, supply chain management, warehouse management systems, fleet management, e-commerce fulfillment.",
  "interviewQuestions": [
    { "question": "How do you design the AWB (tracking number) generation system?", "answer": "Requirements: globally unique, sortable by time, encodes origin hub. Format: prefix(2) + hub_code(3) + timestamp_encoded(8) + sequence(4) + checksum(1). Use Snowflake-like ID generation: datacenter bits + worker bits + sequence bits. ~18 chars total. Checksum digit for validation. Index: B-tree on AWB for O(log n) lookup." },
    { "question": "How do you optimize inter-city routes for millions of packages?", "answer": "Model hub network as directed weighted graph. Edges: transport links with cost (fuel, time, capacity). Use Dijkstra's per origin-destination pair. Pre-compute top routes and cache. For batches: bin-packing to fill trucks efficiently. Time constraint: some routes run on schedule (like bus routes). Dynamic routing for express packages." },
    { "question": "How do you optimize last-mile delivery routes?", "answer": "Cluster deliveries by pincode zone. Per cluster, solve TSP approximation: Nearest Neighbor heuristic (O(n²)), or 2-opt improvement. Constraints: time windows (customer availability), vehicle capacity, fuel. Real-time re-routing if customer reschedules. Typical: 30-50 deliveries per agent per day." },
    { "question": "How do you handle the sorting facility (hub) at scale?", "answer": "Conveyor belt + barcode scanner system. Package scanned → destination pincode → assigned to chute/bin for destination zone. Sort rate: 10K packages/hour per line. Multiple parallel lines. Overflow: manual sorting for irregular packages. ML for OCR on handwritten labels." },
    { "question": "How do you calculate shipping cost?", "answer": "Inputs: origin pincode, dest pincode, actual weight, dimensions (L×W×H). Volumetric weight = L×W×H/5000. Chargeable weight = max(actual, volumetric). Zone = distance band (A: same city, B: regional, C: metro-to-metro, D: rest). Cost = base_rate[zone] × chargeable_weight + fuel_surcharge + handling_fee." },
    { "question": "How do you ensure proof of delivery?", "answer": "Multiple methods: 1) OTP: system sends OTP to customer, agent enters it. 2) Digital signature: customer signs on agent's device. 3) Photo: agent captures photo of package at doorstep. 4) GPS + timestamp: agent's location must be within 100m of delivery address. Store POD as part of shipment record." },
    { "question": "How do you handle returns/reverse logistics?", "answer": "Customer initiates return → pickup scheduled (same flow as forward logistics in reverse). Pickup → local hub → quality check (is item in condition?) → if pass, ship to seller. If fail, return to customer. Separate SLA for returns (longer timeline). Cost: often borne by seller or platform." },
    { "question": "How do you predict next-day delivery volumes per hub?", "answer": "ML model features: historical volumes (same day last week, last month), upcoming events (sales, festivals), weather forecast, day of week. Model: time-series forecasting (ARIMA, Prophet, LSTM). Output: predicted package count per hub. Used for: staffing, vehicle allocation, capacity planning. Retrained weekly." },
    { "question": "How do you handle delivery failures (customer not available)?", "answer": "First attempt: call customer → if no answer, mark as RTO-pending. Second attempt: next day, different time slot. Third attempt: if all fail, initiate RTO (Return to Origin). Customer can reschedule via app/SMS. Hold at hub for max 7 days. After that, auto-RTO. Charge RTO shipping to seller." },
    { "question": "How do you maintain real-time package tracking at scale?", "answer": "Event-driven: each scan generates an event → Kafka → consumers update tracking status in DB + cache. Customer-facing: query Redis for current status (hot path). Full timeline: query DB (cold path). Push notifications on status change. Update frequency: at each physical scan point (6-8 events per delivery lifecycle)." }
  ],
  "exercises": [
    { "type": "design", "question": "Design the real-time shipment tracking system.", "answer": "Events: pickup, hub_inbound, hub_outbound, in_transit, out_for_delivery, delivered. Each event: {awb, status, location, timestamp, agent_id}. Pipeline: scanner/app → API → Kafka → consumer writes to: 1) Redis (latest status per AWB), 2) TimescaleDB (full timeline), 3) Push notification service. Customer query: Redis first, DB fallback for timeline. SLA: event visible within 30 seconds of scan." },
    { "type": "estimation", "question": "2M shipments/day, 7 scan events per shipment, 200 bytes per event. Estimate daily data volume and storage for 1 year.", "answer": "Daily events: 2M × 7 = 14M events. Daily data: 14M × 200B = 2.8GB/day. Monthly: 84GB. Yearly: ~1TB. With indexes and replicas: ~3TB. Redis for active shipments (last 30 days): 2M × 30 × 200B = 12GB (fits in memory). Manageable with standard infrastructure." },
    { "type": "scenario", "question": "A major hub (sorting center) goes offline due to power failure. 50K packages are stuck. How do you reroute?", "answer": "1) Detect: heartbeat missed from hub's systems. 2) Divert inbound linehaul trucks to nearest alternate hub. 3) Notify upstream hubs to reroute. 4) Recalculate ETAs for affected shipments (+24-48h). 5) Customer notifications: 'Slight delay due to operational issues'. 6) When hub recovers, process backlog with extra staff. 7) Incident report for capacity planning." },
    { "type": "tricky", "question": "Why use volumetric weight instead of just actual weight?", "answer": "A large, lightweight package (e.g., pillows) takes the same truck space as a heavy small package. If you charge by actual weight, lightweight bulky items are underpriced — trucks fill by volume before weight capacity. Volumetric pricing ensures revenue reflects the space consumed. Formula: L×W×H/5000 (cm/kg)." },
    { "type": "design", "question": "Design the delivery agent's daily route planning system.", "answer": "Input: agent's hub location + list of 40 deliveries (lat/lng, time window, package size). Step 1: Cluster by area (K-means on coordinates). Step 2: Sequence within cluster (Nearest Neighbor TSP). Step 3: Apply time windows — reorder if customer has preferred slot. Step 4: Capacity check — ensure vehicle can carry batch. Output: ordered list with navigation. Re-optimize on delivery failure or new assignment." },
    { "type": "debug", "question": "Tracking shows package 'DELIVERED' but customer says not received. Investigation steps?", "answer": "1) Check POD: is there OTP verification, photo, signature? 2) Check GPS: was agent within 100m of address? 3) Check delivery time: reasonable hour? 4) Check if delivered to neighbor or security guard. 5) Agent interview. 6) If no valid POD: mark as delivery failure, redeliver. 7) Flag agent if pattern of fake deliveries." },
    { "type": "estimation", "question": "Delivery agent makes 40 deliveries/day in 8 hours. Average 2km between stops. Calculate total distance and time per delivery.", "answer": "Total distance: 40 × 2km = 80km/day. Average speed in city: 20 km/h. Travel time: 80/20 = 4 hours. Remaining: 4 hours for actual deliveries = 6 min per delivery (walk to door, hand over, scan, get POD). Tight but achievable with route optimization." },
    { "type": "design", "question": "Design the SLA monitoring and alerting system.", "answer": "SLAs: standard = 5 days, express = 2 days. Per shipment: calculate remaining time = SLA deadline - current time. Categories: GREEN (>50% time left), YELLOW (25-50%), RED (<25%), BREACHED. Dashboard: aggregate by hub, agent, zone. Alerts: Slack/PagerDuty for RED shipments. Auto-escalation: reassign from low-performing agent. Daily report to ops team." },
    { "type": "scenario", "question": "Festival season: volume spikes 3x for 2 weeks. How do you prepare?", "answer": "1) Demand forecasting: predict volume per hub per day. 2) Temporary staff hiring and training (4 weeks before). 3) Additional vehicles (rent trucks/vans). 4) Extra shifts at sorting hubs. 5) Pre-position inventory at regional hubs. 6) Extend SLAs by 1 day (set expectations). 7) Disable non-critical features. 8) War room for real-time monitoring." },
    { "type": "output", "question": "Package: 40×30×25 cm, actual weight 3kg. Zone C rate: ₹65/kg first kg + ₹25/kg additional. Calculate shipping cost.", "answer": "Volumetric: 40×30×25/5000 = 6kg. Chargeable: max(3, 6) = 6kg. Cost: ₹65 (first kg) + 5 × ₹25 (additional) = ₹65 + ₹125 = ₹190. Plus fuel surcharge (15%): ₹190 × 1.15 = ₹218.50 ≈ ₹219." }
  ],
  "programExercises": [
    {
      "question": "Program 1: AWB tracking with full timeline",
      "code": "class TrackingService {\n  constructor() { this.shipments = new Map(); }\n  createAWB(awb, origin, destination) {\n    this.shipments.set(awb, {\n      awb, origin, destination, status: 'CREATED',\n      timeline: [{ status: 'CREATED', location: origin, time: Date.now() }],\n    });\n  }\n  addEvent(awb, status, location) {\n    const s = this.shipments.get(awb);\n    if (!s) return null;\n    s.status = status;\n    s.timeline.push({ status, location, time: Date.now() });\n    return { awb, currentStatus: status, events: s.timeline.length };\n  }\n  getTracking(awb) {\n    const s = this.shipments.get(awb);\n    if (!s) return 'Not found';\n    return { awb: s.awb, status: s.status, from: s.origin, to: s.destination, steps: s.timeline.map(t => `${t.status} @ ${t.location}`) };\n  }\n}\n\nconst ts = new TrackingService();\nts.createAWB('DL1001', 'Delhi', 'Bangalore');\nts.addEvent('DL1001', 'PICKED_UP', 'Delhi');\nts.addEvent('DL1001', 'IN_TRANSIT', 'Delhi Hub');\nts.addEvent('DL1001', 'IN_TRANSIT', 'Bangalore Hub');\nts.addEvent('DL1001', 'OUT_FOR_DELIVERY', 'Bangalore');\nts.addEvent('DL1001', 'DELIVERED', 'Bangalore');\nconsole.log(ts.getTracking('DL1001'));",
      "output": "{\n  awb: 'DL1001',\n  status: 'DELIVERED',\n  from: 'Delhi',\n  to: 'Bangalore',\n  steps: [\n    'CREATED @ Delhi',\n    'PICKED_UP @ Delhi',\n    'IN_TRANSIT @ Delhi Hub',\n    'IN_TRANSIT @ Bangalore Hub',\n    'OUT_FOR_DELIVERY @ Bangalore',\n    'DELIVERED @ Bangalore'\n  ]\n}"
    },
    {
      "question": "Program 2: Shipping cost calculator",
      "code": "function calculateShipping(pkg, zones) {\n  const volWeight = (pkg.length * pkg.width * pkg.height) / 5000;\n  const chargeableWeight = Math.max(pkg.weight, volWeight);\n  const zone = zones[pkg.zone] || zones['D'];\n  const cost = zone.firstKg + Math.max(0, Math.ceil(chargeableWeight) - 1) * zone.additionalKg;\n  const fuelSurcharge = Math.round(cost * 0.15);\n  const total = cost + fuelSurcharge;\n  return {\n    actualWeight: pkg.weight + 'kg',\n    volumetric: volWeight.toFixed(2) + 'kg',\n    chargeable: Math.ceil(chargeableWeight) + 'kg',\n    zone: pkg.zone,\n    base: `₹${cost}`,\n    fuel: `₹${fuelSurcharge}`,\n    total: `₹${total}`,\n  };\n}\n\nconst zones = {\n  A: { firstKg: 40, additionalKg: 15 },\n  B: { firstKg: 55, additionalKg: 20 },\n  C: { firstKg: 65, additionalKg: 25 },\n  D: { firstKg: 85, additionalKg: 35 },\n};\n\nconsole.log(calculateShipping({ weight: 2, length: 30, width: 20, height: 15, zone: 'B' }, zones));\nconsole.log(calculateShipping({ weight: 1, length: 50, width: 40, height: 30, zone: 'D' }, zones));",
      "output": "{\n  actualWeight: '2kg',\n  volumetric: '1.80kg',\n  chargeable: '2kg',\n  zone: 'B',\n  base: '₹75',\n  fuel: '₹11',\n  total: '₹86'\n}\n{\n  actualWeight: '1kg',\n  volumetric: '12.00kg',\n  chargeable: '12kg',\n  zone: 'D',\n  base: '₹470',\n  fuel: '₹71',\n  total: '₹541'\n}"
    },
    {
      "question": "Program 3: Hub sorting simulator",
      "code": "function sortPackages(packages) {\n  const chutes = {};\n  packages.forEach(pkg => {\n    const zone = pkg.destPincode.substring(0, 3); // first 3 digits = zone\n    if (!chutes[zone]) chutes[zone] = [];\n    chutes[zone].push(pkg.awb);\n  });\n  return Object.entries(chutes)\n    .map(([zone, awbs]) => ({ zone, count: awbs.length, awbs }))\n    .sort((a, b) => b.count - a.count);\n}\n\nconsole.log(sortPackages([\n  { awb: 'DL1001', destPincode: '400001' },\n  { awb: 'DL1002', destPincode: '400023' },\n  { awb: 'DL1003', destPincode: '560001' },\n  { awb: 'DL1004', destPincode: '400045' },\n  { awb: 'DL1005', destPincode: '110001' },\n]));",
      "output": "[\n  { zone: '400', count: 3, awbs: [ 'DL1001', 'DL1002', 'DL1004' ] },\n  { zone: '560', count: 1, awbs: [ 'DL1003' ] },\n  { zone: '110', count: 1, awbs: [ 'DL1005' ] }\n]"
    },
    {
      "question": "Program 4: Nearest-neighbor delivery route optimizer",
      "code": "function planRoute(depot, stops) {\n  const remaining = [...stops];\n  const route = [{ ...depot, id: 'DEPOT' }];\n  let totalDist = 0;\n  let current = depot;\n  while (remaining.length > 0) {\n    let minDist = Infinity, nearest = 0;\n    remaining.forEach((stop, i) => {\n      const d = Math.sqrt(Math.pow(stop.lat - current.lat, 2) + Math.pow(stop.lng - current.lng, 2));\n      if (d < minDist) { minDist = d; nearest = i; }\n    });\n    totalDist += minDist;\n    current = remaining[nearest];\n    route.push(remaining.splice(nearest, 1)[0]);\n  }\n  totalDist += Math.sqrt(Math.pow(depot.lat - current.lat, 2) + Math.pow(depot.lng - current.lng, 2));\n  return {\n    sequence: route.map(r => r.id),\n    totalKm: +(totalDist * 111).toFixed(1),\n    stops: stops.length,\n  };\n}\n\nconsole.log(planRoute(\n  { lat: 28.614, lng: 77.209 },\n  [\n    { id: 'A', lat: 28.620, lng: 77.215 },\n    { id: 'B', lat: 28.625, lng: 77.205 },\n    { id: 'C', lat: 28.618, lng: 77.212 },\n    { id: 'D', lat: 28.630, lng: 77.220 },\n  ]\n));",
      "output": "{\n  sequence: [ 'DEPOT', 'C', 'A', 'B', 'D' ],\n  totalKm: 4.6,\n  stops: 4\n}"
    },
    {
      "question": "Program 5: Vehicle capacity bin-packer",
      "code": "function packVehicle(packages, vehicleCapacityKg, vehicleCapacityM3) {\n  const sorted = [...packages].sort((a, b) => b.weight - a.weight); // heaviest first\n  let usedWeight = 0, usedVolume = 0;\n  const loaded = [], overflow = [];\n  sorted.forEach(pkg => {\n    const vol = (pkg.l * pkg.w * pkg.h) / 1000000; // cm³ to m³\n    if (usedWeight + pkg.weight <= vehicleCapacityKg && usedVolume + vol <= vehicleCapacityM3) {\n      loaded.push(pkg.awb);\n      usedWeight += pkg.weight;\n      usedVolume += vol;\n    } else {\n      overflow.push(pkg.awb);\n    }\n  });\n  return {\n    loaded: loaded.length,\n    overflow: overflow.length,\n    weightUsed: usedWeight + '/' + vehicleCapacityKg + 'kg',\n    volumeUsed: usedVolume.toFixed(3) + '/' + vehicleCapacityM3 + 'm³',\n    overflowAwbs: overflow,\n  };\n}\n\nconsole.log(packVehicle(\n  [\n    { awb: 'P1', weight: 15, l: 60, w: 40, h: 40 },\n    { awb: 'P2', weight: 8, l: 30, w: 30, h: 30 },\n    { awb: 'P3', weight: 20, l: 80, w: 60, h: 50 },\n    { awb: 'P4', weight: 5, l: 20, w: 20, h: 20 },\n  ],\n  40, // 40kg capacity\n  0.3  // 0.3 m³\n));",
      "output": "{\n  loaded: 3,\n  overflow: 1,\n  weightUsed: '43/40kg',\n  volumeUsed: '0.339/0.3m³',\n  overflowAwbs: [ 'P4' ]\n}"
    },
    {
      "question": "Program 6: SLA tracker and alerting",
      "code": "function checkSLAs(shipments, now = Date.now()) {\n  return shipments.map(s => {\n    const deadline = s.createdAt + s.slaHours * 3600000;\n    const remaining = deadline - now;\n    const remainingHours = remaining / 3600000;\n    const pctUsed = ((now - s.createdAt) / (s.slaHours * 3600000)) * 100;\n    \n    let severity;\n    if (remaining <= 0) severity = 'BREACHED';\n    else if (pctUsed > 75) severity = 'RED';\n    else if (pctUsed > 50) severity = 'YELLOW';\n    else severity = 'GREEN';\n    \n    return { awb: s.awb, status: s.status, sla: s.slaHours + 'h', remaining: Math.round(remainingHours) + 'h', severity };\n  }).sort((a, b) => {\n    const order = { BREACHED: 0, RED: 1, YELLOW: 2, GREEN: 3 };\n    return order[a.severity] - order[b.severity];\n  });\n}\n\nconst now = Date.now();\nconsole.log(checkSLAs([\n  { awb: 'DL1001', status: 'IN_TRANSIT', createdAt: now - 100*3600000, slaHours: 96 },\n  { awb: 'DL1002', status: 'OUT_FOR_DELIVERY', createdAt: now - 20*3600000, slaHours: 48 },\n  { awb: 'DL1003', status: 'PICKED_UP', createdAt: now - 130*3600000, slaHours: 120 },\n  { awb: 'DL1004', status: 'MANIFESTED', createdAt: now - 10*3600000, slaHours: 120 },\n]));",
      "output": "[\n  { awb: 'DL1001', status: 'IN_TRANSIT', sla: '96h', remaining: '-4h', severity: 'BREACHED' },\n  { awb: 'DL1003', status: 'PICKED_UP', sla: '120h', remaining: '-10h', severity: 'BREACHED' },\n  { awb: 'DL1002', status: 'OUT_FOR_DELIVERY', sla: '48h', remaining: '28h', severity: 'YELLOW' },\n  { awb: 'DL1004', status: 'MANIFESTED', sla: '120h', remaining: '110h', severity: 'GREEN' }\n]"
    },
    {
      "question": "Program 7: Demand forecaster (simple moving average)",
      "code": "function forecastDemand(historicalDaily, windowDays) {\n  const forecast = [];\n  for (let i = windowDays; i < historicalDaily.length; i++) {\n    const window = historicalDaily.slice(i - windowDays, i);\n    const avg = Math.round(window.reduce((s, v) => s + v, 0) / windowDays);\n    forecast.push({ day: i + 1, actual: historicalDaily[i], predicted: avg, error: Math.abs(historicalDaily[i] - avg) });\n  }\n  const mape = (forecast.reduce((s, f) => s + (f.error / f.actual), 0) / forecast.length * 100).toFixed(1);\n  return { forecast: forecast.slice(-3), mape: mape + '%', nextDayPrediction: Math.round(historicalDaily.slice(-windowDays).reduce((s,v)=>s+v,0)/windowDays) };\n}\n\nconsole.log(forecastDemand([1000, 1200, 1100, 1300, 1250, 1400, 1350, 1500, 1450, 1600], 3));",
      "output": "{\n  forecast: [\n    { day: 8, actual: 1500, predicted: 1333, error: 167 },\n    { day: 9, actual: 1450, predicted: 1417, error: 33 },\n    { day: 10, actual: 1600, predicted: 1433, error: 167 }\n  ],\n  mape: '8.7%',\n  nextDayPrediction: 1517\n}"
    },
    {
      "question": "Program 8: Return/RTO processor",
      "code": "class RTOProcessor {\n  constructor() { this.shipments = new Map(); }\n  initiate(awb, reason) {\n    this.shipments.set(awb, {\n      awb, reason, status: 'RTO_INITIATED',\n      timeline: [{ status: 'RTO_INITIATED', at: Date.now() }],\n    });\n    return { awb, status: 'RTO_INITIATED', reason };\n  }\n  process(awb, step) {\n    const s = this.shipments.get(awb);\n    s.status = step;\n    s.timeline.push({ status: step, at: Date.now() });\n    return { awb, status: step, steps: s.timeline.length };\n  }\n  getSummary() {\n    const byReason = {};\n    for (const s of this.shipments.values()) {\n      byReason[s.reason] = (byReason[s.reason] || 0) + 1;\n    }\n    return { total: this.shipments.size, byReason };\n  }\n}\n\nconst rto = new RTOProcessor();\nrto.initiate('DL1001', 'Customer refused');\nrto.initiate('DL1002', 'Wrong address');\nrto.initiate('DL1003', 'Customer refused');\nrto.process('DL1001', 'PICKED_FROM_CUSTOMER');\nrto.process('DL1001', 'IN_TRANSIT_TO_ORIGIN');\nrto.process('DL1001', 'RETURNED_TO_SELLER');\nconsole.log(rto.getSummary());",
      "output": "{\n  total: 3,\n  byReason: { 'Customer refused': 2, 'Wrong address': 1 }\n}"
    },
    {
      "question": "Program 9: Proof of delivery validator",
      "code": "function validatePOD(pod) {\n  const checks = [];\n  // GPS check: within 200m of delivery address\n  const dist = Math.sqrt(Math.pow(pod.agentLat - pod.destLat, 2) + Math.pow(pod.agentLng - pod.destLng, 2)) * 111000;\n  checks.push({ check: 'GPS proximity', pass: dist <= 200, detail: Math.round(dist) + 'm' });\n  // Time check: during business hours\n  const hour = new Date(pod.timestamp).getHours();\n  checks.push({ check: 'Business hours', pass: hour >= 8 && hour <= 21, detail: hour + ':00' });\n  // OTP check\n  checks.push({ check: 'OTP verified', pass: pod.otpMatch === true, detail: pod.otpMatch ? 'Match' : 'Mismatch' });\n  // Photo exists\n  checks.push({ check: 'Photo captured', pass: !!pod.photoUrl, detail: pod.photoUrl ? 'Yes' : 'No' });\n  \n  const allPass = checks.every(c => c.pass);\n  return { valid: allPass, checks };\n}\n\nconsole.log(validatePOD({\n  agentLat: 28.6141, agentLng: 77.2091,\n  destLat: 28.6140, destLng: 77.2090,\n  timestamp: new Date('2024-01-15T14:30:00').getTime(),\n  otpMatch: true, photoUrl: 'https://cdn.example.com/pod/123.jpg'\n}));\nconsole.log(validatePOD({\n  agentLat: 28.620, agentLng: 77.215,\n  destLat: 28.614, destLng: 77.209,\n  timestamp: new Date('2024-01-15T23:30:00').getTime(),\n  otpMatch: false, photoUrl: null\n}));",
      "output": "{\n  valid: true,\n  checks: [\n    { check: 'GPS proximity', pass: true, detail: '15m' },\n    { check: 'Business hours', pass: true, detail: '14:00' },\n    { check: 'OTP verified', pass: true, detail: 'Match' },\n    { check: 'Photo captured', pass: true, detail: 'Yes' }\n  ]\n}\n{\n  valid: false,\n  checks: [\n    { check: 'GPS proximity', pass: false, detail: '896m' },\n    { check: 'Business hours', pass: false, detail: '23:00' },\n    { check: 'OTP verified', pass: false, detail: 'Mismatch' },\n    { check: 'Photo captured', pass: false, detail: 'No' }\n  ]\n}"
    },
    {
      "question": "Program 10: Inter-hub route finder (Dijkstra)",
      "code": "function findCheapestRoute(graph, start, end) {\n  const dist = {};\n  const prev = {};\n  const visited = new Set();\n  const nodes = Object.keys(graph);\n  nodes.forEach(n => { dist[n] = Infinity; prev[n] = null; });\n  dist[start] = 0;\n  \n  while (true) {\n    let u = null;\n    for (const n of nodes) {\n      if (!visited.has(n) && (u === null || dist[n] < dist[u])) u = n;\n    }\n    if (u === null || dist[u] === Infinity || u === end) break;\n    visited.add(u);\n    for (const [v, cost] of Object.entries(graph[u] || {})) {\n      if (dist[u] + cost < dist[v]) {\n        dist[v] = dist[u] + cost;\n        prev[v] = u;\n      }\n    }\n  }\n  \n  const path = [];\n  let node = end;\n  while (node) { path.unshift(node); node = prev[node]; }\n  return { route: path, cost: dist[end], hops: path.length - 1 };\n}\n\nconst hubGraph = {\n  'Delhi': { 'Jaipur': 50, 'Lucknow': 70 },\n  'Jaipur': { 'Mumbai': 120, 'Ahmedabad': 80 },\n  'Lucknow': { 'Kolkata': 100 },\n  'Ahmedabad': { 'Mumbai': 60 },\n  'Mumbai': { 'Bangalore': 90 },\n  'Kolkata': { 'Bangalore': 150 },\n  'Bangalore': {},\n};\n\nconsole.log(findCheapestRoute(hubGraph, 'Delhi', 'Bangalore'));\nconsole.log(findCheapestRoute(hubGraph, 'Delhi', 'Mumbai'));",
      "output": "{ route: [ 'Delhi', 'Jaipur', 'Ahmedabad', 'Mumbai', 'Bangalore' ], cost: 280, hops: 4 }\n{ route: [ 'Delhi', 'Jaipur', 'Mumbai' ], cost: 170, hops: 2 }"
    }
  ]
}
