{
  "id": "netflix-lld",
  "title": "Netflix: Playback & Streaming",
  "category": "Company LLD",
  "description": "Low-level design of playback authorization, adaptive bitrate streaming, and segment delivery via CDN.",
  "explanation": "Netflix serves 200M+ subscribers streaming video across diverse devices and networks. The core playback path involves multiple subsystems working together to deliver seamless viewing.\n\nPlayback flow:\n1. User clicks play → Client sends playback request with device info, content ID, user token.\n2. Entitlement service validates subscription, geo-restrictions, device limits, and parental controls.\n3. Playback session is created with a signed, short-lived token bound to the device.\n4. Manifest builder generates an adaptive bitrate manifest (DASH/HLS) with URLs for each rendition (quality level).\n5. Client fetches video segments from the nearest CDN edge (Open Connect Appliance).\n6. ABR algorithm on the client selects the best rendition based on throughput and buffer level.\n\nAdaptive Bitrate (ABR) state machine:\n- Measures download throughput for each segment.\n- Monitors playback buffer level (seconds of video buffered).\n- If throughput drops or buffer is low → step down to lower bitrate.\n- If throughput is high and buffer is healthy → step up gradually.\n- Guardrails prevent rapid oscillation between quality levels.\n\nQuality of Experience (QoE) metrics:\n- Startup delay: Time from click to first frame.\n- Rebuffer ratio: % of playback time spent buffering.\n- Bitrate stability: Frequency of quality switches.\n- Playback failure rate: Sessions that fail to start or crash.\n\nCDN architecture: Netflix uses Open Connect — custom CDN appliances placed in ISP networks. Content is pre-positioned during off-peak hours. Cache miss goes to regional hub, then origin. This reduces internet backbone traffic by 95%.",
  "code": "// Playback session state machine\nclass PlaybackSession {\n  constructor(userId, contentId, deviceId) {\n    this.userId = userId;\n    this.contentId = contentId;\n    this.deviceId = deviceId;\n    this.state = 'INIT';\n    this.token = null;\n    this.startTime = Date.now();\n    this.transitions = [];\n  }\n\n  transition(newState) {\n    const allowed = {\n      'INIT': ['AUTHORIZED', 'DENIED'],\n      'AUTHORIZED': ['PLAYING', 'ERROR'],\n      'PLAYING': ['PAUSED', 'BUFFERING', 'ENDED', 'ERROR'],\n      'PAUSED': ['PLAYING', 'ENDED'],\n      'BUFFERING': ['PLAYING', 'ERROR'],\n      'DENIED': [],\n      'ENDED': [],\n      'ERROR': ['INIT'], // retry\n    };\n    if (!allowed[this.state]?.includes(newState)) {\n      throw new Error(`Invalid transition: ${this.state} → ${newState}`);\n    }\n    this.transitions.push({ from: this.state, to: newState, at: Date.now() });\n    this.state = newState;\n    return this.state;\n  }\n\n  authorize(token) {\n    this.token = token;\n    this.transition('AUTHORIZED');\n  }\n\n  getQoE() {\n    return {\n      startupDelayMs: this.transitions.find(t => t.to === 'PLAYING')?.at - this.startTime || null,\n      totalTransitions: this.transitions.length,\n      bufferingEvents: this.transitions.filter(t => t.to === 'BUFFERING').length,\n    };\n  }\n}\n\nconst session = new PlaybackSession('user1', 'movie123', 'device_tv');\nsession.authorize('token_abc');\nsession.transition('PLAYING');\nsession.transition('BUFFERING');\nsession.transition('PLAYING');\nsession.transition('ENDED');\nconsole.log('State:', session.state);\nconsole.log('QoE:', session.getQoE());",
  "example": "// ABR (Adaptive Bitrate) algorithm simulation\nclass ABRController {\n  constructor(renditions) {\n    this.renditions = renditions.sort((a, b) => a.bitrate - b.bitrate);\n    this.currentIndex = 0; // start lowest\n    this.history = [];\n  }\n\n  selectRendition(throughputKbps, bufferSeconds) {\n    let selected = 0;\n    // Find highest rendition that fits in 80% of throughput (safety margin)\n    for (let i = this.renditions.length - 1; i >= 0; i--) {\n      if (this.renditions[i].bitrate <= throughputKbps * 0.8) {\n        selected = i;\n        break;\n      }\n    }\n    // Buffer-based guardrail\n    if (bufferSeconds < 5) selected = Math.min(selected, this.currentIndex); // don't go up\n    if (bufferSeconds < 2) selected = Math.max(0, this.currentIndex - 1); // force step down\n    // Anti-oscillation: max 1 step up at a time\n    if (selected > this.currentIndex + 1) selected = this.currentIndex + 1;\n\n    this.currentIndex = selected;\n    this.history.push({ bitrate: this.renditions[selected].bitrate, buffer: bufferSeconds });\n    return this.renditions[selected];\n  }\n}\n\nconst abr = new ABRController([\n  { bitrate: 500, label: '360p' },\n  { bitrate: 1500, label: '720p' },\n  { bitrate: 4000, label: '1080p' },\n  { bitrate: 8000, label: '4K' },\n]);\nconsole.log(abr.selectRendition(6000, 10)); // 1080p\nconsole.log(abr.selectRendition(2000, 8));  // 720p\nconsole.log(abr.selectRendition(1000, 1));  // 360p (buffer critical)",
  "useCase": "Video streaming platforms, live streaming, any adaptive media delivery system.",
  "interviewQuestions": [
    { "question": "How do you reduce playback startup time?", "answer": "Precomputed manifests cached at edge, start with lowest bitrate for first segments, prefetch initial segments based on user behavior prediction, minimize control-plane round trips by batching auth + manifest in one call." },
    { "question": "How do you prevent token sharing or credential abuse?", "answer": "Short-lived signed tokens bound to device ID and IP range. Concurrent stream limits per account. Anomaly detection on viewing patterns (simultaneous streams from different geos). Device registration caps." },
    { "question": "What metrics define Quality of Experience (QoE)?", "answer": "Startup delay (time to first frame), rebuffer ratio (buffering time / total play time), bitrate stability (switches per minute), playback failure rate, and video quality score. These are tracked per session and aggregated per device type." },
    { "question": "How does adaptive bitrate streaming work?", "answer": "Client measures download throughput and buffer level per segment. ABR algorithm selects the best rendition: high throughput + full buffer = step up quality; low throughput or low buffer = step down. Guardrails prevent oscillation." },
    { "question": "How does Netflix handle CDN architecture?", "answer": "Open Connect: custom appliances placed inside ISP networks. Content pre-positioned during off-peak hours. Hierarchy: ISP appliance → regional hub → origin S3. 95% of traffic served from within the ISP network." },
    { "question": "What happens if the nearest CDN edge doesn't have the content?", "answer": "Cache miss cascades: edge → shield/regional hub → origin. Client is redirected to the next closest edge that has the content. Popular content is replicated proactively. Long-tail content may stream from origin with higher latency." },
    { "question": "How do you handle live streaming vs on-demand differently?", "answer": "Live: segments generated in real-time, no pre-positioning, ultra-low latency requirements, smaller segment duration (2-4s vs 6-10s). Manifest is dynamic (sliding window). CDN must handle thundering herd at segment boundaries." },
    { "question": "How do you design the entitlement check to be fast?", "answer": "Cache active subscription status in Redis with short TTL. Pre-compute content availability per region. Use a lightweight token claim check before hitting the entitlement service. Target: <20ms for entitlement validation." },
    { "question": "What is DRM and how does it integrate with playback?", "answer": "Digital Rights Management encrypts video content. Client obtains a license key during playback init. The key is tied to device and session. Common systems: Widevine (Android/Chrome), FairPlay (Apple), PlayReady (Microsoft). License server is in the critical playback path." },
    { "question": "How would you design A/B testing for the ABR algorithm?", "answer": "Assign users to experiment groups. Each group uses a different ABR policy. Measure QoE metrics per group (startup delay, rebuffer ratio, bitrate). Use statistical significance tests. Ensure balanced device/network distribution across groups." }
  ],
  "exercises": [
    { "type": "design", "question": "Design the ABR switching logic with guardrails against quality oscillation.", "answer": "Rules: 1) Max 1 step up per segment. 2) Require 3 consecutive high-throughput segments before stepping up. 3) Step down immediately on buffer < 3s. 4) Hysteresis: don't switch if throughput is within 20% of current rendition. 5) Minimum dwell time of 30s at a rendition." },
    { "type": "scenario", "question": "CDN edge miss spikes after a new release. Origin load increases 10x. What steps reduce origin overload?", "answer": "1) Pre-warm CDN edges with popular content before release. 2) Shield layer absorbs repeated origin fetches. 3) Rate limit origin pull requests. 4) Serve lower renditions first (smaller files, faster cache fill). 5) Stagger content availability by region." },
    { "type": "output", "question": "Given buffer=2s and throughput drop of 40% from 4Mbps to 2.4Mbps, current rendition is 1080p (4Mbps). What ABR action?", "answer": "2.4Mbps × 0.8 safety = 1.92Mbps < 4Mbps (1080p) AND buffer < 5s. Step down immediately to 720p (1.5Mbps). If buffer < 2s, may step down to 360p (500Kbps) to protect continuity." },
    { "type": "estimation", "question": "Netflix has 200M subscribers, 10% watching at peak. Average bitrate 5Mbps. Estimate peak bandwidth.", "answer": "Concurrent viewers: 200M × 0.1 = 20M. Bandwidth: 20M × 5Mbps = 100Tbps. With CDN serving 95% from edge: origin bandwidth = 5Tbps." },
    { "type": "debug", "question": "Users report increased buffering after a deployment. Playback failure rate is normal. What do you investigate?", "answer": "1) Check if ABR algorithm change is causing wrong rendition selection. 2) Check CDN cache hit rates (did deployment bust caches?). 3) Check segment generation latency. 4) Check if manifest URLs changed. 5) Check client-side bugs in buffer management." },
    { "type": "design", "question": "Design a concurrent stream limiter that allows max 4 simultaneous streams per account.", "answer": "Redis sorted set per account_id. Key: ZSET(account:streams). Members: session_id with score=timestamp. On play: ZADD + ZCARD. If ZCARD > 4, reject. On stop/timeout: ZREM. Expire stale sessions with periodic cleanup (score < now - 30min)." },
    { "type": "tricky", "question": "How do you handle network switches (WiFi→cellular) during playback without interruption?", "answer": "Client detects network change, re-evaluates throughput (start conservative), ABR drops to lower bitrate temporarily, buffer absorbs the transition. Maintain session continuity — don't re-authenticate. Resume from current playback position." },
    { "type": "scenario", "question": "A popular show launches globally at midnight. How do you prepare the infrastructure?", "answer": "1) Pre-encode all renditions + languages in advance. 2) Pre-warm CDN edges in all regions. 3) Scale entitlement and session services 3x. 4) Enable circuit breakers on non-critical services. 5) War room with real-time QoE dashboards." },
    { "type": "estimation", "question": "A 2-hour movie at 4K (15Mbps) — how much storage per movie for 5 renditions?", "answer": "4K: 15Mbps × 7200s / 8 = 13.5GB. 1080p: ~4.5GB. 720p: ~1.35GB. 480p: ~0.675GB. 360p: ~0.45GB. Total: ~20.4GB per movie. 10,000 titles = ~204TB." },
    { "type": "design", "question": "Design the telemetry pipeline for collecting playback QoE events.", "answer": "Client sends heartbeat events every 30s + on state changes. Events: {session_id, bitrate, buffer_level, rebuffer_count, device_type}. Pipeline: Client → API Gateway → Kafka → Flink (real-time aggregation) → S3 (raw) + Druid (dashboards). Alert on p99 rebuffer ratio > 2%." }
  ],
  "programExercises": [
    {
      "question": "Program 1: Playback state machine with transition validation",
      "code": "class PlaybackFSM {\n  constructor() {\n    this.state = 'INIT';\n    this.allowed = {\n      INIT: ['AUTHORIZED', 'DENIED'],\n      AUTHORIZED: ['PLAYING', 'ERROR'],\n      PLAYING: ['PAUSED', 'BUFFERING', 'ENDED', 'ERROR'],\n      PAUSED: ['PLAYING', 'ENDED'],\n      BUFFERING: ['PLAYING', 'ERROR'],\n      DENIED: [],\n      ENDED: [],\n      ERROR: ['INIT'],\n    };\n    this.log = [];\n  }\n  transition(to) {\n    if (!this.allowed[this.state]?.includes(to)) {\n      this.log.push(`REJECTED: ${this.state} → ${to}`);\n      return false;\n    }\n    this.log.push(`${this.state} → ${to}`);\n    this.state = to;\n    return true;\n  }\n}\n\nconst fsm = new PlaybackFSM();\nfsm.transition('AUTHORIZED');\nfsm.transition('PLAYING');\nfsm.transition('BUFFERING');\nfsm.transition('PLAYING');\nfsm.transition('ENDED');\nfsm.transition('PLAYING'); // invalid\nconsole.log(fsm.log);",
      "output": "[\n  'INIT → AUTHORIZED',\n  'AUTHORIZED → PLAYING',\n  'PLAYING → BUFFERING',\n  'BUFFERING → PLAYING',\n  'PLAYING → ENDED',\n  'REJECTED: ENDED → PLAYING'\n]"
    },
    {
      "question": "Program 2: ABR rendition selector",
      "code": "function selectRendition(renditions, throughputKbps, bufferSec) {\n  const sorted = [...renditions].sort((a, b) => b.bitrate - a.bitrate);\n  const safe = throughputKbps * 0.8;\n  for (const r of sorted) {\n    if (r.bitrate <= safe) {\n      if (bufferSec < 3 && r.bitrate > 1000) continue;\n      return r;\n    }\n  }\n  return sorted[sorted.length - 1];\n}\n\nconst renditions = [\n  { label: '360p', bitrate: 500 },\n  { label: '720p', bitrate: 1500 },\n  { label: '1080p', bitrate: 4000 },\n  { label: '4K', bitrate: 8000 },\n];\nconsole.log(selectRendition(renditions, 6000, 15)); // 1080p\nconsole.log(selectRendition(renditions, 2000, 10)); // 720p\nconsole.log(selectRendition(renditions, 3000, 2));  // 360p (low buffer)",
      "output": "{ label: '1080p', bitrate: 4000 }\n{ label: '720p', bitrate: 1500 }\n{ label: '360p', bitrate: 500 }"
    },
    {
      "question": "Program 3: Concurrent stream limiter",
      "code": "class StreamLimiter {\n  constructor(maxStreams) {\n    this.maxStreams = maxStreams;\n    this.accounts = new Map();\n  }\n  startStream(accountId, sessionId) {\n    if (!this.accounts.has(accountId)) this.accounts.set(accountId, new Set());\n    const sessions = this.accounts.get(accountId);\n    if (sessions.size >= this.maxStreams) {\n      return { allowed: false, active: sessions.size, message: `Max ${this.maxStreams} streams reached` };\n    }\n    sessions.add(sessionId);\n    return { allowed: true, active: sessions.size };\n  }\n  stopStream(accountId, sessionId) {\n    this.accounts.get(accountId)?.delete(sessionId);\n  }\n}\n\nconst limiter = new StreamLimiter(2);\nconsole.log(limiter.startStream('acc1', 'tv'));\nconsole.log(limiter.startStream('acc1', 'phone'));\nconsole.log(limiter.startStream('acc1', 'tablet')); // rejected\nlimiter.stopStream('acc1', 'tv');\nconsole.log(limiter.startStream('acc1', 'tablet')); // now OK",
      "output": "{ allowed: true, active: 1 }\n{ allowed: true, active: 2 }\n{ allowed: false, active: 2, message: 'Max 2 streams reached' }\n{ allowed: true, active: 2 }"
    },
    {
      "question": "Program 4: CDN edge cache simulator",
      "code": "class CDNEdge {\n  constructor(name, capacity) {\n    this.name = name;\n    this.cache = new Map();\n    this.capacity = capacity;\n    this.hits = 0;\n    this.misses = 0;\n  }\n  get(contentId) {\n    if (this.cache.has(contentId)) {\n      this.hits++;\n      return { source: this.name, hit: true };\n    }\n    this.misses++;\n    return { source: this.name, hit: false };\n  }\n  store(contentId) {\n    if (this.cache.size >= this.capacity) {\n      const oldest = this.cache.keys().next().value;\n      this.cache.delete(oldest);\n    }\n    this.cache.set(contentId, true);\n  }\n  stats() {\n    const total = this.hits + this.misses;\n    return { name: this.name, hitRate: total ? (this.hits/total*100).toFixed(1)+'%' : 'N/A', size: this.cache.size };\n  }\n}\n\nconst edge = new CDNEdge('us-east-1', 3);\nedge.store('movie-1'); edge.store('movie-2');\nconsole.log(edge.get('movie-1')); // hit\nconsole.log(edge.get('movie-3')); // miss\nedge.store('movie-3');\nconsole.log(edge.get('movie-3')); // hit\nconsole.log(edge.stats());",
      "output": "{ source: 'us-east-1', hit: true }\n{ source: 'us-east-1', hit: false }\n{ source: 'us-east-1', hit: true }\n{ name: 'us-east-1', hitRate: '66.7%', size: 3 }"
    },
    {
      "question": "Program 5: QoE metrics aggregator",
      "code": "function aggregateQoE(sessions) {\n  const metrics = {\n    avgStartupMs: 0, avgRebufferRatio: 0,\n    avgBitrate: 0, failureRate: 0,\n  };\n  const valid = sessions.filter(s => s.state !== 'FAILED');\n  const failed = sessions.filter(s => s.state === 'FAILED');\n  metrics.failureRate = (failed.length / sessions.length * 100).toFixed(2) + '%';\n  metrics.avgStartupMs = Math.round(valid.reduce((s, v) => s + v.startupMs, 0) / valid.length);\n  metrics.avgRebufferRatio = (valid.reduce((s, v) => s + v.rebufferRatio, 0) / valid.length * 100).toFixed(2) + '%';\n  metrics.avgBitrate = Math.round(valid.reduce((s, v) => s + v.avgBitrate, 0) / valid.length);\n  return metrics;\n}\n\nconsole.log(aggregateQoE([\n  { state: 'ENDED', startupMs: 1200, rebufferRatio: 0.01, avgBitrate: 4000 },\n  { state: 'ENDED', startupMs: 800, rebufferRatio: 0.005, avgBitrate: 6000 },\n  { state: 'ENDED', startupMs: 2000, rebufferRatio: 0.03, avgBitrate: 1500 },\n  { state: 'FAILED', startupMs: 0, rebufferRatio: 0, avgBitrate: 0 },\n]));",
      "output": "{\n  avgStartupMs: 1333,\n  avgRebufferRatio: '1.50%',\n  avgBitrate: 3833,\n  failureRate: '25.00%'\n}"
    },
    {
      "question": "Program 6: Manifest builder",
      "code": "function buildManifest(contentId, renditions, segmentDuration, totalDuration) {\n  const segments = Math.ceil(totalDuration / segmentDuration);\n  return {\n    contentId,\n    duration: totalDuration,\n    segmentDuration,\n    renditions: renditions.map(r => ({\n      ...r,\n      segments: Array.from({ length: segments }, (_, i) => ({\n        index: i,\n        url: `/cdn/${contentId}/${r.label}/seg-${i}.m4s`,\n        startTime: i * segmentDuration,\n      })),\n    })),\n  };\n}\n\nconst manifest = buildManifest('movie-42', [\n  { label: '720p', bitrate: 1500 },\n  { label: '1080p', bitrate: 4000 },\n], 6, 18);\nconsole.log(JSON.stringify(manifest.renditions[0].segments, null, 2));",
      "output": "[\n  { \"index\": 0, \"url\": \"/cdn/movie-42/720p/seg-0.m4s\", \"startTime\": 0 },\n  { \"index\": 1, \"url\": \"/cdn/movie-42/720p/seg-1.m4s\", \"startTime\": 6 },\n  { \"index\": 2, \"url\": \"/cdn/movie-42/720p/seg-2.m4s\", \"startTime\": 12 }\n]"
    },
    {
      "question": "Program 7: Entitlement checker",
      "code": "function checkEntitlement(user, content) {\n  const checks = [\n    { name: 'subscription', pass: user.plan !== 'expired' },\n    { name: 'geo', pass: content.availableRegions.includes(user.region) },\n    { name: 'maturity', pass: user.age >= content.minAge },\n    { name: 'deviceLimit', pass: user.activeDevices < user.maxDevices },\n  ];\n  const failed = checks.filter(c => !c.pass);\n  return {\n    allowed: failed.length === 0,\n    checks: checks.map(c => `${c.pass ? '✅' : '❌'} ${c.name}`),\n    reason: failed.length ? `Blocked: ${failed.map(f => f.name).join(', ')}` : 'All checks passed',\n  };\n}\n\nconsole.log(checkEntitlement(\n  { plan: 'premium', region: 'US', age: 25, activeDevices: 2, maxDevices: 4 },\n  { availableRegions: ['US', 'UK', 'IN'], minAge: 18 }\n));\nconsole.log(checkEntitlement(\n  { plan: 'expired', region: 'CN', age: 15, activeDevices: 5, maxDevices: 4 },\n  { availableRegions: ['US', 'UK'], minAge: 18 }\n));",
      "output": "{ allowed: true, checks: ['✅ subscription', '✅ geo', '✅ maturity', '✅ deviceLimit'], reason: 'All checks passed' }\n{ allowed: false, checks: ['❌ subscription', '❌ geo', '❌ maturity', '❌ deviceLimit'], reason: 'Blocked: subscription, geo, maturity, deviceLimit' }"
    },
    {
      "question": "Program 8: Buffer health monitor",
      "code": "function monitorBuffer(events) {\n  let buffer = 0;\n  const log = [];\n  events.forEach(e => {\n    if (e.type === 'segment_loaded') buffer += e.segmentDuration;\n    if (e.type === 'playback_tick') buffer -= e.elapsed;\n    let status = 'healthy';\n    if (buffer < 2) status = 'critical';\n    else if (buffer < 5) status = 'warning';\n    log.push({ time: e.time, buffer: buffer.toFixed(1) + 's', status });\n  });\n  return log;\n}\n\nconsole.log(monitorBuffer([\n  { time: '0s', type: 'segment_loaded', segmentDuration: 6 },\n  { time: '2s', type: 'playback_tick', elapsed: 2 },\n  { time: '4s', type: 'playback_tick', elapsed: 2 },\n  { time: '5s', type: 'segment_loaded', segmentDuration: 6 },\n  { time: '8s', type: 'playback_tick', elapsed: 3 },\n  { time: '12s', type: 'playback_tick', elapsed: 4 },\n  { time: '14s', type: 'playback_tick', elapsed: 2 },\n]));",
      "output": "[\n  { time: '0s', buffer: '6.0s', status: 'healthy' },\n  { time: '2s', buffer: '4.0s', status: 'warning' },\n  { time: '4s', buffer: '2.0s', status: 'warning' },\n  { time: '5s', buffer: '8.0s', status: 'healthy' },\n  { time: '8s', buffer: '5.0s', status: 'healthy' },\n  { time: '12s', buffer: '1.0s', status: 'critical' },\n  { time: '14s', buffer: '-1.0s', status: 'critical' }\n]"
    },
    {
      "question": "Program 9: Content pre-warming scheduler",
      "code": "function schedulePrewarm(releases, cdnEdges, hoursBeforeLaunch) {\n  const schedule = [];\n  releases.forEach(release => {\n    const warmStart = new Date(release.launchTime - hoursBeforeLaunch * 3600 * 1000);\n    const topEdges = cdnEdges\n      .sort((a, b) => b.subscribersInRegion - a.subscribersInRegion)\n      .slice(0, 5);\n    topEdges.forEach(edge => {\n      schedule.push({\n        content: release.title,\n        edge: edge.name,\n        warmAt: warmStart.toISOString(),\n        priority: release.expectedViewers > 1000000 ? 'HIGH' : 'NORMAL',\n      });\n    });\n  });\n  return schedule;\n}\n\nconst result = schedulePrewarm(\n  [{ title: 'New Movie', launchTime: Date.now() + 86400000, expectedViewers: 5000000 }],\n  [\n    { name: 'edge-us-east', subscribersInRegion: 2000000 },\n    { name: 'edge-eu-west', subscribersInRegion: 1500000 },\n    { name: 'edge-ap-south', subscribersInRegion: 800000 },\n  ],\n  6\n);\nconsole.log(result.length, 'warm jobs,', 'priority:', result[0].priority);",
      "output": "3 warm jobs, priority: HIGH"
    },
    {
      "question": "Program 10: Session token generator and validator",
      "code": "const crypto = require('crypto');\n\nclass SessionTokenService {\n  constructor(secret) { this.secret = secret; }\n  \n  generate(userId, deviceId, ttlSeconds) {\n    const payload = { userId, deviceId, exp: Date.now() + ttlSeconds * 1000 };\n    const data = JSON.stringify(payload);\n    const sig = crypto.createHmac('sha256', this.secret).update(data).digest('hex').slice(0, 16);\n    return Buffer.from(data).toString('base64') + '.' + sig;\n  }\n  \n  validate(token) {\n    const [dataB64, sig] = token.split('.');\n    const data = Buffer.from(dataB64, 'base64').toString();\n    const expectedSig = crypto.createHmac('sha256', this.secret).update(data).digest('hex').slice(0, 16);\n    if (sig !== expectedSig) return { valid: false, reason: 'Invalid signature' };\n    const payload = JSON.parse(data);\n    if (payload.exp < Date.now()) return { valid: false, reason: 'Token expired' };\n    return { valid: true, userId: payload.userId, deviceId: payload.deviceId };\n  }\n}\n\nconst svc = new SessionTokenService('my-secret-key');\nconst token = svc.generate('user1', 'tv-123', 3600);\nconsole.log('Token:', token.slice(0, 30) + '...');\nconsole.log('Valid:', svc.validate(token));",
      "output": "Token: eyJ1c2VySWQiOiJ1c2VyMSIsI...\nValid: { valid: true, userId: 'user1', deviceId: 'tv-123' }"
    }
  ]
}
