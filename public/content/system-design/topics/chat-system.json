{
  "id": "chat-system",
  "title": "Chat System (like WhatsApp/Slack)",
  "category": "Company HLD",
  "description": "High-level design of a real-time chat system — message delivery, presence, group chats, read receipts, and offline message handling.",
  "explanation": "A chat system like WhatsApp must deliver messages in real-time to online users, store messages for offline users, support 1:1 and group conversations, and handle presence/typing indicators — all at massive scale.\n\n**Core Components**:\n1. **Chat Server (WebSocket Gateway)**: Maintains persistent connections with clients. Routes messages to recipients.\n2. **Message Service**: Stores messages, handles ordering, deduplication.\n3. **Presence Service**: Tracks online/offline status, last seen.\n4. **Notification Service**: Push notifications for offline users (APNs/FCM).\n5. **Group Service**: Group membership, message fanout.\n6. **Media Service**: Image/video/file upload and CDN delivery.\n\n**1:1 Message Flow**:\n1. User A sends message → WebSocket → Chat Server.\n2. Chat Server stores message in DB (status: SENT).\n3. Lookup: is User B online? (Presence Service).\n4. If online: forward to User B's Chat Server → WebSocket → User B's device. Mark: DELIVERED.\n5. If offline: store in pending queue. When B comes online, flush pending messages. Also send push notification.\n6. User B reads message → send read receipt → mark: READ.\n\n**Message Ordering**:\n- Each message has: sender_id, conversation_id, timestamp, sequence_number.\n- Sequence number per conversation ensures ordering within a chat.\n- Client displays messages ordered by sequence number.\n- Server-assigned timestamps resolve cross-device ordering.\n\n**Group Chat**:\n- Small groups (<256 members): fanout-on-write. Message stored once, delivery entry per member.\n- Large groups (>256): fanout-on-read. Store message once in group timeline. Members fetch on demand.\n- Message table: (msg_id, group_id, sender_id, content, timestamp).\n- Delivery table: (msg_id, user_id, status: SENT|DELIVERED|READ).\n\n**Presence**:\n- Heartbeat: client sends ping every 30 seconds. If missed 2 consecutive heartbeats → mark offline.\n- On status change: notify all contacts who have this user's chat open.\n- 'Last seen' = timestamp of last heartbeat.\n\n**End-to-End Encryption (E2EE)**:\n- Signal Protocol: each user has identity key pair + session keys.\n- Messages encrypted on sender device, decrypted on recipient device.\n- Server cannot read message content.\n- Key exchange on first message (X3DH protocol).",
  "code": "// Real-time chat server simulation\nclass ChatServer {\n  constructor() {\n    this.connections = new Map(); // userId -> connection\n    this.messages = []; // message store\n    this.pending = new Map(); // userId -> pending messages\n    this.seqCounters = new Map(); // conversationId -> sequence\n  }\n\n  connect(userId) {\n    this.connections.set(userId, { userId, online: true, connectedAt: Date.now() });\n    // Flush pending messages\n    const pendingMsgs = this.pending.get(userId) || [];\n    this.pending.delete(userId);\n    return { status: 'CONNECTED', pendingMessages: pendingMsgs };\n  }\n\n  disconnect(userId) {\n    this.connections.delete(userId);\n    return { status: 'DISCONNECTED', lastSeen: Date.now() };\n  }\n\n  sendMessage(senderId, recipientId, content) {\n    const convId = [senderId, recipientId].sort().join(':');\n    const seq = (this.seqCounters.get(convId) || 0) + 1;\n    this.seqCounters.set(convId, seq);\n\n    const msg = {\n      id: `msg_${Date.now()}_${seq}`,\n      conversationId: convId,\n      senderId,\n      recipientId,\n      content,\n      sequence: seq,\n      timestamp: Date.now(),\n      status: 'SENT',\n    };\n    this.messages.push(msg);\n\n    // Deliver if online\n    if (this.connections.has(recipientId)) {\n      msg.status = 'DELIVERED';\n      return { ...msg, delivery: 'REALTIME' };\n    } else {\n      if (!this.pending.has(recipientId)) this.pending.set(recipientId, []);\n      this.pending.get(recipientId).push(msg);\n      return { ...msg, delivery: 'QUEUED' };\n    }\n  }\n\n  markRead(userId, messageIds) {\n    const updated = [];\n    messageIds.forEach(id => {\n      const msg = this.messages.find(m => m.id === id);\n      if (msg) { msg.status = 'READ'; updated.push(id); }\n    });\n    return { updated };\n  }\n}\n\nconst chat = new ChatServer();\nchat.connect('alice');\nchat.connect('bob');\nconsole.log(chat.sendMessage('alice', 'bob', 'Hello Bob!')); // realtime\nchat.disconnect('bob');\nconsole.log(chat.sendMessage('alice', 'bob', 'Are you there?')); // queued\nconst reconnect = chat.connect('bob');\nconsole.log('Bob reconnects:', reconnect);",
  "example": "// Group chat with fanout\nclass GroupChat {\n  constructor() {\n    this.groups = new Map(); // groupId -> { members, messages }\n  }\n  createGroup(groupId, members) {\n    this.groups.set(groupId, { members: new Set(members), messages: [] });\n  }\n  sendGroupMessage(groupId, senderId, content) {\n    const group = this.groups.get(groupId);\n    if (!group || !group.members.has(senderId)) return { error: 'Not a member' };\n    const msg = { id: `gm_${Date.now()}`, groupId, senderId, content, timestamp: Date.now() };\n    group.messages.push(msg);\n    // Fanout: create delivery entry for each member\n    const deliveries = [...group.members]\n      .filter(m => m !== senderId)\n      .map(m => ({ userId: m, status: 'SENT' }));\n    return { message: msg, deliveries };\n  }\n  getMessages(groupId, userId, limit = 10) {\n    const group = this.groups.get(groupId);\n    if (!group?.members.has(userId)) return [];\n    return group.messages.slice(-limit);\n  }\n}\n\nconst gc = new GroupChat();\ngc.createGroup('g1', ['alice', 'bob', 'carol']);\nconsole.log(gc.sendGroupMessage('g1', 'alice', 'Hey everyone!'));\nconsole.log(gc.sendGroupMessage('g1', 'bob', 'Hi Alice!'));\nconsole.log('Messages:', gc.getMessages('g1', 'carol'));",
  "useCase": "Instant messaging, team collaboration tools, customer support chat, in-app messaging, social media DMs.",
  "interviewQuestions": [
    { "question": "How do you ensure message ordering in a chat?", "answer": "Sequence number per conversation, assigned by server. Client displays by sequence number. For concurrent sends in same conversation, server serializes via a lock or queue per conversation_id. Timestamps are secondary — used for display, not ordering." },
    { "question": "How do you handle message delivery for offline users?", "answer": "Store in pending queue (Redis list per user or DB). When user reconnects (WebSocket established), flush queue. Also send push notification via APNs/FCM. Mark messages as DELIVERED when client acknowledges receipt. Messages persist in DB regardless of online status." },
    { "question": "How do you scale WebSocket connections?", "answer": "Each server maintains N connections. Route messages between servers via pub/sub (Redis Pub/Sub or Kafka). User → server mapping stored in Redis. On send: lookup recipient's server → publish to that server → server forwards to user's WebSocket. Horizontal scale: add more WebSocket servers behind L4 load balancer (sticky sessions by user)." },
    { "question": "How do group messages work differently from 1:1?", "answer": "1:1: simple point-to-point. Groups: message stored once + delivery entry per member (fanout-on-write for small groups). For groups with 10K members, fanout-on-read: store one message, members pull. Group messages need member list maintenance, admin controls, and read receipt aggregation." },
    { "question": "How do you implement typing indicators?", "answer": "Client sends 'typing' event when user starts typing. Server forwards to other participants (no persistence). Debounce: send at most once per 3 seconds. Auto-clear after 5 seconds of no keypress. Not sent for group chats > 50 members (too noisy). Sent via same WebSocket, not REST." },
    { "question": "How do you implement read receipts?", "answer": "When recipient views message: client sends ACK with message_id. Server updates delivery status to READ. Send read receipt event to sender. For groups: maintain per-member status. Show 'Read by N' aggregate, not individual receipts for large groups. Blue ticks = all group members read." },
    { "question": "How do you handle media messages (images, videos)?", "answer": "Upload flow: client → upload service → object storage (S3). Get back media_url. Send chat message with media_url + thumbnail. Recipient downloads media separately. Encrypt media with per-message key for E2EE. CDN for media delivery. Compress images/videos client-side before upload." },
    { "question": "How do you implement message search?", "answer": "Local search: client-side full-text search on message cache/DB. Server search: Elasticsearch index on messages (for non-E2EE apps). For E2EE: search only works on client device (server can't index encrypted content). Index: message content + metadata. Support: by keyword, by sender, by date range." },
    { "question": "What is the data model for messages?", "answer": "Messages table: (id PK, conversation_id, sender_id, content, type, timestamp, sequence). Conversations table: (id PK, type: 1:1|group, last_message_id, updated_at). Participants table: (conversation_id, user_id, role, joined_at). Delivery: (message_id, user_id, status, delivered_at, read_at). Partition by conversation_id." },
    { "question": "How do you implement message deletion?", "answer": "Soft delete: mark message as deleted, hide from UI, keep in DB for compliance. 'Delete for me': only remove from user's view (add to user's deleted_messages set). 'Delete for everyone': mark message as globally deleted (within time window, e.g., 1 hour). Show 'This message was deleted' placeholder." }
  ],
  "exercises": [
    { "type": "estimation", "question": "1B daily active users, each sends 50 messages/day. Average message: 100 bytes + 50B metadata. Estimate daily data.", "answer": "Messages/day: 1B × 50 = 50B messages. Storage: 50B × 150B = 7.5TB/day. Monthly: 225TB. Write QPS: 50B / 86400 = 579K writes/sec. Peak (3x): 1.7M writes/sec. Need: distributed DB (Cassandra, DynamoDB) with heavy partitioning." },
    { "type": "design", "question": "Design the presence (online/offline) service.", "answer": "On connect: user sends heartbeat → server sets Redis key (user:{id}, TTL=60s). Every 30s: client renews heartbeat. If key expires → user offline. On subscribe to contact's presence: listen to Redis keyspace notifications. Optimization: batch presence updates for contact list. Don't push presence for contacts not in active chat." },
    { "type": "scenario", "question": "User has 5 devices (phone, tablet, laptop, desktop, web). How does multi-device sync work?", "answer": "Each device maintains separate WebSocket. Message sent from one device → delivered to all other devices (including sender's). Each device tracks its own delivery/read state. Sequence numbers ensure ordering across devices. Device registration: server maintains device list per user. Push to all connected devices." },
    { "type": "tricky", "question": "Why not just use HTTP polling instead of WebSocket?", "answer": "Polling: client asks 'any new messages?' every N seconds. Wasteful: 95% of polls return empty. Latency: up to N seconds delay. WebSocket: persistent connection, server pushes instantly. 1B users × 1 poll/sec = 1B req/sec (expensive). WebSocket: 1B persistent connections (fewer resources). Long-polling is a middle ground but still wastes connections." },
    { "type": "design", "question": "Design message delivery guarantees (at-least-once, exactly-once).", "answer": "At-least-once: server retries delivery until client ACKs. Client deduplicates by message_id. Exactly-once: idempotent processing with unique message_id. Server: write to DB + send to recipient. If recipient doesn't ACK within 5s, retry. Client: if receives duplicate msg_id, ignore. ACK is the client's confirmation message." },
    { "type": "output", "question": "Alice sends 3 messages to offline Bob. Bob reconnects. What events fire?", "answer": "1) Bob WebSocket connected → server sends 3 pending messages (ordered by sequence). 2) Bob's client ACKs each → server marks DELIVERED. 3) Server sends delivery receipts to Alice ('double tick'). 4) When Bob reads → read receipt sent to Alice ('blue tick'). 5) Presence service marks Bob as online → Alice sees 'online'." },
    { "type": "estimation", "question": "WhatsApp group: 256 members. One message. How many DB writes, how many deliveries?", "answer": "DB writes: 1 for message + 255 for delivery records = 256 writes. If group has 100 messages/day: 25,600 delivery writes/day. For 1M groups of size 256: 25.6B delivery writes/day. This is why large groups (Telegram channels with 100K) must use fanout-on-read." },
    { "type": "design", "question": "Design the notification system for offline messages.", "answer": "On message to offline user: Chat Server → Notification Queue (Kafka). Consumer: lookup user's push tokens (FCM for Android, APNs for iOS). Construct notification: sender name + message preview (if not E2EE) or 'New message'. Rate limit: collapse multiple notifications into '5 new messages from Alice'. User preferences: mute per conversation, DND hours." },
    { "type": "debug", "question": "Users report messages arriving out of order. What could cause this?", "answer": "1) Multiple chat servers assigning timestamps with clock skew. Fix: use sequence numbers, not timestamps. 2) Network race: message B arrives before A at recipient. Fix: client buffers and reorders by sequence. 3) Multi-device: different devices show different order. Fix: single source of truth (server sequence). 4) Group message fanout taking different paths." },
    { "type": "scenario", "question": "A celebrity posts in a group with 100K members. How does message delivery work?", "answer": "Fanout-on-read: store message once in group timeline. When member opens chat, fetch latest from group timeline. No individual delivery writes. Push notification: batch notification to all members (not instant — stagger over minutes). Read receipts: disabled for large groups. Online members get WebSocket event for new message notification (not full content)." }
  ],
  "programExercises": [
    {
      "question": "Program 1: 1:1 chat with delivery status tracking",
      "code": "class Chat {\n  constructor() { this.messages = []; this.online = new Set(); }\n  connect(user) { this.online.add(user); }\n  disconnect(user) { this.online.delete(user); }\n  send(from, to, text) {\n    const msg = { id: this.messages.length + 1, from, to, text, status: 'SENT', time: Date.now() };\n    if (this.online.has(to)) msg.status = 'DELIVERED';\n    this.messages.push(msg);\n    return { id: msg.id, status: msg.status };\n  }\n  read(userId, msgId) {\n    const msg = this.messages.find(m => m.id === msgId && m.to === userId);\n    if (msg) { msg.status = 'READ'; return true; }\n    return false;\n  }\n  getConversation(user1, user2) {\n    return this.messages.filter(m => \n      (m.from === user1 && m.to === user2) || (m.from === user2 && m.to === user1)\n    ).map(m => `[${m.status}] ${m.from}: ${m.text}`);\n  }\n}\n\nconst c = new Chat();\nc.connect('alice'); c.connect('bob');\nconsole.log(c.send('alice', 'bob', 'Hi!'));\nconsole.log(c.send('bob', 'alice', 'Hey!'));\nc.disconnect('alice');\nconsole.log(c.send('bob', 'alice', 'You there?'));\nc.read('bob', 1);\nconsole.log(c.getConversation('alice', 'bob'));",
      "output": "{ id: 1, status: 'DELIVERED' }\n{ id: 2, status: 'DELIVERED' }\n{ id: 3, status: 'SENT' }\n[\n  '[READ] alice: Hi!',\n  '[DELIVERED] bob: Hey!',\n  '[SENT] bob: You there?'\n]"
    },
    {
      "question": "Program 2: Presence service with heartbeat",
      "code": "class PresenceService {\n  constructor(timeoutMs) {\n    this.timeout = timeoutMs;\n    this.heartbeats = new Map();\n  }\n  heartbeat(userId) {\n    this.heartbeats.set(userId, Date.now());\n  }\n  isOnline(userId) {\n    const last = this.heartbeats.get(userId);\n    return last && (Date.now() - last) < this.timeout;\n  }\n  getStatus(userId) {\n    const last = this.heartbeats.get(userId);\n    if (!last) return { userId, status: 'NEVER_SEEN' };\n    if (Date.now() - last < this.timeout) return { userId, status: 'ONLINE' };\n    return { userId, status: 'OFFLINE', lastSeen: new Date(last).toISOString() };\n  }\n  getOnlineUsers(userIds) {\n    return userIds.filter(id => this.isOnline(id));\n  }\n}\n\nconst ps = new PresenceService(5000); // 5s timeout\nps.heartbeat('alice');\nps.heartbeat('bob');\nps.heartbeat('carol');\n// Simulate carol going offline by setting old heartbeat\nps.heartbeats.set('carol', Date.now() - 10000);\n\nconsole.log(ps.getStatus('alice'));\nconsole.log(ps.getStatus('carol'));\nconsole.log(ps.getStatus('dave'));\nconsole.log('Online:', ps.getOnlineUsers(['alice', 'bob', 'carol', 'dave']));",
      "output": "{ userId: 'alice', status: 'ONLINE' }\n{ userId: 'carol', status: 'OFFLINE', lastSeen: '...' }\n{ userId: 'dave', status: 'NEVER_SEEN' }\nOnline: [ 'alice', 'bob' ]"
    },
    {
      "question": "Program 3: Group chat with fanout",
      "code": "class GroupChatService {\n  constructor() { this.groups = new Map(); }\n  create(id, members) {\n    this.groups.set(id, { members: new Set(members), messages: [], deliveries: new Map() });\n  }\n  send(groupId, sender, text) {\n    const g = this.groups.get(groupId);\n    if (!g?.members.has(sender)) return { error: 'Not a member' };\n    const msg = { id: `${groupId}_${g.messages.length + 1}`, sender, text };\n    g.messages.push(msg);\n    // Fanout delivery\n    const delivery = new Map();\n    g.members.forEach(m => { if (m !== sender) delivery.set(m, 'SENT'); });\n    g.deliveries.set(msg.id, delivery);\n    return { msgId: msg.id, deliveredTo: delivery.size };\n  }\n  markDelivered(groupId, msgId, userId) {\n    this.groups.get(groupId)?.deliveries.get(msgId)?.set(userId, 'DELIVERED');\n  }\n  getDeliveryStatus(groupId, msgId) {\n    const d = this.groups.get(groupId)?.deliveries.get(msgId);\n    if (!d) return null;\n    return Object.fromEntries(d);\n  }\n}\n\nconst gs = new GroupChatService();\ngs.create('team', ['alice', 'bob', 'carol']);\nconsole.log(gs.send('team', 'alice', 'Meeting at 3pm'));\ngs.markDelivered('team', 'team_1', 'bob');\nconsole.log(gs.getDeliveryStatus('team', 'team_1'));",
      "output": "{ msgId: 'team_1', deliveredTo: 2 }\n{ bob: 'DELIVERED', carol: 'SENT' }"
    },
    {
      "question": "Program 4: Message queue for offline delivery",
      "code": "class OfflineQueue {\n  constructor() { this.queues = new Map(); }\n  enqueue(userId, message) {\n    if (!this.queues.has(userId)) this.queues.set(userId, []);\n    this.queues.get(userId).push(message);\n  }\n  flush(userId) {\n    const messages = this.queues.get(userId) || [];\n    this.queues.delete(userId);\n    return { userId, count: messages.length, messages };\n  }\n  pending(userId) {\n    return (this.queues.get(userId) || []).length;\n  }\n}\n\nconst q = new OfflineQueue();\nq.enqueue('bob', { from: 'alice', text: 'Hi Bob!' });\nq.enqueue('bob', { from: 'alice', text: 'Are you there?' });\nq.enqueue('bob', { from: 'carol', text: 'Check this out' });\nconsole.log('Pending for Bob:', q.pending('bob'));\nconsole.log('Bob comes online:', q.flush('bob'));\nconsole.log('Pending after flush:', q.pending('bob'));",
      "output": "Pending for Bob: 3\nBob comes online: {\n  userId: 'bob',\n  count: 3,\n  messages: [\n    { from: 'alice', text: 'Hi Bob!' },\n    { from: 'alice', text: 'Are you there?' },\n    { from: 'carol', text: 'Check this out' }\n  ]\n}\nPending after flush: 0"
    },
    {
      "question": "Program 5: Conversation thread manager",
      "code": "class ConversationManager {\n  constructor() { this.conversations = new Map(); }\n  getOrCreate(user1, user2) {\n    const id = [user1, user2].sort().join(':');\n    if (!this.conversations.has(id)) {\n      this.conversations.set(id, { id, participants: [user1, user2], messages: [], lastActivity: null });\n    }\n    return this.conversations.get(id);\n  }\n  addMessage(user1, user2, sender, text) {\n    const conv = this.getOrCreate(user1, user2);\n    const msg = { sender, text, seq: conv.messages.length + 1, time: Date.now() };\n    conv.messages.push(msg);\n    conv.lastActivity = msg.time;\n    return msg;\n  }\n  getInbox(userId) {\n    return [...this.conversations.values()]\n      .filter(c => c.participants.includes(userId))\n      .sort((a, b) => (b.lastActivity || 0) - (a.lastActivity || 0))\n      .map(c => ({\n        with: c.participants.find(p => p !== userId),\n        lastMessage: c.messages[c.messages.length - 1]?.text,\n        messageCount: c.messages.length,\n      }));\n  }\n}\n\nconst cm = new ConversationManager();\ncm.addMessage('alice', 'bob', 'alice', 'Hey!');\ncm.addMessage('alice', 'bob', 'bob', 'Hi!');\ncm.addMessage('alice', 'carol', 'carol', 'Lunch?');\nconsole.log(cm.getInbox('alice'));",
      "output": "[\n  { with: 'carol', lastMessage: 'Lunch?', messageCount: 1 },\n  { with: 'bob', lastMessage: 'Hi!', messageCount: 2 }\n]"
    },
    {
      "question": "Program 6: Typing indicator with debounce",
      "code": "class TypingIndicator {\n  constructor(timeoutMs) {\n    this.timeout = timeoutMs;\n    this.typing = new Map(); // conversationId -> { userId, expiresAt }\n  }\n  setTyping(convId, userId) {\n    const key = `${convId}:${userId}`;\n    this.typing.set(key, { userId, expiresAt: Date.now() + this.timeout });\n  }\n  getTyping(convId) {\n    const now = Date.now();\n    const result = [];\n    for (const [key, val] of this.typing) {\n      if (key.startsWith(convId + ':')) {\n        if (val.expiresAt > now) result.push(val.userId);\n        else this.typing.delete(key);\n      }\n    }\n    return result;\n  }\n}\n\nconst ti = new TypingIndicator(3000); // 3s timeout\nti.setTyping('conv1', 'alice');\nti.setTyping('conv1', 'bob');\nconsole.log('Typing in conv1:', ti.getTyping('conv1'));\n// Simulate alice stops typing\nti.typing.set('conv1:alice', { userId: 'alice', expiresAt: Date.now() - 1000 });\nconsole.log('After alice stops:', ti.getTyping('conv1'));",
      "output": "Typing in conv1: [ 'alice', 'bob' ]\nAfter alice stops: [ 'bob' ]"
    },
    {
      "question": "Program 7: Message deduplication",
      "code": "class MessageDeduplicator {\n  constructor() { this.seen = new Set(); this.messages = []; }\n  process(message) {\n    if (this.seen.has(message.id)) {\n      return { action: 'DUPLICATE', id: message.id };\n    }\n    this.seen.add(message.id);\n    this.messages.push(message);\n    return { action: 'ACCEPTED', id: message.id, total: this.messages.length };\n  }\n}\n\nconst dedup = new MessageDeduplicator();\nconsole.log(dedup.process({ id: 'msg1', text: 'Hello' }));\nconsole.log(dedup.process({ id: 'msg2', text: 'World' }));\nconsole.log(dedup.process({ id: 'msg1', text: 'Hello' })); // retry/duplicate\nconsole.log(dedup.process({ id: 'msg3', text: '!' }));\nconsole.log('Total unique:', dedup.messages.length);",
      "output": "{ action: 'ACCEPTED', id: 'msg1', total: 1 }\n{ action: 'ACCEPTED', id: 'msg2', total: 2 }\n{ action: 'DUPLICATE', id: 'msg1' }\n{ action: 'ACCEPTED', id: 'msg3', total: 3 }\nTotal unique: 3"
    },
    {
      "question": "Program 8: Read receipt aggregator for groups",
      "code": "class ReadReceipts {\n  constructor() { this.receipts = new Map(); }\n  \n  markRead(msgId, userId) {\n    if (!this.receipts.has(msgId)) this.receipts.set(msgId, new Set());\n    this.receipts.get(msgId).add(userId);\n  }\n  \n  getStatus(msgId, totalMembers) {\n    const readers = this.receipts.get(msgId) || new Set();\n    const readCount = readers.size;\n    return {\n      msgId,\n      readBy: [...readers],\n      readCount,\n      totalMembers,\n      allRead: readCount >= totalMembers,\n      display: readCount === 0 ? '✓ Sent' : readCount >= totalMembers ? '✓✓ Read by all' : `✓✓ Read by ${readCount}`,\n    };\n  }\n}\n\nconst rr = new ReadReceipts();\nrr.markRead('msg1', 'bob');\nconsole.log(rr.getStatus('msg1', 3));\nrr.markRead('msg1', 'carol');\nrr.markRead('msg1', 'dave');\nconsole.log(rr.getStatus('msg1', 3));",
      "output": "{\n  msgId: 'msg1',\n  readBy: [ 'bob' ],\n  readCount: 1,\n  totalMembers: 3,\n  allRead: false,\n  display: '✓✓ Read by 1'\n}\n{\n  msgId: 'msg1',\n  readBy: [ 'bob', 'carol', 'dave' ],\n  readCount: 3,\n  totalMembers: 3,\n  allRead: true,\n  display: '✓✓ Read by all'\n}"
    },
    {
      "question": "Program 9: Message encryption/decryption (simplified)",
      "code": "class SimpleE2EE {\n  constructor() { this.keys = new Map(); }\n  generateKeyPair(userId) {\n    // Simplified: in reality use asymmetric crypto\n    const key = Math.random().toString(36).substring(2, 18);\n    this.keys.set(userId, key);\n    return { userId, keyLength: key.length };\n  }\n  encrypt(senderId, recipientId, plaintext) {\n    const key = this.keys.get(recipientId);\n    if (!key) return { error: 'No key for recipient' };\n    // Simplified XOR-like encryption\n    const encrypted = plaintext.split('').map((c, i) => \n      String.fromCharCode(c.charCodeAt(0) ^ key.charCodeAt(i % key.length))\n    ).join('');\n    return { encrypted: Buffer.from(encrypted).toString('base64'), for: recipientId };\n  }\n  decrypt(recipientId, encryptedBase64) {\n    const key = this.keys.get(recipientId);\n    const encrypted = Buffer.from(encryptedBase64, 'base64').toString();\n    const decrypted = encrypted.split('').map((c, i) =>\n      String.fromCharCode(c.charCodeAt(0) ^ key.charCodeAt(i % key.length))\n    ).join('');\n    return { decrypted };\n  }\n}\n\nconst e2ee = new SimpleE2EE();\ne2ee.generateKeyPair('alice');\ne2ee.generateKeyPair('bob');\nconst { encrypted } = e2ee.encrypt('alice', 'bob', 'Secret message!');\nconsole.log('Encrypted:', encrypted);\nconsole.log('Decrypted:', e2ee.decrypt('bob', encrypted));",
      "output": "Encrypted: <base64 string>\nDecrypted: { decrypted: 'Secret message!' }"
    },
    {
      "question": "Program 10: Chat message search",
      "code": "class MessageSearch {\n  constructor() { this.index = []; }\n  addMessage(msg) { this.index.push(msg); }\n  search(query, filters = {}) {\n    const q = query.toLowerCase();\n    return this.index.filter(msg => {\n      if (!msg.text.toLowerCase().includes(q)) return false;\n      if (filters.from && msg.from !== filters.from) return false;\n      if (filters.conversation && msg.conversation !== filters.conversation) return false;\n      return true;\n    }).map(msg => ({\n      id: msg.id,\n      from: msg.from,\n      preview: msg.text.substring(0, 50),\n      conversation: msg.conversation,\n    }));\n  }\n}\n\nconst ms = new MessageSearch();\nms.addMessage({ id: 1, from: 'alice', text: 'Meeting at 3pm tomorrow', conversation: 'work' });\nms.addMessage({ id: 2, from: 'bob', text: 'Can we reschedule the meeting?', conversation: 'work' });\nms.addMessage({ id: 3, from: 'carol', text: 'Lunch meeting at noon', conversation: 'friends' });\nms.addMessage({ id: 4, from: 'alice', text: 'Sure, see you then', conversation: 'work' });\n\nconsole.log(ms.search('meeting'));\nconsole.log(ms.search('meeting', { conversation: 'work' }));",
      "output": "[\n  { id: 1, from: 'alice', preview: 'Meeting at 3pm tomorrow', conversation: 'work' },\n  { id: 2, from: 'bob', preview: 'Can we reschedule the meeting?', conversation: 'work' },\n  { id: 3, from: 'carol', preview: 'Lunch meeting at noon', conversation: 'friends' }\n]\n[\n  { id: 1, from: 'alice', preview: 'Meeting at 3pm tomorrow', conversation: 'work' },\n  { id: 2, from: 'bob', preview: 'Can we reschedule the meeting?', conversation: 'work' }\n]"
    }
  ]
}
