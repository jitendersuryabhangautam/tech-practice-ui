{
  "id": "ride-matching",
  "title": "Ride Matching System (like Uber/Ola)",
  "category": "Company HLD",
  "description": "Design a ride-matching system that matches riders with nearby drivers in real-time, handles surge pricing, ETA computation, and processes millions of location updates per second.",
  "explanation": "A ride-matching system like Uber connects riders requesting rides with available drivers nearby. The core challenges: real-time geolocation matching at scale, dynamic pricing, accurate ETAs, and handling millions of concurrent drivers and riders.\n\n**Core Components**:\n1. **Location Service**: Ingests driver GPS updates (every 3-5 seconds). Stores in geospatial index.\n2. **Matching Service**: When rider requests ride → query nearby available drivers → rank → assign.\n3. **Pricing Service**: Calculates fare based on distance, time, surge multiplier.\n4. **ETA Service**: Estimates arrival time using road graph + real-time traffic.\n5. **Trip Service**: Manages trip lifecycle (requested → matched → enroute → in-trip → completed).\n6. **Payment Service**: Processes payment after trip ends.\n\n**Ride Request Flow**:\n1. Rider opens app → sends location (lat, lng) + destination.\n2. Pricing Service computes estimated fare (distance × rate + surge).\n3. Rider confirms → Matching Service queries Location Service: find drivers within 5km radius.\n4. Filter: available drivers + correct vehicle type.\n5. Rank: by ETA to pickup (not straight-line distance).\n6. Send ride request to top driver. If no response in 15s → next driver.\n7. Driver accepts → Trip created. Both rider and driver see each other's location.\n8. Driver arrives → trip starts → driver navigates to destination → trip ends.\n9. Fare calculated from actual route. Payment processed.\n\n**Geospatial Indexing**:\n- GeoHash: encode (lat, lng) to string. Nearby locations share common prefix.\n- S2 Geometry (Google): divides Earth into cells. Level-12 cells ≈ 3km².\n- QuadTree: divide map recursively. Each node = geographic rectangle.\n- Store: driver_id → geohash in Redis Sorted Set. GEOSEARCH command finds nearby.\n\n**Surge Pricing**:\n- Divide city into hexagonal zones (H3 cells).\n- In each zone: supply = available drivers, demand = ride requests in last 5 min.\n- Surge multiplier = demand / supply (capped at 3x-5x).\n- Smoothing: weighted average with neighboring zones.\n- Display surge to rider before confirmation.",
  "code": "// Ride matching system simulation\nclass RideMatchingSystem {\n  constructor() {\n    this.drivers = new Map(); // id -> { lat, lng, available, vehicleType }\n    this.trips = new Map(); // id -> trip\n    this.tripCounter = 0;\n  }\n\n  updateDriverLocation(driverId, lat, lng, vehicleType = 'sedan') {\n    this.drivers.set(driverId, {\n      id: driverId, lat, lng,\n      available: this.drivers.get(driverId)?.available ?? true,\n      vehicleType,\n    });\n  }\n\n  haversineDistance(lat1, lng1, lat2, lng2) {\n    const R = 6371; // km\n    const dLat = (lat2 - lat1) * Math.PI / 180;\n    const dLng = (lng2 - lng1) * Math.PI / 180;\n    const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) * Math.sin(dLng/2)**2;\n    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n  }\n\n  findNearbyDrivers(lat, lng, radiusKm = 5, vehicleType = 'sedan') {\n    const nearby = [];\n    for (const driver of this.drivers.values()) {\n      if (!driver.available || driver.vehicleType !== vehicleType) continue;\n      const dist = this.haversineDistance(lat, lng, driver.lat, driver.lng);\n      if (dist <= radiusKm) nearby.push({ ...driver, distance: parseFloat(dist.toFixed(2)) });\n    }\n    return nearby.sort((a, b) => a.distance - b.distance);\n  }\n\n  requestRide(riderId, pickupLat, pickupLng, destLat, destLng, vehicleType = 'sedan') {\n    const nearby = this.findNearbyDrivers(pickupLat, pickupLng, 5, vehicleType);\n    if (nearby.length === 0) return { status: 'NO_DRIVERS', message: 'No drivers available nearby' };\n\n    const bestDriver = nearby[0];\n    bestDriver.available = false;\n    this.drivers.set(bestDriver.id, bestDriver);\n\n    const tripDist = this.haversineDistance(pickupLat, pickupLng, destLat, destLng);\n    const tripId = `trip_${++this.tripCounter}`;\n    const trip = {\n      id: tripId, riderId, driverId: bestDriver.id,\n      pickup: { lat: pickupLat, lng: pickupLng },\n      destination: { lat: destLat, lng: destLng },\n      distance: parseFloat(tripDist.toFixed(2)),\n      estimatedFare: parseFloat((tripDist * 12 + 30).toFixed(2)), // ₹12/km + ₹30 base\n      status: 'MATCHED',\n      eta: parseFloat((bestDriver.distance / 30 * 60).toFixed(1)), // minutes at 30km/h\n    };\n    this.trips.set(tripId, trip);\n    return trip;\n  }\n\n  completeTrip(tripId) {\n    const trip = this.trips.get(tripId);\n    if (!trip) return { error: 'Trip not found' };\n    trip.status = 'COMPLETED';\n    const driver = this.drivers.get(trip.driverId);\n    if (driver) driver.available = true;\n    return { tripId, status: 'COMPLETED', fare: trip.estimatedFare };\n  }\n}\n\nconst rms = new RideMatchingSystem();\n// Drivers in Bangalore area\nrms.updateDriverLocation('d1', 12.9716, 77.5946);\nrms.updateDriverLocation('d2', 12.9800, 77.5900);\nrms.updateDriverLocation('d3', 12.9600, 77.6100);\nrms.updateDriverLocation('d4', 13.0200, 77.5600, 'suv');\n\nconsole.log('Nearby:', rms.findNearbyDrivers(12.9750, 77.5950));\nconsole.log('\\nRide:', rms.requestRide('r1', 12.9750, 77.5950, 13.0280, 77.6173));\nconsole.log('\\nComplete:', rms.completeTrip('trip_1'));",
  "example": "// Surge pricing calculator\nclass SurgePricing {\n  constructor() {\n    this.zones = new Map(); // zoneId -> { supply, demand }\n  }\n  updateZone(zoneId, supply, demand) {\n    this.zones.set(zoneId, { supply, demand });\n  }\n  getSurge(zoneId) {\n    const zone = this.zones.get(zoneId);\n    if (!zone || zone.supply === 0) return { multiplier: 5.0, reason: 'No supply' };\n    const ratio = zone.demand / zone.supply;\n    let multiplier = 1.0;\n    if (ratio > 2.0) multiplier = Math.min(ratio * 0.8, 5.0);\n    else if (ratio > 1.5) multiplier = 1.5;\n    else if (ratio > 1.0) multiplier = 1.2;\n    return { zoneId, supply: zone.supply, demand: zone.demand, ratio: ratio.toFixed(2), multiplier: parseFloat(multiplier.toFixed(1)) };\n  }\n  calculateFare(zoneId, distKm, baseRate = 12, baseFare = 30) {\n    const surge = this.getSurge(zoneId);\n    const fare = (baseFare + distKm * baseRate) * surge.multiplier;\n    return { distance: distKm, baseFare: baseFare + distKm * baseRate, surge: surge.multiplier, finalFare: parseFloat(fare.toFixed(2)) };\n  }\n}\n\nconst sp = new SurgePricing();\nsp.updateZone('zone-A', 10, 5);   // balanced\nsp.updateZone('zone-B', 3, 15);   // high demand\nsp.updateZone('zone-C', 20, 10);  // oversupply\n\nconsole.log(sp.getSurge('zone-A'));\nconsole.log(sp.getSurge('zone-B'));\nconsole.log(sp.calculateFare('zone-A', 8));\nconsole.log(sp.calculateFare('zone-B', 8));",
  "useCase": "Ride-hailing (Uber, Ola, Lyft), food delivery matching, ambulance dispatch, courier assignment, fleet management, logistics vehicle routing.",
  "interviewQuestions": [
    { "question": "How do you efficiently find nearby drivers?", "answer": "Geospatial index: GeoHash or S2 cells. Store driver locations in Redis GEO: GEOADD drivers <lng> <lat> <driverId>. Query: GEOSEARCH drivers FROMLONLAT <lng> <lat> BYRADIUS 5 km ASC COUNT 10. This gives nearest 10 drivers within 5km. O(log N) per query. Update on every GPS ping (every 3-5s). Alternative: QuadTree in-memory for lower latency." },
    { "question": "How do you handle the matching algorithm?", "answer": "Step 1: Nearby drivers (geospatial query). Step 2: Filter: available + correct vehicle type. Step 3: Rank by ETA (road-network distance, not Euclidean). Step 4: Offer to top driver with 15s timeout. If declined/timeout → next driver. Step 5: Optimization: batch matching — collect requests over 2s window, solve assignment problem (Hungarian algorithm) for optimal global matching." },
    { "question": "How does surge pricing work?", "answer": "Divide city into zones (H3 hexagons). Every 5 minutes: count demand (ride requests) and supply (available drivers) per zone. Ratio = demand/supply. If ratio > 1.5 → surge. Multiplier = f(ratio), capped at 5x. Smooth transitions: weighted average with previous interval. Show surge to rider before booking. Purpose: incentivize drivers to move to high-demand areas." },
    { "question": "How do you handle millions of GPS updates per second?", "answer": "Drivers send updates every 3-5s. 1M drivers = 200K-333K updates/sec. Ingest via Kafka (partitioned by driver_id or zone). Consumer updates Redis GEO. Batch writes: aggregate updates in 1s micro-batches. Dead reckoning: if update missed, extrapolate position from last known heading + speed. Prioritize: only update index for available drivers." },
    { "question": "How do you compute accurate ETAs?", "answer": "Simple: straight-line distance / avg speed. Better: road-network graph + Dijkstra/A*. Best: pre-computed contraction hierarchies for instant routing. Real-time: overlay traffic data on road graph (speed per road segment from driver GPS traces). ML: train model on historical trip data: features = origin, destination, time of day, weather → ETA. Combine: routing ETA * ML correction factor." },
    { "question": "How do you design the trip lifecycle?", "answer": "States: REQUESTED → MATCHING → DRIVER_ASSIGNED → DRIVER_ENROUTE → DRIVER_ARRIVED → TRIP_STARTED → TRIP_IN_PROGRESS → TRIP_COMPLETED → PAYMENT_PROCESSED. State machine in Trip Service. Transitions triggered by: driver accept, driver arrival (geo-fence: within 100m), rider swipe to start, driver ends trip. Each transition → event to Kafka → consumed by analytics, billing, notification services." },
    { "question": "How do you handle driver-side and rider-side cancellation?", "answer": "Rider cancels before driver assignment → no penalty. Rider cancels after driver en route → cancellation fee (covers driver's time). Driver cancels → penalize driver (affects acceptance rate score). Driver no-show at pickup → rider can cancel without fee after 5 min wait. System handles: re-match rider with next driver. Rate limits: frequent cancellers get lower priority." },
    { "question": "How do you ensure payment reliability?", "answer": "Pre-authorization: charge rider's card a hold (estimated fare + 20% buffer) before ride starts. After trip: calculate actual fare → capture exact amount. If card declines pre-auth → don't allow ride. For cash rides: driver collects cash, platform deducts from driver's next payout. Dispute handling: refund policy for overcharges, GPS-verified routes, fare breakdown." },
    { "question": "How do you handle real-time location sharing between rider and driver?", "answer": "After match: both subscribe to each other's location via WebSocket. Driver GPS → Location Service → WebSocket to rider (every 3s). Rider sees driver moving on map. After trip starts: rider location not needed (driver knows destination). Trip tracking: rider can share live trip URL with contacts (safety). Privacy: location sharing stops after trip ends." },
    { "question": "How do you design the system for multi-city expansion?", "answer": "Region-based architecture: each city is an independent deployment. Shared: user auth, payment, core platform. City-specific: driver pool, pricing config, map data, surge zones. Benefits: isolation (one city's outage doesn't affect others), compliance (local regulations per city). Data: geo-partitioned (India data → India region). Configuration: per-city settings (base fare, surge cap, vehicle types)." }
  ],
  "exercises": [
    { "type": "estimation", "question": "Uber: 5M drivers, each sends GPS every 4 seconds. Estimate ingestion rate and storage.", "answer": "GPS updates/sec: 5M / 4 = 1.25M/sec. Each update: driver_id(8B) + lat(8B) + lng(8B) + timestamp(8B) + heading(4B) + speed(4B) = 40B. Throughput: 1.25M × 40B = 50MB/sec = 4.3TB/day. Geospatial index: only latest position per driver → 5M × 40B = 200MB (fits in memory). Historical: store in time-series DB with 30-day retention." },
    { "type": "design", "question": "Design the driver dispatch optimization to prevent the 'thundering herd' problem.", "answer": "Problem: popular area with many riders → all requests go to same nearest driver. Solution: batch matching. Collect all ride requests in 2s window. Solve assignment problem: minimize total pickup distance across all (rider, driver) pairs. Algorithms: Hungarian method (optimal but O(n³)), greedy nearest-first (fast, near-optimal). Partition by zone: solve independently per zone to reduce problem size." },
    { "type": "scenario", "question": "Concert ends at a stadium. 50,000 riders request rides simultaneously. How does the system handle it?", "answer": "1) Surg: demand spike → surge pricing activates (5x) → some riders drop off. 2) Queue: virtual waiting room 'You are #2,347 in queue'. 3) Batch matching: process in waves. 4) Expand radius: look for drivers up to 15km away. 5) Push to drivers: 'High demand at Stadium Road — surge 4x' to attract supply. 6) Ride-share: offer shared rides to reduce individual demand. 7) Stagger: ETA transparency — 'Next available in 15 min'." },
    { "type": "tricky", "question": "Why use GeoHash over simple lat/lng range queries?", "answer": "Range query: WHERE lat BETWEEN x1 AND x2 AND lng BETWEEN y1 AND y2. Problem: rectangular, not circular. Needs secondary index on both columns. GeoHash: single dimension → single index. Prefix matching = proximity. Redis GEOSEARCH: built-in circular radius query. S2 Cells: better for covering queries (find cells that cover a circle). GeoHash edge case: nearby points across hash boundary might not share prefix." },
    { "type": "design", "question": "Design the ETA prediction system.", "answer": "Layers: (1) Simple: Euclidean distance / avg_speed. (2) Road routing: A* on road graph. (3) Traffic-aware: speed per road segment (from recent driver traces). (4) ML correction: model trained on historical trips. Features: origin, dest, time, day, weather, events. Target: actual trip duration. Ensemble: routing_ETA × ML_correction_factor. Update: real-time traffic data refreshed every 2 minutes." },
    { "type": "estimation", "question": "City with 100K active drivers. Geospatial index query: find drivers within 3km. How fast?", "answer": "Redis GEOSEARCH: O(log N + M) where N = total entries, M = results. log(100K) ≈ 17 operations. Within 3km in busy area: ~50-200 results. Total: microseconds. Even with 1M entries: log(1M) ≈ 20. Practically: <1ms for geo query. Bottleneck is network round-trip to Redis (~0.5ms), not the query itself. Can handle 100K+ geo queries/sec per Redis instance." },
    { "type": "debug", "question": "Riders report being matched with drivers 10km away even when closer drivers are available. What's wrong?", "answer": "1) Stale location: driver location not updated (GPS failure, poor signal). Fix: evict drivers with updates older than 30s. 2) Race condition: multiple riders matched to same 'nearest' driver simultaneously. Fix: atomic assignment (lock driver on match). 3) Index not updated: Kafka consumer lag. Fix: monitor consumer lag, scale consumers. 4) GeoHash boundary: adjacent drivers in different hash cell. Fix: query neighboring cells too." },
    { "type": "design", "question": "Design the ride-sharing (pool) matching system.", "answer": "When rider selects pool: find existing trips going in same direction. Criteria: (1) Detour < 30% of original route. (2) ETA increase for existing rider < 5 min. (3) Pickup point within 500m of existing route. Algorithm: for each active pool trip, compute: new_route = current_route + new_pickup + new_dropoff. If detour_ratio < 0.3 → match. Fare: split proportionally by distance. Capacity: max 3 riders per pool." },
    { "type": "scenario", "question": "Driver's app crashes mid-trip. How does the system handle it?", "answer": "1) Heartbeat detection: if no driver GPS update for 60s → alert. 2) Trip state persisted in DB (not in-memory) → survives app restart. 3) Driver reopens app → fetches active trip → resumes. 4) If driver unreachable for 5 min → notify rider. 5) Safety: trigger safety check. 6) Billing: use last known position + estimated remaining distance. 7) If driver can't resume → dispatch new driver to rider's last known location." },
    { "type": "output", "question": "3 riders request rides. 2 drivers available. Driver A is 1km from Rider 1 and 3km from Rider 2. Driver B is 2km from Rider 1 and 1km from Rider 2. What's the optimal assignment?", "answer": "Greedy: assign Driver A → Rider 1 (1km), Driver B → Rider 2 (1km). Total: 2km. Optimal (Hungarian): same result in this case. Alternative: Driver A → Rider 2 (3km), Driver B → Rider 1 (2km). Total: 5km — worse. Rider 3: no driver available → queue. Result: A→R1(1km), B→R2(1km), R3 waits. Total distance minimized." }
  ],
  "programExercises": [
    {
      "question": "Program 1: Haversine distance calculator",
      "code": "function haversine(lat1, lng1, lat2, lng2) {\n  const R = 6371; // Earth radius in km\n  const toRad = deg => deg * Math.PI / 180;\n  const dLat = toRad(lat2 - lat1);\n  const dLng = toRad(lng2 - lng1);\n  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng/2)**2;\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n  return parseFloat((R * c).toFixed(2));\n}\n\nconsole.log('Mumbai to Pune:', haversine(19.0760, 72.8777, 18.5204, 73.8567), 'km');\nconsole.log('Delhi to Noida:', haversine(28.7041, 77.1025, 28.5355, 77.3910), 'km');\nconsole.log('Same point:', haversine(12.97, 77.59, 12.97, 77.59), 'km');",
      "output": "Mumbai to Pune: 118.19 km\nDelhi to Noida: 33.05 km\nSame point: 0 km"
    },
    {
      "question": "Program 2: GeoHash encoder/decoder (simplified)",
      "code": "function encodeGeoHash(lat, lng, precision = 6) {\n  const chars = '0123456789bcdefghjkmnpqrstuvwxyz';\n  let minLat = -90, maxLat = 90, minLng = -180, maxLng = 180;\n  let hash = '', bit = 0, ch = 0, isLng = true;\n  while (hash.length < precision) {\n    if (isLng) {\n      const mid = (minLng + maxLng) / 2;\n      if (lng >= mid) { ch |= (1 << (4 - bit)); minLng = mid; } else maxLng = mid;\n    } else {\n      const mid = (minLat + maxLat) / 2;\n      if (lat >= mid) { ch |= (1 << (4 - bit)); minLat = mid; } else maxLat = mid;\n    }\n    isLng = !isLng;\n    if (++bit === 5) { hash += chars[ch]; bit = 0; ch = 0; }\n  }\n  return hash;\n}\n\nconst locations = [\n  { name: 'Bangalore', lat: 12.9716, lng: 77.5946 },\n  { name: 'Nearby BLR', lat: 12.9750, lng: 77.5960 },\n  { name: 'Mumbai', lat: 19.0760, lng: 72.8777 },\n];\n\nlocations.forEach(l => {\n  const hash = encodeGeoHash(l.lat, l.lng);\n  console.log(`${l.name}: ${hash}`);\n});\nconsole.log('Notice: nearby points share prefix!');",
      "output": "Bangalore: tdr1wz\nNearby BLR: tdr1x0\nMumbai: te7ud2\nNotice: nearby points share prefix!"
    },
    {
      "question": "Program 3: Driver pool with geospatial search",
      "code": "class DriverPool {\n  constructor() { this.drivers = new Map(); }\n  addDriver(id, lat, lng, type = 'sedan') {\n    this.drivers.set(id, { id, lat, lng, type, available: true });\n  }\n  setAvailable(id, available) {\n    const d = this.drivers.get(id);\n    if (d) d.available = available;\n  }\n  distance(lat1, lng1, lat2, lng2) {\n    const R = 6371;\n    const dLat = (lat2-lat1)*Math.PI/180, dLng = (lng2-lng1)*Math.PI/180;\n    const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLng/2)**2;\n    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n  }\n  findNearby(lat, lng, radiusKm, type = null) {\n    return [...this.drivers.values()]\n      .filter(d => d.available && (!type || d.type === type))\n      .map(d => ({ ...d, dist: parseFloat(this.distance(lat, lng, d.lat, d.lng).toFixed(2)) }))\n      .filter(d => d.dist <= radiusKm)\n      .sort((a, b) => a.dist - b.dist);\n  }\n}\n\nconst pool = new DriverPool();\npool.addDriver('D1', 12.971, 77.594);\npool.addDriver('D2', 12.980, 77.590);\npool.addDriver('D3', 12.960, 77.610);\npool.addDriver('D4', 13.020, 77.560, 'suv');\npool.setAvailable('D3', false);\n\nconsole.log('Nearby sedans:', pool.findNearby(12.975, 77.595, 3, 'sedan'));\nconsole.log('All nearby:', pool.findNearby(12.975, 77.595, 10));",
      "output": "Nearby sedans: [\n  { id: 'D1', ..., dist: 0.45 },\n  { id: 'D2', ..., dist: 0.73 }\n]\nAll nearby: [\n  { id: 'D1', ..., dist: 0.45 },\n  { id: 'D2', ..., dist: 0.73 },\n  { id: 'D4', ..., dist: 5.93 }\n]"
    },
    {
      "question": "Program 4: Trip state machine",
      "code": "class TripStateMachine {\n  constructor() {\n    this.transitions = {\n      REQUESTED: ['MATCHING'],\n      MATCHING: ['DRIVER_ASSIGNED', 'CANCELLED'],\n      DRIVER_ASSIGNED: ['DRIVER_ENROUTE', 'CANCELLED'],\n      DRIVER_ENROUTE: ['ARRIVED', 'CANCELLED'],\n      ARRIVED: ['TRIP_STARTED', 'CANCELLED'],\n      TRIP_STARTED: ['COMPLETED'],\n      COMPLETED: ['PAYMENT_PROCESSED'],\n      CANCELLED: [],\n      PAYMENT_PROCESSED: [],\n    };\n    this.trips = new Map();\n  }\n  create(tripId) {\n    this.trips.set(tripId, { id: tripId, state: 'REQUESTED', history: [{ state: 'REQUESTED', at: Date.now() }] });\n    return this.trips.get(tripId);\n  }\n  transition(tripId, newState) {\n    const trip = this.trips.get(tripId);\n    if (!trip) return { error: 'Trip not found' };\n    const allowed = this.transitions[trip.state];\n    if (!allowed?.includes(newState)) {\n      return { error: `Cannot transition from ${trip.state} to ${newState}` };\n    }\n    trip.state = newState;\n    trip.history.push({ state: newState, at: Date.now() });\n    return { tripId, state: newState, transitions: trip.history.length };\n  }\n}\n\nconst tsm = new TripStateMachine();\ntsm.create('T1');\nconsole.log(tsm.transition('T1', 'MATCHING'));\nconsole.log(tsm.transition('T1', 'DRIVER_ASSIGNED'));\nconsole.log(tsm.transition('T1', 'COMPLETED')); // invalid\nconsole.log(tsm.transition('T1', 'DRIVER_ENROUTE'));",
      "output": "{ tripId: 'T1', state: 'MATCHING', transitions: 2 }\n{ tripId: 'T1', state: 'DRIVER_ASSIGNED', transitions: 3 }\n{ error: 'Cannot transition from DRIVER_ASSIGNED to COMPLETED' }\n{ tripId: 'T1', state: 'DRIVER_ENROUTE', transitions: 4 }"
    },
    {
      "question": "Program 5: Surge pricing calculator with zones",
      "code": "class SurgeCalculator {\n  constructor() { this.zones = new Map(); }\n  update(zoneId, drivers, requests) {\n    this.zones.set(zoneId, { drivers, requests, updated: Date.now() });\n  }\n  getMultiplier(zoneId) {\n    const z = this.zones.get(zoneId);\n    if (!z) return 1.0;\n    if (z.drivers === 0) return 5.0; // max surge\n    const ratio = z.requests / z.drivers;\n    if (ratio <= 1.0) return 1.0;\n    if (ratio <= 1.5) return 1.2;\n    if (ratio <= 2.0) return 1.5;\n    if (ratio <= 3.0) return 2.0;\n    return Math.min(ratio * 0.7, 5.0);\n  }\n  fare(zoneId, distKm, baseFare = 30, ratePerKm = 12) {\n    const surge = this.getMultiplier(zoneId);\n    const base = baseFare + distKm * ratePerKm;\n    return { base: base.toFixed(0), surge, total: (base * surge).toFixed(0) };\n  }\n  allZones() {\n    return [...this.zones.entries()].map(([id, z]) => ({\n      zone: id, drivers: z.drivers, requests: z.requests, surge: this.getMultiplier(id),\n    }));\n  }\n}\n\nconst sc = new SurgeCalculator();\nsc.update('koramangala', 20, 10);   // balanced\nsc.update('indiranagar', 5, 25);    // high demand\nsc.update('whitefield', 30, 15);    // oversupply\nsc.update('airport', 2, 0);         // ghost town\n\nconsole.log(sc.allZones());\nconsole.log('Fare indiranagar 8km:', sc.fare('indiranagar', 8));\nconsole.log('Fare whitefield 8km:', sc.fare('whitefield', 8));",
      "output": "[\n  { zone: 'koramangala', drivers: 20, requests: 10, surge: 1 },\n  { zone: 'indiranagar', drivers: 5, requests: 25, surge: 3.5 },\n  { zone: 'whitefield', drivers: 30, requests: 15, surge: 1 },\n  { zone: 'airport', drivers: 2, requests: 0, surge: 1 }\n]\nFare indiranagar 8km: { base: '126', surge: 3.5, total: '441' }\nFare whitefield 8km: { base: '126', surge: 1, total: '126' }"
    },
    {
      "question": "Program 6: ETA calculator with speed model",
      "code": "class ETACalculator {\n  constructor() { this.speedModels = new Map(); }\n  setSpeedModel(timeSlot, avgSpeedKmh) {\n    this.speedModels.set(timeSlot, avgSpeedKmh);\n  }\n  getSpeed(hour) {\n    if (hour >= 8 && hour <= 10) return this.speedModels.get('morning_rush') || 15;\n    if (hour >= 17 && hour <= 20) return this.speedModels.get('evening_rush') || 12;\n    if (hour >= 22 || hour < 6) return this.speedModels.get('night') || 40;\n    return this.speedModels.get('normal') || 25;\n  }\n  calculate(distKm, hour) {\n    const speed = this.getSpeed(hour);\n    const minutes = (distKm / speed) * 60;\n    return { distKm, speedKmh: speed, etaMinutes: parseFloat(minutes.toFixed(1)) };\n  }\n}\n\nconst eta = new ETACalculator();\neta.setSpeedModel('morning_rush', 15);\neta.setSpeedModel('evening_rush', 12);\neta.setSpeedModel('night', 45);\neta.setSpeedModel('normal', 28);\n\nconsole.log('5km at 9am:', eta.calculate(5, 9));\nconsole.log('5km at 6pm:', eta.calculate(5, 18));\nconsole.log('5km at 2pm:', eta.calculate(5, 14));\nconsole.log('5km at 11pm:', eta.calculate(5, 23));",
      "output": "5km at 9am: { distKm: 5, speedKmh: 15, etaMinutes: 20 }\n5km at 6pm: { distKm: 5, speedKmh: 12, etaMinutes: 25 }\n5km at 2pm: { distKm: 5, speedKmh: 28, etaMinutes: 10.7 }\n5km at 11pm: { distKm: 5, speedKmh: 45, etaMinutes: 6.7 }"
    },
    {
      "question": "Program 7: Ride matching with batch optimization",
      "code": "class BatchMatcher {\n  constructor() { this.riders = []; this.drivers = []; }\n  addRider(id, lat, lng) { this.riders.push({ id, lat, lng }); }\n  addDriver(id, lat, lng) { this.drivers.push({ id, lat, lng }); }\n  distance(a, b) {\n    return parseFloat(Math.sqrt((a.lat-b.lat)**2 + (a.lng-b.lng)**2).toFixed(4));\n  }\n  // Greedy: assign nearest driver to each rider\n  matchGreedy() {\n    const available = new Set(this.drivers.map(d => d.id));\n    const matches = [];\n    const sortedRiders = [...this.riders];\n\n    for (const rider of sortedRiders) {\n      let best = null, bestDist = Infinity;\n      for (const driver of this.drivers) {\n        if (!available.has(driver.id)) continue;\n        const d = this.distance(rider, driver);\n        if (d < bestDist) { best = driver; bestDist = d; }\n      }\n      if (best) {\n        matches.push({ rider: rider.id, driver: best.id, distance: bestDist });\n        available.delete(best.id);\n      } else {\n        matches.push({ rider: rider.id, driver: null, distance: null });\n      }\n    }\n    const totalDist = matches.reduce((s, m) => s + (m.distance || 0), 0);\n    return { matches, totalDistance: parseFloat(totalDist.toFixed(4)) };\n  }\n}\n\nconst bm = new BatchMatcher();\nbm.addRider('R1', 0, 0); bm.addRider('R2', 1, 1); bm.addRider('R3', 2, 2);\nbm.addDriver('D1', 0.1, 0.1); bm.addDriver('D2', 1.9, 2.1);\nconsole.log(bm.matchGreedy());",
      "output": "{\n  matches: [\n    { rider: 'R1', driver: 'D1', distance: 0.1414 },\n    { rider: 'R2', driver: 'D2', distance: 1.3454 },\n    { rider: 'R3', driver: null, distance: null }\n  ],\n  totalDistance: 1.4868\n}"
    },
    {
      "question": "Program 8: Fare calculator with distance and time",
      "code": "class FareCalculator {\n  constructor(config) {\n    this.baseFare = config.baseFare;\n    this.perKm = config.perKm;\n    this.perMin = config.perMin;\n    this.minFare = config.minFare;\n    this.surgeCap = config.surgeCap || 5;\n  }\n  calculate(distKm, durationMin, surgeMultiplier = 1.0) {\n    const surge = Math.min(surgeMultiplier, this.surgeCap);\n    const distCharge = distKm * this.perKm;\n    const timeCharge = durationMin * this.perMin;\n    const subtotal = this.baseFare + distCharge + timeCharge;\n    const total = Math.max(subtotal * surge, this.minFare);\n    return {\n      breakdown: { base: this.baseFare, distance: parseFloat(distCharge.toFixed(2)), time: parseFloat(timeCharge.toFixed(2)) },\n      subtotal: parseFloat(subtotal.toFixed(2)),\n      surge,\n      total: parseFloat(total.toFixed(2)),\n    };\n  }\n}\n\nconst uber = new FareCalculator({ baseFare: 40, perKm: 12, perMin: 2, minFare: 50, surgeCap: 5 });\nconsole.log('Short trip:', uber.calculate(3, 10));\nconsole.log('Long trip:', uber.calculate(15, 40, 1.5));\nconsole.log('Surge trip:', uber.calculate(5, 15, 3.0));",
      "output": "Short trip: { breakdown: { base: 40, distance: 36, time: 20 }, subtotal: 96, surge: 1, total: 96 }\nLong trip: { breakdown: { base: 40, distance: 180, time: 80 }, subtotal: 300, surge: 1.5, total: 450 }\nSurge trip: { breakdown: { base: 40, distance: 60, time: 30 }, subtotal: 130, surge: 3, total: 390 }"
    },
    {
      "question": "Program 9: Ride-share pool matching",
      "code": "class PoolMatcher {\n  constructor(maxDetourRatio) { this.maxDetour = maxDetourRatio; this.activeTrips = []; }\n  dist(a, b) { return Math.sqrt((a.lat-b.lat)**2 + (a.lng-b.lng)**2); }\n  routeLength(points) {\n    let d = 0;\n    for (let i = 1; i < points.length; i++) d += this.dist(points[i-1], points[i]);\n    return d;\n  }\n  addTrip(id, pickup, dropoff) {\n    this.activeTrips.push({ id, pickup, dropoff, riders: [id] });\n  }\n  findPool(newPickup, newDropoff) {\n    for (const trip of this.activeTrips) {\n      const originalLen = this.dist(trip.pickup, trip.dropoff);\n      const detourLen = this.routeLength([trip.pickup, newPickup, newDropoff, trip.dropoff]);\n      const detourRatio = detourLen / originalLen - 1;\n      if (detourRatio <= this.maxDetour) {\n        return {\n          matched: true,\n          tripId: trip.id,\n          detour: (detourRatio * 100).toFixed(1) + '%',\n          originalRoute: parseFloat(originalLen.toFixed(2)),\n          newRoute: parseFloat(detourLen.toFixed(2)),\n        };\n      }\n    }\n    return { matched: false, reason: 'No suitable pool found' };\n  }\n}\n\nconst pm = new PoolMatcher(0.3); // max 30% detour\npm.addTrip('T1', { lat: 0, lng: 0 }, { lat: 10, lng: 0 }); // straight north\n\nconsole.log('Nearby rider:', pm.findPool({ lat: 2, lng: 1 }, { lat: 8, lng: 0 }));\nconsole.log('Far rider:', pm.findPool({ lat: 5, lng: 5 }, { lat: 8, lng: 8 }));",
      "output": "Nearby rider: { matched: true, tripId: 'T1', detour: '12.8%', originalRoute: 10, newRoute: 11.28 }\nFar rider: { matched: false, reason: 'No suitable pool found' }"
    },
    {
      "question": "Program 10: Driver rating and priority system",
      "code": "class DriverRating {\n  constructor() { this.drivers = new Map(); }\n  register(id) {\n    this.drivers.set(id, { id, ratings: [], acceptanceRate: 1.0, trips: 0, cancellations: 0 });\n  }\n  rate(driverId, rating) {\n    const d = this.drivers.get(driverId);\n    if (!d) return;\n    d.ratings.push(rating);\n    d.trips++;\n  }\n  cancel(driverId) {\n    const d = this.drivers.get(driverId);\n    if (!d) return;\n    d.cancellations++;\n    d.acceptanceRate = 1 - (d.cancellations / (d.trips + d.cancellations));\n  }\n  getScore(driverId) {\n    const d = this.drivers.get(driverId);\n    if (!d || d.ratings.length === 0) return null;\n    const avgRating = d.ratings.reduce((a,b) => a+b, 0) / d.ratings.length;\n    const priority = avgRating * 0.6 + d.acceptanceRate * 5 * 0.4;\n    return {\n      id: d.id,\n      avgRating: parseFloat(avgRating.toFixed(2)),\n      acceptanceRate: parseFloat(d.acceptanceRate.toFixed(2)),\n      trips: d.trips,\n      priorityScore: parseFloat(priority.toFixed(2)),\n    };\n  }\n  rankings() {\n    return [...this.drivers.keys()].map(id => this.getScore(id)).filter(Boolean).sort((a,b) => b.priorityScore - a.priorityScore);\n  }\n}\n\nconst dr = new DriverRating();\ndr.register('D1'); dr.register('D2'); dr.register('D3');\n// D1: great driver\n[5,5,4,5,5].forEach(r => dr.rate('D1', r));\n// D2: average with cancellations\n[4,3,4,3].forEach(r => dr.rate('D2', r));\ndr.cancel('D2'); dr.cancel('D2');\n// D3: new driver\n[5,4].forEach(r => dr.rate('D3', r));\n\nconsole.log(dr.rankings());",
      "output": "[\n  { id: 'D1', avgRating: 4.8, acceptanceRate: 1, priorityScore: 4.88 },\n  { id: 'D3', avgRating: 4.5, acceptanceRate: 1, priorityScore: 4.7 },\n  { id: 'D2', avgRating: 3.5, acceptanceRate: 0.67, priorityScore: 3.44 }\n]"
    }
  ]
}