{
  "id": "promises",
  "title": "Promises",
  "description": "Promises represent the eventual completion or failure of an asynchronous operation. They provide a cleaner way to handle async code compared to callbacks, avoiding callback hell.",
  "explanation": "A Promise is an object representing the eventual completion or failure of an asynchronous operation. It's a proxy for a value not necessarily known when the promise is created.\n\nPromise States:\n1. Pending: Initial state, neither fulfilled nor rejected\n2. Fulfilled: Operation completed successfully\n3. Rejected: Operation failed\n\nPromises solve the callback hell problem by allowing you to chain operations using .then() and handle errors with .catch().\n\nKey advantages:\n- Better error handling with .catch()\n- Chainable operations with .then()\n- Multiple promises with Promise.all()\n- Race conditions with Promise.race()\n- Cleaner, more readable code",
  "implementation": "const promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    const success = true;\n    if (success) {\n      resolve('Operation successful!');\n    } else {\n      reject('Operation failed!');\n    }\n  }, 1000);\n});\n\npromise\n  .then(result => console.log(result))\n  .catch(error => console.error(error))\n  .finally(() => console.log('Done'));",
  "example": "// API call example\nfunction fetchUser(userId) {\n  return fetch(`/api/users/${userId}`)\n    .then(response => {\n      if (!response.ok) {\n        throw new Error('User not found');\n      }\n      return response.json();\n    });\n}\n\n// Chaining promises\nfetchUser(1)\n  .then(user => {\n    console.log('User:', user);\n    return fetchUserPosts(user.id);\n  })\n  .then(posts => {\n    console.log('Posts:', posts);\n  })\n  .catch(error => {\n    console.error('Error:', error);\n  });",
  "useCase": "API calls, file operations, timers, async operations, chaining async tasks",
  "interviewQuestions": [
    {
      "question": "What are Promise states?",
      "answer": "pending, fulfilled, rejected. State is immutable after settle."
    },
    {
      "question": "How does .catch propagate in chains?",
      "answer": "It catches rejections from previous links and can recover by returning value/promise."
    },
    {
      "question": "Difference between then(onFulfilled, onRejected) and catch?",
      "answer": "catch is preferred for centralized error flow and readability."
    },
    {
      "question": "How do you wrap callback APIs in Promise?",
      "answer": "Create new Promise and call resolve/reject from callback branches."
    },
    {
      "question": "What is an anti-pattern with promises?",
      "answer": "Nesting chains instead of returning promises, which breaks composition."
    },
    {
      "question": "What is the Promise constructor anti-pattern?",
      "answer": "Wrapping an already-promise-returning function in new Promise(). Example: new Promise((resolve) => fetch(url).then(resolve)) — just use fetch(url) directly. Extra wrapping adds overhead and can swallow errors."
    },
    {
      "question": "What is the difference between Promise.resolve() and new Promise(resolve => resolve())?",
      "answer": "Promise.resolve(value) returns an already-resolved promise synchronously. new Promise(resolve => resolve(value)) creates a new promise that resolves on the next microtask. Promise.resolve is more efficient for wrapping known values."
    },
    {
      "question": "Can a Promise be cancelled?",
      "answer": "No, native Promises cannot be cancelled. Once started, they will settle. Use AbortController with fetch for cancellable network requests, or use a cancellation token pattern for custom promises."
    },
    {
      "question": "What happens if you resolve a Promise with another Promise?",
      "answer": "The outer promise 'follows' the inner promise — it adopts the state and value of the inner promise. resolve(anotherPromise) waits for anotherPromise to settle. reject() does NOT unwrap — it rejects with whatever value is given."
    },
    {
      "question": "How does .finally() work and when should you use it?",
      "answer": ".finally(callback) runs after the promise settles (fulfilled or rejected), without receiving the value/reason. It passes through the original result. Use for cleanup: closing connections, hiding loaders, logging. Similar to try-catch-finally."
    }
  ],
  "exercises": [
    {
      "type": "output",
      "question": "Predict output order: Promise.resolve().then(()=>console.log(\"A\")); console.log(\"B\");",
      "answer": "B then A",
      "output": "B\nA"
    },
    {
      "type": "implement",
      "question": "Wrap setTimeout in delay(ms) returning Promise.",
      "code": "function delay(ms){\n  return new Promise(resolve => setTimeout(resolve, ms));\n}"
    },
    {
      "type": "debug",
      "question": "Promise chain stops after then. Cause?",
      "answer": "Likely forgot return in then callback, breaking chain value flow."
    },
    {
      "type": "scenario",
      "question": "Need retry API promise 3 times. What structure?",
      "answer": "Use recursive/loop retry wrapper that catches failure and retries until max attempts."
    },
    {
      "type": "output",
      "question": "Predict output: Promise.reject(\"X\").catch(e=>e+\"!\").then(console.log)",
      "answer": "X!",
      "output": "X!"
    },
    {
      "type": "implement",
      "question": "Implement a promisified version of fs.readFile.",
      "code": "function readFileAsync(path) { return new Promise((resolve, reject) => { fs.readFile(path, 'utf8', (err, data) => err ? reject(err) : resolve(data)); }); }"
    },
    {
      "type": "implement",
      "question": "Create a Promise that resolves with a value after validating it, or rejects.",
      "code": "function validateAsync(value) { return new Promise((resolve, reject) => { if(value > 0) resolve(value); else reject('Invalid value'); }); }"
    },
    {
      "type": "debug",
      "question": "Promise.resolve().then(() => { throw 'error' }).then(v => console.log(v)); — why is 'error' never caught?",
      "answer": "There's no .catch() in the chain. The thrown error creates a rejected promise that is unhandled. Add .catch(e => console.error(e)) at the end."
    },
    {
      "type": "debug",
      "question": "Unhandled rejection appears even with catch in another function. Why?",
      "answer": "The rejected promise path was not returned/awaited in caller chain."
    },
    {
      "type": "refactor",
      "question": "Refactor nested then callbacks to flat chain with proper returns."
    }
  ],
  "programExercises": [
    {
      "type": "program",
      "question": "Program 1: Create resolved promise and print value.",
      "code": "Promise.resolve(\"Done\").then(console.log);",
      "output": "Done"
    },
    {
      "type": "program",
      "question": "Program 2: Create rejected promise and handle with catch.",
      "code": "Promise.reject(\"Fail\").catch(err=>console.log(\"Handled:\",err));",
      "output": "Handled: Fail"
    },
    {
      "type": "program",
      "question": "Program 3: Implement delay promise and await result.",
      "code": "const delay=ms=>new Promise(r=>setTimeout(r,ms));\ndelay(100).then(()=>console.log(\"After 100ms\"));",
      "output": "After 100ms"
    },
    {
      "type": "program",
      "question": "Program 4: Chain promises for arithmetic operations.",
      "code": "Promise.resolve(5)\n .then(n=>n*2)\n .then(n=>n+1)\n .then(console.log);",
      "output": "11"
    },
    {
      "type": "program",
      "question": "Program 5: Demonstrate finally in promise chain.",
      "code": "Promise.resolve(\"ok\")\n .then(v=>console.log(v))\n .finally(()=>console.log(\"cleanup\"));",
      "output": "ok\ncleanup"
    },
    {
      "type": "program",
      "question": "Program 6: Wrap setTimeout in Promise function.",
      "code": "function wait(msg,ms){\n  return new Promise(res=>setTimeout(()=>res(msg),ms));\n}\nwait(\"hello\",50).then(console.log);",
      "output": "hello"
    },
    {
      "type": "program",
      "question": "Program 7: Promise.all with two resolved promises.",
      "code": "Promise.all([Promise.resolve(1), Promise.resolve(2)])\n .then(v=>console.log(v));",
      "output": "[ 1, 2 ]"
    },
    {
      "type": "program",
      "question": "Program 8: Promise.race timeout example.",
      "code": "const fast=Promise.resolve(\"fast\");\nconst slow=new Promise(r=>setTimeout(()=>r(\"slow\"),100));\nPromise.race([fast,slow]).then(console.log);",
      "output": "fast"
    },
    {
      "type": "program",
      "question": "Program 9: Convert callback API to Promise.",
      "code": "function asyncDouble(n){\n  return new Promise(res=>setTimeout(()=>res(n*2),50));\n}\nasyncDouble(6).then(console.log);",
      "output": "12"
    },
    {
      "type": "program",
      "question": "Program 10: Handle thrown error in then chain.",
      "code": "Promise.resolve(1)\n .then(()=>{throw new Error(\"boom\")})\n .catch(e=>console.log(e.message));",
      "output": "boom"
    }
  ],
  "category": "Core Concepts"
}
