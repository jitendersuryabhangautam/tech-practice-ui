{
  "id": "javascript-practice-150",
  "title": "JavaScript Practice Hub (150+ Exercises)",
  "description": "A cross-topic JavaScript practice bank with output prediction, implementation, and debugging exercises spanning closures, async, prototypes, coercion, and more.",
  "explanation": "This section combines exercises from multiple JavaScript topics into a mixed practice format. Unlike individual topic pages that focus on one concept, these exercises require you to identify which concept is being tested and apply the right knowledge. This simulates real interview conditions where questions jump between topics.\n\nRecommended workflow:\n1. Pick 10 exercises at random\n2. Time yourself (3-5 min per exercise)\n3. Explain your reasoning out loud (interview practice)\n4. Review wrong answers by visiting the relevant topic page\n5. Re-attempt after 24 hours for spaced repetition",
  "implementation": "// Suggested workflow\n// 1) Pick 10 exercises by mixed types\n// 2) Solve with time limit (5-10 min each)\n// 3) Re-solve missed ones without notes\n// 4) Convert best solutions to reusable utilities",
  "example": "// Quick warm-up\nconst arr = [1, 2, 3, 4, 5];\nconst evens = arr.filter(n => n % 2 === 0);\nconst doubled = evens.map(n => n * 2);\nconsole.log(doubled); // [4, 8]",
  "useCase": "Interview preparation, frontend screening rounds, DSA-lite JavaScript practice, and core language mastery.",
  "category": "Complete Practice Guide",
  "interviewQuestions": [
    {
      "question": "How do you choose between map, filter, and reduce?",
      "answer": "Map transforms one-to-one, filter selects subset, reduce accumulates to a single value/structure."
    },
    {
      "question": "What causes most async JavaScript bugs in interviews?",
      "answer": "Not understanding event-loop ordering, missing await, and uncaught promise rejections."
    },
    {
      "question": "When is mutation acceptable in JavaScript code?",
      "answer": "When intentional and localized for performance-critical paths, but immutable style is safer by default."
    },
    {
      "question": "How do you debug closure-related issues?",
      "answer": "Trace lexical scope and captured variables, especially inside loops, timers, and listeners."
    },
    {
      "question": "What is a practical strategy for output prediction questions?",
      "answer": "Evaluate synchronous phase first, then microtasks, then macrotasks."
    }
  ],
  "exercises": [
    {
      "type": "output",
      "question": "What is the output?\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 0);\n}",
      "answer": "3, 3, 3 â€” var is function-scoped, all callbacks share the same i which is 3 after the loop"
    },
    {
      "type": "output",
      "question": "What is the output?\nconsole.log(typeof null);\nconsole.log(typeof undefined);\nconsole.log(null == undefined);\nconsole.log(null === undefined);",
      "answer": "object, undefined, true, false â€” typeof null is a historical bug. null loosely equals undefined."
    },
    {
      "type": "output",
      "question": "What is the output?\nconst a = { x: 1 };\nconst b = { x: 1 };\nconsole.log(a === b);\nconsole.log(a == b);",
      "answer": "false, false â€” Objects are compared by reference, not by value. a and b are different objects."
    },
    {
      "type": "output",
      "question": "What is the output?\nconsole.log(1 + '2' + 3);\nconsole.log(1 + 2 + '3');",
      "answer": "'123', '33' â€” First: 1+'2'='12', '12'+3='123'. Second: 1+2=3, 3+'3'='33'."
    },
    {
      "type": "output",
      "question": "What is the output?\nfunction foo() {\n  console.log(this);\n}\nconst obj = { foo };\nobj.foo();\nconst fn = obj.foo;\nfn();",
      "answer": "obj (implicit binding), then undefined in strict mode / window in non-strict (lost binding when assigned to variable)"
    },
    {
      "type": "output",
      "question": "What is the output?\nconsole.log('start');\nsetTimeout(() => console.log('timeout'), 0);\nPromise.resolve().then(() => console.log('promise'));\nconsole.log('end');",
      "answer": "start, end, promise, timeout â€” Sync first, then microtasks (promise), then macrotasks (setTimeout)"
    },
    {
      "type": "output",
      "question": "What is the output?\nconst arr = [1, 2, 3];\narr[10] = 11;\nconsole.log(arr.length);\nconsole.log(arr.filter(x => x).length);",
      "answer": "11, 4 â€” Array length is 11 (sparse). filter skips empty slots, so only 4 elements: 1,2,3,11"
    },
    {
      "type": "output",
      "question": "What is the output?\nlet x = 10;\nlet y = x;\nx = 20;\nconsole.log(x, y);",
      "answer": "20, 10 â€” Primitives are copied by value. Changing x doesn't affect y."
    },
    {
      "type": "output",
      "question": "What is the output?\nconst obj = { a: 1, b: 2 };\nconst { a: x, b: y } = obj;\nconsole.log(x, y);",
      "answer": "1, 2 â€” Destructuring with renaming: a is renamed to x, b to y."
    },
    {
      "type": "output",
      "question": "What is the output?\n[] + [];\n[] + {};\n{} + [];",
      "answer": "'' (empty string), '[object Object]', '[object Object]' â€” Arrays/objects convert via toString for + operator"
    },
    {
      "type": "output",
      "question": "What is the output?\nconst promise = new Promise((resolve) => {\n  console.log('A');\n  resolve();\n  console.log('B');\n});\npromise.then(() => console.log('C'));\nconsole.log('D');",
      "answer": "A, B, D, C â€” Promise executor runs synchronously. resolve() doesn't stop execution. .then is a microtask."
    },
    {
      "type": "output",
      "question": "What is the output?\nfunction createCounter() {\n  let count = 0;\n  return {\n    inc: () => ++count,\n    get: () => count\n  };\n}\nconst c = createCounter();\nc.inc(); c.inc(); c.inc();\nconsole.log(c.get());",
      "answer": "3 â€” Closure captures count by reference. Three inc() calls increment to 3."
    },
    {
      "type": "output",
      "question": "What is the output?\nconsole.log(0.1 + 0.2 === 0.3);\nconsole.log(0.1 + 0.2);",
      "answer": "false, 0.30000000000000004 â€” IEEE 754 floating point precision issue"
    },
    {
      "type": "output",
      "question": "What is the output?\nconst arr = [1, 2, 3, 4, 5];\nconst [a, , b, ...rest] = arr;\nconsole.log(a, b, rest);",
      "answer": "1, 3, [4, 5] â€” Destructuring: a=1, skip 2, b=3, rest collects remaining"
    },
    {
      "type": "output",
      "question": "What is the output?\nasync function test() {\n  return 1;\n}\nconsole.log(test());\nconsole.log(await test());",
      "answer": "Promise { 1 }, then 1 â€” async always returns Promise. await unwraps it."
    },
    {
      "type": "output",
      "question": "What is the output?\nclass Animal {\n  constructor(name) { this.name = name; }\n  speak() { return `${this.name} speaks`; }\n}\nclass Dog extends Animal {\n  speak() { return `${this.name} barks`; }\n}\nconsole.log(new Dog('Rex').speak());\nconsole.log(new Dog('Rex') instanceof Animal);",
      "answer": "Rex barks, true â€” Dog overrides speak(). instanceof checks prototype chain."
    },
    {
      "type": "output",
      "question": "What is the output?\nconst s = new Set([1, 2, 3, 1, 2]);\nconsole.log(s.size);\ns.add(1);\nconsole.log(s.size);",
      "answer": "3, 3 â€” Set removes duplicates. Adding existing value has no effect."
    },
    {
      "type": "output",
      "question": "What is the output?\nconst m = new Map();\nm.set({}, 'a');\nm.set({}, 'b');\nconsole.log(m.size);",
      "answer": "2 â€” Each {} creates a new object reference, so they're different keys."
    },
    {
      "type": "output",
      "question": "What is the output?\ntry {\n  throw new Error('oops');\n} catch (e) {\n  console.log(e.message);\n} finally {\n  console.log('done');\n}",
      "answer": "oops, done â€” catch handles the error, finally always runs"
    },
    {
      "type": "output",
      "question": "What is the output?\nconsole.log(Boolean(''));\nconsole.log(Boolean('0'));\nconsole.log(Boolean(0));\nconsole.log(Boolean([]));\nconsole.log(Boolean({}));",
      "answer": "false, true, false, true, true â€” '' and 0 are falsy. '0', [], {} are truthy."
    },
    {
      "type": "implement",
      "question": "Implement a debounce function that delays execution until N ms after the last call.",
      "answer": "function debounce(fn, ms) { let timer; return (...args) => { clearTimeout(timer); timer = setTimeout(() => fn(...args), ms); }; }"
    },
    {
      "type": "implement",
      "question": "Implement a function that deep clones an object (handle objects, arrays, dates).",
      "answer": "function deepClone(obj) { if (obj === null || typeof obj !== 'object') return obj; if (obj instanceof Date) return new Date(obj); if (Array.isArray(obj)) return obj.map(deepClone); return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, deepClone(v)])); }"
    },
    {
      "type": "implement",
      "question": "Implement Array.prototype.myMap without using the built-in map.",
      "answer": "Array.prototype.myMap = function(cb) { const result = []; for (let i = 0; i < this.length; i++) { if (i in this) result[i] = cb(this[i], i, this); } return result; }"
    },
    {
      "type": "implement",
      "question": "Implement a pipe function: pipe(fn1, fn2, fn3)(value) applies functions left to right.",
      "answer": "const pipe = (...fns) => (x) => fns.reduce((v, fn) => fn(v), x);"
    },
    {
      "type": "implement",
      "question": "Implement a function that flattens a nested array to any depth.",
      "answer": "function flatten(arr, depth = Infinity) { return depth > 0 ? arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flatten(val, depth - 1) : val), []) : arr.slice(); }"
    },
    {
      "type": "debug",
      "question": "Bug: ['1','2','3'].map(parseInt) returns [1, NaN, NaN] instead of [1, 2, 3]. Why and how to fix?",
      "answer": "parseInt receives (element, index) as arguments: parseInt('2', 1) is NaN (base 1 invalid). Fix: .map(s => parseInt(s, 10)) or .map(Number)"
    },
    {
      "type": "debug",
      "question": "Bug: const obj = {a: 1}; const copy = {...obj}; copy.nested = obj.nested; â€” copy.nested changes when obj.nested changes. Why?",
      "answer": "Spread is a shallow copy. Nested objects share references. Fix: use structuredClone(obj) or JSON parse/stringify for deep copy."
    },
    {
      "type": "debug",
      "question": "Bug: async function fetchAll(urls) { urls.forEach(async url => { await fetch(url); }); console.log('done'); } â€” 'done' logs before fetches complete. Why?",
      "answer": "forEach doesn't await async callbacks â€” it fires all and returns immediately. Fix: use for...of loop or await Promise.all(urls.map(url => fetch(url)))."
    },
    {
      "type": "concept",
      "question": "Explain the difference between == and === with examples.",
      "answer": "=== (strict equality) checks type and value without conversion. == (loose equality) coerces types first. Examples: '5' == 5 is true (string coerced to number), '5' === 5 is false (different types). Best practice: always use === unless checking null/undefined (x == null)."
    },
    {
      "type": "concept",
      "question": "What is the event loop and how does it process tasks?",
      "answer": "The event loop checks: 1) Call stack (synchronous code runs first), 2) Microtask queue (Promise.then, queueMicrotask â€” processed after each task, before rendering), 3) Macrotask queue (setTimeout, setInterval â€” one per tick). Microtasks have higher priority than macrotasks."
    }
  ],
  "programExercises": [
    {
      "type": "program",
      "question": "Implement `promiseAllSettledLimit` with concurrency control.",
      "code": "async function promiseAllSettledLimit(taskFns, limit = 3) {\n  const results = new Array(taskFns.length);\n  let idx = 0;\n\n  async function worker() {\n    while (idx < taskFns.length) {\n      const i = idx++;\n      try {\n        const value = await taskFns[i]();\n        results[i] = { status: 'fulfilled', value };\n      } catch (error) {\n        results[i] = { status: 'rejected', reason: error.message };\n      }\n    }\n  }\n\n  await Promise.all(Array.from({ length: Math.min(limit, taskFns.length) }, worker));\n  return results;\n}\n\nconst wait = (v, ms, fail = false) => () => new Promise((res, rej) => setTimeout(() => fail ? rej(new Error(v)) : res(v), ms));\n(async () => {\n  const out = await promiseAllSettledLimit([wait('A', 30), wait('B', 10, true), wait('C', 5)], 2);\n  console.log(out.map(x => x.status));\n})();",
      "output": "[ 'fulfilled', 'rejected', 'fulfilled' ]",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Build deep equality check supporting objects, arrays, and dates.",
      "code": "function deepEqual(a, b) {\n  if (Object.is(a, b)) return true;\n  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();\n  if (typeof a !== 'object' || typeof b !== 'object' || a === null || b === null) return false;\n  if (Array.isArray(a) !== Array.isArray(b)) return false;\n\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n\n  for (const k of keysA) {\n    if (!keysB.includes(k)) return false;\n    if (!deepEqual(a[k], b[k])) return false;\n  }\n  return true;\n}\n\nconsole.log(\n  deepEqual({ x: [1, { y: 2 }], d: new Date('2026-01-01') }, { x: [1, { y: 2 }], d: new Date('2026-01-01') })\n);",
      "output": "true",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Implement object diff utility (added/removed/changed keys).",
      "code": "function objectDiff(oldObj, newObj) {\n  const added = [];\n  const removed = [];\n  const changed = [];\n\n  for (const k of Object.keys(oldObj)) {\n    if (!(k in newObj)) removed.push(k);\n    else if (JSON.stringify(oldObj[k]) !== JSON.stringify(newObj[k])) changed.push(k);\n  }\n  for (const k of Object.keys(newObj)) {\n    if (!(k in oldObj)) added.push(k);\n  }\n  return { added, removed, changed };\n}\n\nconsole.log(objectDiff(\n  { a: 1, b: 2, c: { x: 1 } },\n  { a: 1, b: 3, d: true, c: { x: 2 } }\n));",
      "output": "{ added: [ 'd' ], removed: [], changed: [ 'b', 'c' ] }",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Build immutable deep update by path (`setIn`).",
      "code": "function setIn(obj, path, value) {\n  const keys = path.split('.');\n  const out = Array.isArray(obj) ? [...obj] : { ...obj };\n  let cur = out;\n  let src = obj;\n\n  for (let i = 0; i < keys.length - 1; i++) {\n    const k = keys[i];\n    const next = src?.[k];\n    cur[k] = Array.isArray(next) ? [...next] : { ...(next || {}) };\n    cur = cur[k];\n    src = next;\n  }\n  cur[keys[keys.length - 1]] = value;\n  return out;\n}\n\nconst state = { user: { profile: { city: 'Austin' } } };\nconst next = setIn(state, 'user.profile.city', 'Dallas');\nconsole.log(state.user.profile.city, next.user.profile.city, state !== next);",
      "output": "Austin Dallas true",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Implement `groupBy` + aggregate pipeline for sales analytics.",
      "code": "function groupBy(arr, keyFn) {\n  return arr.reduce((m, item) => {\n    const k = keyFn(item);\n    if (!m[k]) m[k] = [];\n    m[k].push(item);\n    return m;\n  }, {});\n}\n\nconst sales = [\n  { region: 'US', amount: 120 },\n  { region: 'EU', amount: 80 },\n  { region: 'US', amount: 30 }\n];\n\nconst grouped = groupBy(sales, x => x.region);\nconst totals = Object.fromEntries(Object.entries(grouped).map(([k, v]) => [k, v.reduce((s, x) => s + x.amount, 0)]));\nconsole.log(totals);",
      "output": "{ US: 150, EU: 80 }",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Write robust CSV parser for quoted fields.",
      "code": "function parseCSVLine(line) {\n  const out = [];\n  let cur = '';\n  let inQuotes = false;\n\n  for (let i = 0; i < line.length; i++) {\n    const ch = line[i];\n    if (ch === '\"') {\n      if (inQuotes && line[i + 1] === '\"') {\n        cur += '\"';\n        i++;\n      } else {\n        inQuotes = !inQuotes;\n      }\n    } else if (ch === ',' && !inQuotes) {\n      out.push(cur);\n      cur = '';\n    } else {\n      cur += ch;\n    }\n  }\n  out.push(cur);\n  return out;\n}\n\nconsole.log(parseCSVLine('1,\"Ada, Lovelace\",Engineer'));",
      "output": "[ '1', 'Ada, Lovelace', 'Engineer' ]",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Build mini template engine with `{{key}}` placeholders.",
      "code": "function renderTemplate(template, data) {\n  return template.replace(/{{s*([w.]+)s*}}/g, (_, path) => {\n    const value = path.split('.').reduce((acc, k) => acc?.[k], data);\n    return value == null ? '' : String(value);\n  });\n}\n\nconst t = 'Hello {{user.name}}, order {{order.id}} is {{order.status}}.';\nconsole.log(renderTemplate(t, { user: { name: 'Alice' }, order: { id: 101, status: 'shipped' } }));",
      "output": "Hello Alice, order 101 is shipped.",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Implement topological sort for dependency graph.",
      "code": "function topoSort(graph) {\n  const indeg = new Map();\n  for (const n of Object.keys(graph)) indeg.set(n, 0);\n  for (const deps of Object.values(graph)) for (const d of deps) indeg.set(d, (indeg.get(d) || 0) + 1);\n\n  const q = [...[...indeg.entries()].filter(([, v]) => v === 0).map(([k]) => k)];\n  const out = [];\n\n  while (q.length) {\n    const n = q.shift();\n    out.push(n);\n    for (const d of graph[n] || []) {\n      indeg.set(d, indeg.get(d) - 1);\n      if (indeg.get(d) === 0) q.push(d);\n    }\n  }\n  return out.length === indeg.size ? out : null;\n}\n\nconsole.log(topoSort({ build: ['test'], test: ['lint'], lint: [] }));",
      "output": "[ 'build', 'test', 'lint' ]",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Implement token bucket rate limiter.",
      "code": "class TokenBucket {\n  constructor(capacity, refillPerSec) {\n    this.capacity = capacity;\n    this.tokens = capacity;\n    this.refillPerSec = refillPerSec;\n    this.last = Date.now();\n  }\n  allow(cost = 1) {\n    const now = Date.now();\n    const elapsed = (now - this.last) / 1000;\n    this.tokens = Math.min(this.capacity, this.tokens + elapsed * this.refillPerSec);\n    this.last = now;\n    if (this.tokens >= cost) {\n      this.tokens -= cost;\n      return true;\n    }\n    return false;\n  }\n}\n\nconst bucket = new TokenBucket(2, 1);\nconsole.log(bucket.allow(), bucket.allow(), bucket.allow());",
      "output": "true true false",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Build Trie with insert/search/prefix methods.",
      "code": "class TrieNode {\n  constructor() { this.next = new Map(); this.end = false; }\n}\nclass Trie {\n  constructor() { this.root = new TrieNode(); }\n  insert(word) {\n    let cur = this.root;\n    for (const ch of word) {\n      if (!cur.next.has(ch)) cur.next.set(ch, new TrieNode());\n      cur = cur.next.get(ch);\n    }\n    cur.end = true;\n  }\n  search(word) {\n    let cur = this.root;\n    for (const ch of word) {\n      if (!cur.next.has(ch)) return false;\n      cur = cur.next.get(ch);\n    }\n    return cur.end;\n  }\n  startsWith(prefix) {\n    let cur = this.root;\n    for (const ch of prefix) {\n      if (!cur.next.has(ch)) return false;\n      cur = cur.next.get(ch);\n    }\n    return true;\n  }\n}\n\nconst t = new Trie();\nt.insert('code'); t.insert('coder');\nconsole.log(t.search('code'), t.search('cod'), t.startsWith('cod'));",
      "output": "true false true",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Build undo/redo state manager (command stack).",
      "code": "class HistoryState {\n  constructor(initial) {\n    this.past = [];\n    this.present = initial;\n    this.future = [];\n  }\n  set(next) {\n    this.past.push(this.present);\n    this.present = next;\n    this.future = [];\n  }\n  undo() {\n    if (!this.past.length) return;\n    this.future.push(this.present);\n    this.present = this.past.pop();\n  }\n  redo() {\n    if (!this.future.length) return;\n    this.past.push(this.present);\n    this.present = this.future.pop();\n  }\n}\n\nconst h = new HistoryState(1);\nh.set(2); h.set(3); h.undo(); h.undo(); h.redo();\nconsole.log(h.present);",
      "output": "2",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Implement async queue with pause/resume and worker.",
      "code": "class AsyncQueue {\n  constructor(worker) {\n    this.worker = worker;\n    this.q = [];\n    this.running = false;\n    this.paused = false;\n  }\n  push(item) {\n    this.q.push(item);\n    this.drain();\n  }\n  pause() { this.paused = true; }\n  resume() { this.paused = false; this.drain(); }\n  async drain() {\n    if (this.running || this.paused) return;\n    this.running = true;\n    while (this.q.length && !this.paused) {\n      const item = this.q.shift();\n      await this.worker(item);\n    }\n    this.running = false;\n  }\n}\n\nconst out = [];\nconst aq = new AsyncQueue(async x => { out.push(x * 2); });\naq.push(1); aq.push(2); aq.push(3);\nsetTimeout(() => console.log(out), 10);",
      "output": "[ 2, 4, 6 ]",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Implement paginated fetch iterator over async source.",
      "code": "async function* paginate(fetchPage) {\n  let page = 1;\n  while (true) {\n    const { items, hasNext } = await fetchPage(page);\n    for (const item of items) yield item;\n    if (!hasNext) break;\n    page++;\n  }\n}\n\n(async () => {\n  const source = {\n    1: { items: [1, 2], hasNext: true },\n    2: { items: [3, 4], hasNext: false }\n  };\n  const out = [];\n  for await (const v of paginate(async p => source[p])) out.push(v);\n  console.log(out);\n})();",
      "output": "[ 1, 2, 3, 4 ]",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Build safe JSON parser with validation and defaults.",
      "code": "function parseConfig(input, schema) {\n  let raw;\n  try { raw = JSON.parse(input); } catch { raw = {}; }\n  const out = {};\n  for (const [k, rule] of Object.entries(schema)) {\n    const v = raw[k];\n    if (v == null) out[k] = rule.default;\n    else if (typeof v === rule.type) out[k] = v;\n    else out[k] = rule.default;\n  }\n  return out;\n}\n\nconst schema = { retries: { type: 'number', default: 3 }, mode: { type: 'string', default: 'safe' } };\nconsole.log(parseConfig('{\"retries\":5,\"mode\":\"fast\"}', schema));",
      "output": "{ retries: 5, mode: 'fast' }",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Build binary search over sorted array of objects by key.",
      "code": "function binarySearchBy(arr, key, target) {\n  let l = 0, r = arr.length - 1;\n  while (l <= r) {\n    const m = (l + r) >> 1;\n    if (arr[m][key] === target) return m;\n    if (arr[m][key] < target) l = m + 1;\n    else r = m - 1;\n  }\n  return -1;\n}\n\nconst users = [{ id: 10 }, { id: 20 }, { id: 30 }, { id: 40 }];\nconsole.log(binarySearchBy(users, 'id', 30));",
      "output": "2",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Implement interval scheduler for maximum non-overlap jobs.",
      "code": "function maxNonOverlapping(intervals) {\n  intervals.sort((a, b) => a[1] - b[1]);\n  const selected = [];\n  let end = -Infinity;\n  for (const [s, e] of intervals) {\n    if (s >= end) {\n      selected.push([s, e]);\n      end = e;\n    }\n  }\n  return selected;\n}\n\nconsole.log(maxNonOverlapping([[1,3],[2,5],[4,6],[6,7]]));",
      "output": "[ [ 1, 3 ], [ 4, 6 ], [ 6, 7 ] ]",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Build path matcher with params (`/users/:id/orders/:oid`).",
      "code": "function matchRoute(pattern, path) {\n  const p1 = pattern.split('/').filter(Boolean);\n  const p2 = path.split('/').filter(Boolean);\n  if (p1.length !== p2.length) return null;\n  const params = {};\n  for (let i = 0; i < p1.length; i++) {\n    if (p1[i].startsWith(':')) params[p1[i].slice(1)] = p2[i];\n    else if (p1[i] !== p2[i]) return null;\n  }\n  return params;\n}\n\nconsole.log(matchRoute('/users/:id/orders/:oid', '/users/42/orders/900'));",
      "output": "{ id: '42', oid: '900' }",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Implement custom `Promise.any` polyfill.",
      "code": "function promiseAny(promises) {\n  return new Promise((resolve, reject) => {\n    let rejected = 0;\n    const errs = [];\n    promises.forEach((p, i) => {\n      Promise.resolve(p)\n        .then(resolve)\n        .catch(e => {\n          errs[i] = e;\n          rejected++;\n          if (rejected === promises.length) reject(new AggregateError(errs, 'All promises were rejected'));\n        });\n    });\n  });\n}\n\npromiseAny([Promise.reject('x'), Promise.resolve('ok'), Promise.reject('y')]).then(console.log);",
      "output": "ok",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Build LCS (longest common subsequence) dynamic programming.",
      "code": "function lcs(a, b) {\n  const dp = Array.from({ length: a.length + 1 }, () => Array(b.length + 1).fill(0));\n  for (let i = 1; i <= a.length; i++) {\n    for (let j = 1; j <= b.length; j++) {\n      if (a[i - 1] === b[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;\n      else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n    }\n  }\n  return dp[a.length][b.length];\n}\n\nconsole.log(lcs('ABCBDAB', 'BDCAB'));",
      "output": "4",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Implement rolling logger with max size and severity filter.",
      "code": "class RollingLogger {\n  constructor(max = 5) {\n    this.max = max;\n    this.rows = [];\n  }\n  log(level, msg) {\n    this.rows.push({ level, msg });\n    if (this.rows.length > this.max) this.rows.shift();\n  }\n  get(minLevel = 'debug') {\n    const order = { debug: 1, info: 2, warn: 3, error: 4 };\n    return this.rows.filter(r => order[r.level] >= order[minLevel]);\n  }\n}\n\nconst lg = new RollingLogger(3);\nlg.log('info', 'a'); lg.log('warn', 'b'); lg.log('error', 'c'); lg.log('debug', 'd');\nconsole.log(lg.get('warn'));",
      "output": "[ { level: 'warn', msg: 'b' }, { level: 'error', msg: 'c' } ]",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Implement `promiseAllSettledLimit` with concurrency control.",
      "code": "async function promiseAllSettledLimit(taskFns, limit = 3) {\n  const results = new Array(taskFns.length);\n  let idx = 0;\n\n  async function worker() {\n    while (idx < taskFns.length) {\n      const i = idx++;\n      try {\n        const value = await taskFns[i]();\n        results[i] = { status: 'fulfilled', value };\n      } catch (error) {\n        results[i] = { status: 'rejected', reason: error.message };\n      }\n    }\n  }\n\n  await Promise.all(Array.from({ length: Math.min(limit, taskFns.length) }, worker));\n  return results;\n}\n\nconst wait = (v, ms, fail = false) => () => new Promise((res, rej) => setTimeout(() => fail ? rej(new Error(v)) : res(v), ms));\n(async () => {\n  const out = await promiseAllSettledLimit([wait('A', 30), wait('B', 10, true), wait('C', 5)], 2);\n  console.log(out.map(x => x.status));\n})();",
      "output": "[ 'fulfilled', 'rejected', 'fulfilled' ]",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Build deep equality check supporting objects, arrays, and dates.",
      "code": "function deepEqual(a, b) {\n  if (Object.is(a, b)) return true;\n  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();\n  if (typeof a !== 'object' || typeof b !== 'object' || a === null || b === null) return false;\n  if (Array.isArray(a) !== Array.isArray(b)) return false;\n\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n\n  for (const k of keysA) {\n    if (!keysB.includes(k)) return false;\n    if (!deepEqual(a[k], b[k])) return false;\n  }\n  return true;\n}\n\nconsole.log(\n  deepEqual({ x: [1, { y: 2 }], d: new Date('2026-01-01') }, { x: [1, { y: 2 }], d: new Date('2026-01-01') })\n);",
      "output": "true",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Implement object diff utility (added/removed/changed keys).",
      "code": "function objectDiff(oldObj, newObj) {\n  const added = [];\n  const removed = [];\n  const changed = [];\n\n  for (const k of Object.keys(oldObj)) {\n    if (!(k in newObj)) removed.push(k);\n    else if (JSON.stringify(oldObj[k]) !== JSON.stringify(newObj[k])) changed.push(k);\n  }\n  for (const k of Object.keys(newObj)) {\n    if (!(k in oldObj)) added.push(k);\n  }\n  return { added, removed, changed };\n}\n\nconsole.log(objectDiff(\n  { a: 1, b: 2, c: { x: 1 } },\n  { a: 1, b: 3, d: true, c: { x: 2 } }\n));",
      "output": "{ added: [ 'd' ], removed: [], changed: [ 'b', 'c' ] }",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Build immutable deep update by path (`setIn`).",
      "code": "function setIn(obj, path, value) {\n  const keys = path.split('.');\n  const out = Array.isArray(obj) ? [...obj] : { ...obj };\n  let cur = out;\n  let src = obj;\n\n  for (let i = 0; i < keys.length - 1; i++) {\n    const k = keys[i];\n    const next = src?.[k];\n    cur[k] = Array.isArray(next) ? [...next] : { ...(next || {}) };\n    cur = cur[k];\n    src = next;\n  }\n  cur[keys[keys.length - 1]] = value;\n  return out;\n}\n\nconst state = { user: { profile: { city: 'Austin' } } };\nconst next = setIn(state, 'user.profile.city', 'Dallas');\nconsole.log(state.user.profile.city, next.user.profile.city, state !== next);",
      "output": "Austin Dallas true",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Implement `groupBy` + aggregate pipeline for sales analytics.",
      "code": "function groupBy(arr, keyFn) {\n  return arr.reduce((m, item) => {\n    const k = keyFn(item);\n    if (!m[k]) m[k] = [];\n    m[k].push(item);\n    return m;\n  }, {});\n}\n\nconst sales = [\n  { region: 'US', amount: 120 },\n  { region: 'EU', amount: 80 },\n  { region: 'US', amount: 30 }\n];\n\nconst grouped = groupBy(sales, x => x.region);\nconst totals = Object.fromEntries(Object.entries(grouped).map(([k, v]) => [k, v.reduce((s, x) => s + x.amount, 0)]));\nconsole.log(totals);",
      "output": "{ US: 150, EU: 80 }",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Write robust CSV parser for quoted fields.",
      "code": "function parseCSVLine(line) {\n  const out = [];\n  let cur = '';\n  let inQuotes = false;\n\n  for (let i = 0; i < line.length; i++) {\n    const ch = line[i];\n    if (ch === '\"') {\n      if (inQuotes && line[i + 1] === '\"') {\n        cur += '\"';\n        i++;\n      } else {\n        inQuotes = !inQuotes;\n      }\n    } else if (ch === ',' && !inQuotes) {\n      out.push(cur);\n      cur = '';\n    } else {\n      cur += ch;\n    }\n  }\n  out.push(cur);\n  return out;\n}\n\nconsole.log(parseCSVLine('1,\"Ada, Lovelace\",Engineer'));",
      "output": "[ '1', 'Ada, Lovelace', 'Engineer' ]",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Build mini template engine with `{{key}}` placeholders.",
      "code": "function renderTemplate(template, data) {\n  return template.replace(/{{s*([w.]+)s*}}/g, (_, path) => {\n    const value = path.split('.').reduce((acc, k) => acc?.[k], data);\n    return value == null ? '' : String(value);\n  });\n}\n\nconst t = 'Hello {{user.name}}, order {{order.id}} is {{order.status}}.';\nconsole.log(renderTemplate(t, { user: { name: 'Alice' }, order: { id: 101, status: 'shipped' } }));",
      "output": "Hello Alice, order 101 is shipped.",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Implement topological sort for dependency graph.",
      "code": "function topoSort(graph) {\n  const indeg = new Map();\n  for (const n of Object.keys(graph)) indeg.set(n, 0);\n  for (const deps of Object.values(graph)) for (const d of deps) indeg.set(d, (indeg.get(d) || 0) + 1);\n\n  const q = [...[...indeg.entries()].filter(([, v]) => v === 0).map(([k]) => k)];\n  const out = [];\n\n  while (q.length) {\n    const n = q.shift();\n    out.push(n);\n    for (const d of graph[n] || []) {\n      indeg.set(d, indeg.get(d) - 1);\n      if (indeg.get(d) === 0) q.push(d);\n    }\n  }\n  return out.length === indeg.size ? out : null;\n}\n\nconsole.log(topoSort({ build: ['test'], test: ['lint'], lint: [] }));",
      "output": "[ 'build', 'test', 'lint' ]",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Implement token bucket rate limiter.",
      "code": "class TokenBucket {\n  constructor(capacity, refillPerSec) {\n    this.capacity = capacity;\n    this.tokens = capacity;\n    this.refillPerSec = refillPerSec;\n    this.last = Date.now();\n  }\n  allow(cost = 1) {\n    const now = Date.now();\n    const elapsed = (now - this.last) / 1000;\n    this.tokens = Math.min(this.capacity, this.tokens + elapsed * this.refillPerSec);\n    this.last = now;\n    if (this.tokens >= cost) {\n      this.tokens -= cost;\n      return true;\n    }\n    return false;\n  }\n}\n\nconst bucket = new TokenBucket(2, 1);\nconsole.log(bucket.allow(), bucket.allow(), bucket.allow());",
      "output": "true true false",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Build Trie with insert/search/prefix methods.",
      "code": "class TrieNode {\n  constructor() { this.next = new Map(); this.end = false; }\n}\nclass Trie {\n  constructor() { this.root = new TrieNode(); }\n  insert(word) {\n    let cur = this.root;\n    for (const ch of word) {\n      if (!cur.next.has(ch)) cur.next.set(ch, new TrieNode());\n      cur = cur.next.get(ch);\n    }\n    cur.end = true;\n  }\n  search(word) {\n    let cur = this.root;\n    for (const ch of word) {\n      if (!cur.next.has(ch)) return false;\n      cur = cur.next.get(ch);\n    }\n    return cur.end;\n  }\n  startsWith(prefix) {\n    let cur = this.root;\n    for (const ch of prefix) {\n      if (!cur.next.has(ch)) return false;\n      cur = cur.next.get(ch);\n    }\n    return true;\n  }\n}\n\nconst t = new Trie();\nt.insert('code'); t.insert('coder');\nconsole.log(t.search('code'), t.search('cod'), t.startsWith('cod'));",
      "output": "true false true",
      "level": "Medium"
    },
    {
      "type": "program",
      "question": "Edge-safe Build undo/redo state manager (command stack).",
      "code": "class HistoryState {\n  constructor(initial) {\n    this.past = [];\n    this.present = initial;\n    this.future = [];\n  }\n  set(next) {\n    this.past.push(this.present);\n    this.present = next;\n    this.future = [];\n  }\n  undo() {\n    if (!this.past.length) return;\n    this.future.push(this.present);\n    this.present = this.past.pop();\n  }\n  redo() {\n    if (!this.future.length) return;\n    this.past.push(this.present);\n    this.present = this.future.pop();\n  }\n}\n\nconst h = new HistoryState(1);\nh.set(2); h.set(3); h.undo(); h.undo(); h.redo();\nconsole.log(h.present);",
      "output": "2",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Production-ready Implement async queue with pause/resume and worker.",
      "code": "class AsyncQueue {\n  constructor(worker) {\n    this.worker = worker;\n    this.q = [];\n    this.running = false;\n    this.paused = false;\n  }\n  push(item) {\n    this.q.push(item);\n    this.drain();\n  }\n  pause() { this.paused = true; }\n  resume() { this.paused = false; this.drain(); }\n  async drain() {\n    if (this.running || this.paused) return;\n    this.running = true;\n    while (this.q.length && !this.paused) {\n      const item = this.q.shift();\n      await this.worker(item);\n    }\n    this.running = false;\n  }\n}\n\nconst out = [];\nconst aq = new AsyncQueue(async x => { out.push(x * 2); });\naq.push(1); aq.push(2); aq.push(3);\nsetTimeout(() => console.log(out), 10);",
      "output": "[ 2, 4, 6 ]",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Optimized Implement paginated fetch iterator over async source.",
      "code": "async function* paginate(fetchPage) {\n  let page = 1;\n  while (true) {\n    const { items, hasNext } = await fetchPage(page);\n    for (const item of items) yield item;\n    if (!hasNext) break;\n    page++;\n  }\n}\n\n(async () => {\n  const source = {\n    1: { items: [1, 2], hasNext: true },\n    2: { items: [3, 4], hasNext: false }\n  };\n  const out = [];\n  for await (const v of paginate(async p => source[p])) out.push(v);\n  console.log(out);\n})();",
      "output": "[ 1, 2, 3, 4 ]",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Concurrency-aware Build safe JSON parser with validation and defaults.",
      "code": "function parseConfig(input, schema) {\n  let raw;\n  try { raw = JSON.parse(input); } catch { raw = {}; }\n  const out = {};\n  for (const [k, rule] of Object.entries(schema)) {\n    const v = raw[k];\n    if (v == null) out[k] = rule.default;\n    else if (typeof v === rule.type) out[k] = v;\n    else out[k] = rule.default;\n  }\n  return out;\n}\n\nconst schema = { retries: { type: 'number', default: 3 }, mode: { type: 'string', default: 'safe' } };\nconsole.log(parseConfig('{\"retries\":5,\"mode\":\"fast\"}', schema));",
      "output": "{ retries: 5, mode: 'fast' }",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Fault-tolerant Build binary search over sorted array of objects by key.",
      "code": "function binarySearchBy(arr, key, target) {\n  let l = 0, r = arr.length - 1;\n  while (l <= r) {\n    const m = (l + r) >> 1;\n    if (arr[m][key] === target) return m;\n    if (arr[m][key] < target) l = m + 1;\n    else r = m - 1;\n  }\n  return -1;\n}\n\nconst users = [{ id: 10 }, { id: 20 }, { id: 30 }, { id: 40 }];\nconsole.log(binarySearchBy(users, 'id', 30));",
      "output": "2",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Edge-safe Implement interval scheduler for maximum non-overlap jobs.",
      "code": "function maxNonOverlapping(intervals) {\n  intervals.sort((a, b) => a[1] - b[1]);\n  const selected = [];\n  let end = -Infinity;\n  for (const [s, e] of intervals) {\n    if (s >= end) {\n      selected.push([s, e]);\n      end = e;\n    }\n  }\n  return selected;\n}\n\nconsole.log(maxNonOverlapping([[1,3],[2,5],[4,6],[6,7]]));",
      "output": "[ [ 1, 3 ], [ 4, 6 ], [ 6, 7 ] ]",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Production-ready Build path matcher with params (`/users/:id/orders/:oid`).",
      "code": "function matchRoute(pattern, path) {\n  const p1 = pattern.split('/').filter(Boolean);\n  const p2 = path.split('/').filter(Boolean);\n  if (p1.length !== p2.length) return null;\n  const params = {};\n  for (let i = 0; i < p1.length; i++) {\n    if (p1[i].startsWith(':')) params[p1[i].slice(1)] = p2[i];\n    else if (p1[i] !== p2[i]) return null;\n  }\n  return params;\n}\n\nconsole.log(matchRoute('/users/:id/orders/:oid', '/users/42/orders/900'));",
      "output": "{ id: '42', oid: '900' }",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Optimized Implement custom `Promise.any` polyfill.",
      "code": "function promiseAny(promises) {\n  return new Promise((resolve, reject) => {\n    let rejected = 0;\n    const errs = [];\n    promises.forEach((p, i) => {\n      Promise.resolve(p)\n        .then(resolve)\n        .catch(e => {\n          errs[i] = e;\n          rejected++;\n          if (rejected === promises.length) reject(new AggregateError(errs, 'All promises were rejected'));\n        });\n    });\n  });\n}\n\npromiseAny([Promise.reject('x'), Promise.resolve('ok'), Promise.reject('y')]).then(console.log);",
      "output": "ok",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Concurrency-aware Build LCS (longest common subsequence) dynamic programming.",
      "code": "function lcs(a, b) {\n  const dp = Array.from({ length: a.length + 1 }, () => Array(b.length + 1).fill(0));\n  for (let i = 1; i <= a.length; i++) {\n    for (let j = 1; j <= b.length; j++) {\n      if (a[i - 1] === b[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;\n      else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n    }\n  }\n  return dp[a.length][b.length];\n}\n\nconsole.log(lcs('ABCBDAB', 'BDCAB'));",
      "output": "4",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Fault-tolerant Implement rolling logger with max size and severity filter.",
      "code": "class RollingLogger {\n  constructor(max = 5) {\n    this.max = max;\n    this.rows = [];\n  }\n  log(level, msg) {\n    this.rows.push({ level, msg });\n    if (this.rows.length > this.max) this.rows.shift();\n  }\n  get(minLevel = 'debug') {\n    const order = { debug: 1, info: 2, warn: 3, error: 4 };\n    return this.rows.filter(r => order[r.level] >= order[minLevel]);\n  }\n}\n\nconst lg = new RollingLogger(3);\nlg.log('info', 'a'); lg.log('warn', 'b'); lg.log('error', 'c'); lg.log('debug', 'd');\nconsole.log(lg.get('warn'));",
      "output": "[ { level: 'warn', msg: 'b' }, { level: 'error', msg: 'c' } ]",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Edge-safe Implement `promiseAllSettledLimit` with concurrency control.",
      "code": "async function promiseAllSettledLimit(taskFns, limit = 3) {\n  const results = new Array(taskFns.length);\n  let idx = 0;\n\n  async function worker() {\n    while (idx < taskFns.length) {\n      const i = idx++;\n      try {\n        const value = await taskFns[i]();\n        results[i] = { status: 'fulfilled', value };\n      } catch (error) {\n        results[i] = { status: 'rejected', reason: error.message };\n      }\n    }\n  }\n\n  await Promise.all(Array.from({ length: Math.min(limit, taskFns.length) }, worker));\n  return results;\n}\n\nconst wait = (v, ms, fail = false) => () => new Promise((res, rej) => setTimeout(() => fail ? rej(new Error(v)) : res(v), ms));\n(async () => {\n  const out = await promiseAllSettledLimit([wait('A', 30), wait('B', 10, true), wait('C', 5)], 2);\n  console.log(out.map(x => x.status));\n})();",
      "output": "[ 'fulfilled', 'rejected', 'fulfilled' ]",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Production-ready Build deep equality check supporting objects, arrays, and dates.",
      "code": "function deepEqual(a, b) {\n  if (Object.is(a, b)) return true;\n  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();\n  if (typeof a !== 'object' || typeof b !== 'object' || a === null || b === null) return false;\n  if (Array.isArray(a) !== Array.isArray(b)) return false;\n\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n\n  for (const k of keysA) {\n    if (!keysB.includes(k)) return false;\n    if (!deepEqual(a[k], b[k])) return false;\n  }\n  return true;\n}\n\nconsole.log(\n  deepEqual({ x: [1, { y: 2 }], d: new Date('2026-01-01') }, { x: [1, { y: 2 }], d: new Date('2026-01-01') })\n);",
      "output": "true",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Optimized Implement object diff utility (added/removed/changed keys).",
      "code": "function objectDiff(oldObj, newObj) {\n  const added = [];\n  const removed = [];\n  const changed = [];\n\n  for (const k of Object.keys(oldObj)) {\n    if (!(k in newObj)) removed.push(k);\n    else if (JSON.stringify(oldObj[k]) !== JSON.stringify(newObj[k])) changed.push(k);\n  }\n  for (const k of Object.keys(newObj)) {\n    if (!(k in oldObj)) added.push(k);\n  }\n  return { added, removed, changed };\n}\n\nconsole.log(objectDiff(\n  { a: 1, b: 2, c: { x: 1 } },\n  { a: 1, b: 3, d: true, c: { x: 2 } }\n));",
      "output": "{ added: [ 'd' ], removed: [], changed: [ 'b', 'c' ] }",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Concurrency-aware Build immutable deep update by path (`setIn`).",
      "code": "function setIn(obj, path, value) {\n  const keys = path.split('.');\n  const out = Array.isArray(obj) ? [...obj] : { ...obj };\n  let cur = out;\n  let src = obj;\n\n  for (let i = 0; i < keys.length - 1; i++) {\n    const k = keys[i];\n    const next = src?.[k];\n    cur[k] = Array.isArray(next) ? [...next] : { ...(next || {}) };\n    cur = cur[k];\n    src = next;\n  }\n  cur[keys[keys.length - 1]] = value;\n  return out;\n}\n\nconst state = { user: { profile: { city: 'Austin' } } };\nconst next = setIn(state, 'user.profile.city', 'Dallas');\nconsole.log(state.user.profile.city, next.user.profile.city, state !== next);",
      "output": "Austin Dallas true",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Fault-tolerant Implement `groupBy` + aggregate pipeline for sales analytics.",
      "code": "function groupBy(arr, keyFn) {\n  return arr.reduce((m, item) => {\n    const k = keyFn(item);\n    if (!m[k]) m[k] = [];\n    m[k].push(item);\n    return m;\n  }, {});\n}\n\nconst sales = [\n  { region: 'US', amount: 120 },\n  { region: 'EU', amount: 80 },\n  { region: 'US', amount: 30 }\n];\n\nconst grouped = groupBy(sales, x => x.region);\nconst totals = Object.fromEntries(Object.entries(grouped).map(([k, v]) => [k, v.reduce((s, x) => s + x.amount, 0)]));\nconsole.log(totals);",
      "output": "{ US: 150, EU: 80 }",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Edge-safe Write robust CSV parser for quoted fields.",
      "code": "function parseCSVLine(line) {\n  const out = [];\n  let cur = '';\n  let inQuotes = false;\n\n  for (let i = 0; i < line.length; i++) {\n    const ch = line[i];\n    if (ch === '\"') {\n      if (inQuotes && line[i + 1] === '\"') {\n        cur += '\"';\n        i++;\n      } else {\n        inQuotes = !inQuotes;\n      }\n    } else if (ch === ',' && !inQuotes) {\n      out.push(cur);\n      cur = '';\n    } else {\n      cur += ch;\n    }\n  }\n  out.push(cur);\n  return out;\n}\n\nconsole.log(parseCSVLine('1,\"Ada, Lovelace\",Engineer'));",
      "output": "[ '1', 'Ada, Lovelace', 'Engineer' ]",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Production-ready Build mini template engine with `{{key}}` placeholders.",
      "code": "function renderTemplate(template, data) {\n  return template.replace(/{{s*([w.]+)s*}}/g, (_, path) => {\n    const value = path.split('.').reduce((acc, k) => acc?.[k], data);\n    return value == null ? '' : String(value);\n  });\n}\n\nconst t = 'Hello {{user.name}}, order {{order.id}} is {{order.status}}.';\nconsole.log(renderTemplate(t, { user: { name: 'Alice' }, order: { id: 101, status: 'shipped' } }));",
      "output": "Hello Alice, order 101 is shipped.",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Optimized Implement topological sort for dependency graph.",
      "code": "function topoSort(graph) {\n  const indeg = new Map();\n  for (const n of Object.keys(graph)) indeg.set(n, 0);\n  for (const deps of Object.values(graph)) for (const d of deps) indeg.set(d, (indeg.get(d) || 0) + 1);\n\n  const q = [...[...indeg.entries()].filter(([, v]) => v === 0).map(([k]) => k)];\n  const out = [];\n\n  while (q.length) {\n    const n = q.shift();\n    out.push(n);\n    for (const d of graph[n] || []) {\n      indeg.set(d, indeg.get(d) - 1);\n      if (indeg.get(d) === 0) q.push(d);\n    }\n  }\n  return out.length === indeg.size ? out : null;\n}\n\nconsole.log(topoSort({ build: ['test'], test: ['lint'], lint: [] }));",
      "output": "[ 'build', 'test', 'lint' ]",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Concurrency-aware Implement token bucket rate limiter.",
      "code": "class TokenBucket {\n  constructor(capacity, refillPerSec) {\n    this.capacity = capacity;\n    this.tokens = capacity;\n    this.refillPerSec = refillPerSec;\n    this.last = Date.now();\n  }\n  allow(cost = 1) {\n    const now = Date.now();\n    const elapsed = (now - this.last) / 1000;\n    this.tokens = Math.min(this.capacity, this.tokens + elapsed * this.refillPerSec);\n    this.last = now;\n    if (this.tokens >= cost) {\n      this.tokens -= cost;\n      return true;\n    }\n    return false;\n  }\n}\n\nconst bucket = new TokenBucket(2, 1);\nconsole.log(bucket.allow(), bucket.allow(), bucket.allow());",
      "output": "true true false",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Fault-tolerant Build Trie with insert/search/prefix methods.",
      "code": "class TrieNode {\n  constructor() { this.next = new Map(); this.end = false; }\n}\nclass Trie {\n  constructor() { this.root = new TrieNode(); }\n  insert(word) {\n    let cur = this.root;\n    for (const ch of word) {\n      if (!cur.next.has(ch)) cur.next.set(ch, new TrieNode());\n      cur = cur.next.get(ch);\n    }\n    cur.end = true;\n  }\n  search(word) {\n    let cur = this.root;\n    for (const ch of word) {\n      if (!cur.next.has(ch)) return false;\n      cur = cur.next.get(ch);\n    }\n    return cur.end;\n  }\n  startsWith(prefix) {\n    let cur = this.root;\n    for (const ch of prefix) {\n      if (!cur.next.has(ch)) return false;\n      cur = cur.next.get(ch);\n    }\n    return true;\n  }\n}\n\nconst t = new Trie();\nt.insert('code'); t.insert('coder');\nconsole.log(t.search('code'), t.search('cod'), t.startsWith('cod'));",
      "output": "true false true",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Edge-safe Build undo/redo state manager (command stack).",
      "code": "class HistoryState {\n  constructor(initial) {\n    this.past = [];\n    this.present = initial;\n    this.future = [];\n  }\n  set(next) {\n    this.past.push(this.present);\n    this.present = next;\n    this.future = [];\n  }\n  undo() {\n    if (!this.past.length) return;\n    this.future.push(this.present);\n    this.present = this.past.pop();\n  }\n  redo() {\n    if (!this.future.length) return;\n    this.past.push(this.present);\n    this.present = this.future.pop();\n  }\n}\n\nconst h = new HistoryState(1);\nh.set(2); h.set(3); h.undo(); h.undo(); h.redo();\nconsole.log(h.present);",
      "output": "2",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Production-ready Implement async queue with pause/resume and worker.",
      "code": "class AsyncQueue {\n  constructor(worker) {\n    this.worker = worker;\n    this.q = [];\n    this.running = false;\n    this.paused = false;\n  }\n  push(item) {\n    this.q.push(item);\n    this.drain();\n  }\n  pause() { this.paused = true; }\n  resume() { this.paused = false; this.drain(); }\n  async drain() {\n    if (this.running || this.paused) return;\n    this.running = true;\n    while (this.q.length && !this.paused) {\n      const item = this.q.shift();\n      await this.worker(item);\n    }\n    this.running = false;\n  }\n}\n\nconst out = [];\nconst aq = new AsyncQueue(async x => { out.push(x * 2); });\naq.push(1); aq.push(2); aq.push(3);\nsetTimeout(() => console.log(out), 10);",
      "output": "[ 2, 4, 6 ]",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Optimized Implement paginated fetch iterator over async source.",
      "code": "async function* paginate(fetchPage) {\n  let page = 1;\n  while (true) {\n    const { items, hasNext } = await fetchPage(page);\n    for (const item of items) yield item;\n    if (!hasNext) break;\n    page++;\n  }\n}\n\n(async () => {\n  const source = {\n    1: { items: [1, 2], hasNext: true },\n    2: { items: [3, 4], hasNext: false }\n  };\n  const out = [];\n  for await (const v of paginate(async p => source[p])) out.push(v);\n  console.log(out);\n})();",
      "output": "[ 1, 2, 3, 4 ]",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Concurrency-aware Build safe JSON parser with validation and defaults.",
      "code": "function parseConfig(input, schema) {\n  let raw;\n  try { raw = JSON.parse(input); } catch { raw = {}; }\n  const out = {};\n  for (const [k, rule] of Object.entries(schema)) {\n    const v = raw[k];\n    if (v == null) out[k] = rule.default;\n    else if (typeof v === rule.type) out[k] = v;\n    else out[k] = rule.default;\n  }\n  return out;\n}\n\nconst schema = { retries: { type: 'number', default: 3 }, mode: { type: 'string', default: 'safe' } };\nconsole.log(parseConfig('{\"retries\":5,\"mode\":\"fast\"}', schema));",
      "output": "{ retries: 5, mode: 'fast' }",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Fault-tolerant Build binary search over sorted array of objects by key.",
      "code": "function binarySearchBy(arr, key, target) {\n  let l = 0, r = arr.length - 1;\n  while (l <= r) {\n    const m = (l + r) >> 1;\n    if (arr[m][key] === target) return m;\n    if (arr[m][key] < target) l = m + 1;\n    else r = m - 1;\n  }\n  return -1;\n}\n\nconst users = [{ id: 10 }, { id: 20 }, { id: 30 }, { id: 40 }];\nconsole.log(binarySearchBy(users, 'id', 30));",
      "output": "2",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Edge-safe Implement interval scheduler for maximum non-overlap jobs.",
      "code": "function maxNonOverlapping(intervals) {\n  intervals.sort((a, b) => a[1] - b[1]);\n  const selected = [];\n  let end = -Infinity;\n  for (const [s, e] of intervals) {\n    if (s >= end) {\n      selected.push([s, e]);\n      end = e;\n    }\n  }\n  return selected;\n}\n\nconsole.log(maxNonOverlapping([[1,3],[2,5],[4,6],[6,7]]));",
      "output": "[ [ 1, 3 ], [ 4, 6 ], [ 6, 7 ] ]",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Production-ready Build path matcher with params (`/users/:id/orders/:oid`).",
      "code": "function matchRoute(pattern, path) {\n  const p1 = pattern.split('/').filter(Boolean);\n  const p2 = path.split('/').filter(Boolean);\n  if (p1.length !== p2.length) return null;\n  const params = {};\n  for (let i = 0; i < p1.length; i++) {\n    if (p1[i].startsWith(':')) params[p1[i].slice(1)] = p2[i];\n    else if (p1[i] !== p2[i]) return null;\n  }\n  return params;\n}\n\nconsole.log(matchRoute('/users/:id/orders/:oid', '/users/42/orders/900'));",
      "output": "{ id: '42', oid: '900' }",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Optimized Implement custom `Promise.any` polyfill.",
      "code": "function promiseAny(promises) {\n  return new Promise((resolve, reject) => {\n    let rejected = 0;\n    const errs = [];\n    promises.forEach((p, i) => {\n      Promise.resolve(p)\n        .then(resolve)\n        .catch(e => {\n          errs[i] = e;\n          rejected++;\n          if (rejected === promises.length) reject(new AggregateError(errs, 'All promises were rejected'));\n        });\n    });\n  });\n}\n\npromiseAny([Promise.reject('x'), Promise.resolve('ok'), Promise.reject('y')]).then(console.log);",
      "output": "ok",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Concurrency-aware Build LCS (longest common subsequence) dynamic programming.",
      "code": "function lcs(a, b) {\n  const dp = Array.from({ length: a.length + 1 }, () => Array(b.length + 1).fill(0));\n  for (let i = 1; i <= a.length; i++) {\n    for (let j = 1; j <= b.length; j++) {\n      if (a[i - 1] === b[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;\n      else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n    }\n  }\n  return dp[a.length][b.length];\n}\n\nconsole.log(lcs('ABCBDAB', 'BDCAB'));",
      "output": "4",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "Fault-tolerant Implement rolling logger with max size and severity filter.",
      "code": "class RollingLogger {\n  constructor(max = 5) {\n    this.max = max;\n    this.rows = [];\n  }\n  log(level, msg) {\n    this.rows.push({ level, msg });\n    if (this.rows.length > this.max) this.rows.shift();\n  }\n  get(minLevel = 'debug') {\n    const order = { debug: 1, info: 2, warn: 3, error: 4 };\n    return this.rows.filter(r => order[r.level] >= order[minLevel]);\n  }\n}\n\nconst lg = new RollingLogger(3);\nlg.log('info', 'a'); lg.log('warn', 'b'); lg.log('error', 'c'); lg.log('debug', 'd');\nconsole.log(lg.get('warn'));",
      "output": "[ { level: 'warn', msg: 'b' }, { level: 'error', msg: 'c' } ]",
      "level": "Hard"
    },
    {
      "type": "program",
      "question": "System-level Implement `promiseAllSettledLimit` with concurrency control.",
      "code": "async function promiseAllSettledLimit(taskFns, limit = 3) {\n  const results = new Array(taskFns.length);\n  let idx = 0;\n\n  async function worker() {\n    while (idx < taskFns.length) {\n      const i = idx++;\n      try {\n        const value = await taskFns[i]();\n        results[i] = { status: 'fulfilled', value };\n      } catch (error) {\n        results[i] = { status: 'rejected', reason: error.message };\n      }\n    }\n  }\n\n  await Promise.all(Array.from({ length: Math.min(limit, taskFns.length) }, worker));\n  return results;\n}\n\nconst wait = (v, ms, fail = false) => () => new Promise((res, rej) => setTimeout(() => fail ? rej(new Error(v)) : res(v), ms));\n(async () => {\n  const out = await promiseAllSettledLimit([wait('A', 30), wait('B', 10, true), wait('C', 5)], 2);\n  console.log(out.map(x => x.status));\n})();",
      "output": "[ 'fulfilled', 'rejected', 'fulfilled' ]",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "Scalable Build deep equality check supporting objects, arrays, and dates.",
      "code": "function deepEqual(a, b) {\n  if (Object.is(a, b)) return true;\n  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();\n  if (typeof a !== 'object' || typeof b !== 'object' || a === null || b === null) return false;\n  if (Array.isArray(a) !== Array.isArray(b)) return false;\n\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n\n  for (const k of keysA) {\n    if (!keysB.includes(k)) return false;\n    if (!deepEqual(a[k], b[k])) return false;\n  }\n  return true;\n}\n\nconsole.log(\n  deepEqual({ x: [1, { y: 2 }], d: new Date('2026-01-01') }, { x: [1, { y: 2 }], d: new Date('2026-01-01') })\n);",
      "output": "true",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "Interview-hard Implement object diff utility (added/removed/changed keys).",
      "code": "function objectDiff(oldObj, newObj) {\n  const added = [];\n  const removed = [];\n  const changed = [];\n\n  for (const k of Object.keys(oldObj)) {\n    if (!(k in newObj)) removed.push(k);\n    else if (JSON.stringify(oldObj[k]) !== JSON.stringify(newObj[k])) changed.push(k);\n  }\n  for (const k of Object.keys(newObj)) {\n    if (!(k in oldObj)) added.push(k);\n  }\n  return { added, removed, changed };\n}\n\nconsole.log(objectDiff(\n  { a: 1, b: 2, c: { x: 1 } },\n  { a: 1, b: 3, d: true, c: { x: 2 } }\n));",
      "output": "{ added: [ 'd' ], removed: [], changed: [ 'b', 'c' ] }",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "Architecture-grade Build immutable deep update by path (`setIn`).",
      "code": "function setIn(obj, path, value) {\n  const keys = path.split('.');\n  const out = Array.isArray(obj) ? [...obj] : { ...obj };\n  let cur = out;\n  let src = obj;\n\n  for (let i = 0; i < keys.length - 1; i++) {\n    const k = keys[i];\n    const next = src?.[k];\n    cur[k] = Array.isArray(next) ? [...next] : { ...(next || {}) };\n    cur = cur[k];\n    src = next;\n  }\n  cur[keys[keys.length - 1]] = value;\n  return out;\n}\n\nconst state = { user: { profile: { city: 'Austin' } } };\nconst next = setIn(state, 'user.profile.city', 'Dallas');\nconsole.log(state.user.profile.city, next.user.profile.city, state !== next);",
      "output": "Austin Dallas true",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "High-complexity Implement `groupBy` + aggregate pipeline for sales analytics.",
      "code": "function groupBy(arr, keyFn) {\n  return arr.reduce((m, item) => {\n    const k = keyFn(item);\n    if (!m[k]) m[k] = [];\n    m[k].push(item);\n    return m;\n  }, {});\n}\n\nconst sales = [\n  { region: 'US', amount: 120 },\n  { region: 'EU', amount: 80 },\n  { region: 'US', amount: 30 }\n];\n\nconst grouped = groupBy(sales, x => x.region);\nconst totals = Object.fromEntries(Object.entries(grouped).map(([k, v]) => [k, v.reduce((s, x) => s + x.amount, 0)]));\nconsole.log(totals);",
      "output": "{ US: 150, EU: 80 }",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "System-level Write robust CSV parser for quoted fields.",
      "code": "function parseCSVLine(line) {\n  const out = [];\n  let cur = '';\n  let inQuotes = false;\n\n  for (let i = 0; i < line.length; i++) {\n    const ch = line[i];\n    if (ch === '\"') {\n      if (inQuotes && line[i + 1] === '\"') {\n        cur += '\"';\n        i++;\n      } else {\n        inQuotes = !inQuotes;\n      }\n    } else if (ch === ',' && !inQuotes) {\n      out.push(cur);\n      cur = '';\n    } else {\n      cur += ch;\n    }\n  }\n  out.push(cur);\n  return out;\n}\n\nconsole.log(parseCSVLine('1,\"Ada, Lovelace\",Engineer'));",
      "output": "[ '1', 'Ada, Lovelace', 'Engineer' ]",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "Scalable Build mini template engine with `{{key}}` placeholders.",
      "code": "function renderTemplate(template, data) {\n  return template.replace(/{{s*([w.]+)s*}}/g, (_, path) => {\n    const value = path.split('.').reduce((acc, k) => acc?.[k], data);\n    return value == null ? '' : String(value);\n  });\n}\n\nconst t = 'Hello {{user.name}}, order {{order.id}} is {{order.status}}.';\nconsole.log(renderTemplate(t, { user: { name: 'Alice' }, order: { id: 101, status: 'shipped' } }));",
      "output": "Hello Alice, order 101 is shipped.",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "Interview-hard Implement topological sort for dependency graph.",
      "code": "function topoSort(graph) {\n  const indeg = new Map();\n  for (const n of Object.keys(graph)) indeg.set(n, 0);\n  for (const deps of Object.values(graph)) for (const d of deps) indeg.set(d, (indeg.get(d) || 0) + 1);\n\n  const q = [...[...indeg.entries()].filter(([, v]) => v === 0).map(([k]) => k)];\n  const out = [];\n\n  while (q.length) {\n    const n = q.shift();\n    out.push(n);\n    for (const d of graph[n] || []) {\n      indeg.set(d, indeg.get(d) - 1);\n      if (indeg.get(d) === 0) q.push(d);\n    }\n  }\n  return out.length === indeg.size ? out : null;\n}\n\nconsole.log(topoSort({ build: ['test'], test: ['lint'], lint: [] }));",
      "output": "[ 'build', 'test', 'lint' ]",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "Architecture-grade Implement token bucket rate limiter.",
      "code": "class TokenBucket {\n  constructor(capacity, refillPerSec) {\n    this.capacity = capacity;\n    this.tokens = capacity;\n    this.refillPerSec = refillPerSec;\n    this.last = Date.now();\n  }\n  allow(cost = 1) {\n    const now = Date.now();\n    const elapsed = (now - this.last) / 1000;\n    this.tokens = Math.min(this.capacity, this.tokens + elapsed * this.refillPerSec);\n    this.last = now;\n    if (this.tokens >= cost) {\n      this.tokens -= cost;\n      return true;\n    }\n    return false;\n  }\n}\n\nconst bucket = new TokenBucket(2, 1);\nconsole.log(bucket.allow(), bucket.allow(), bucket.allow());",
      "output": "true true false",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "High-complexity Build Trie with insert/search/prefix methods.",
      "code": "class TrieNode {\n  constructor() { this.next = new Map(); this.end = false; }\n}\nclass Trie {\n  constructor() { this.root = new TrieNode(); }\n  insert(word) {\n    let cur = this.root;\n    for (const ch of word) {\n      if (!cur.next.has(ch)) cur.next.set(ch, new TrieNode());\n      cur = cur.next.get(ch);\n    }\n    cur.end = true;\n  }\n  search(word) {\n    let cur = this.root;\n    for (const ch of word) {\n      if (!cur.next.has(ch)) return false;\n      cur = cur.next.get(ch);\n    }\n    return cur.end;\n  }\n  startsWith(prefix) {\n    let cur = this.root;\n    for (const ch of prefix) {\n      if (!cur.next.has(ch)) return false;\n      cur = cur.next.get(ch);\n    }\n    return true;\n  }\n}\n\nconst t = new Trie();\nt.insert('code'); t.insert('coder');\nconsole.log(t.search('code'), t.search('cod'), t.startsWith('cod'));",
      "output": "true false true",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "System-level Build undo/redo state manager (command stack).",
      "code": "class HistoryState {\n  constructor(initial) {\n    this.past = [];\n    this.present = initial;\n    this.future = [];\n  }\n  set(next) {\n    this.past.push(this.present);\n    this.present = next;\n    this.future = [];\n  }\n  undo() {\n    if (!this.past.length) return;\n    this.future.push(this.present);\n    this.present = this.past.pop();\n  }\n  redo() {\n    if (!this.future.length) return;\n    this.past.push(this.present);\n    this.present = this.future.pop();\n  }\n}\n\nconst h = new HistoryState(1);\nh.set(2); h.set(3); h.undo(); h.undo(); h.redo();\nconsole.log(h.present);",
      "output": "2",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "Scalable Implement async queue with pause/resume and worker.",
      "code": "class AsyncQueue {\n  constructor(worker) {\n    this.worker = worker;\n    this.q = [];\n    this.running = false;\n    this.paused = false;\n  }\n  push(item) {\n    this.q.push(item);\n    this.drain();\n  }\n  pause() { this.paused = true; }\n  resume() { this.paused = false; this.drain(); }\n  async drain() {\n    if (this.running || this.paused) return;\n    this.running = true;\n    while (this.q.length && !this.paused) {\n      const item = this.q.shift();\n      await this.worker(item);\n    }\n    this.running = false;\n  }\n}\n\nconst out = [];\nconst aq = new AsyncQueue(async x => { out.push(x * 2); });\naq.push(1); aq.push(2); aq.push(3);\nsetTimeout(() => console.log(out), 10);",
      "output": "[ 2, 4, 6 ]",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "Interview-hard Implement paginated fetch iterator over async source.",
      "code": "async function* paginate(fetchPage) {\n  let page = 1;\n  while (true) {\n    const { items, hasNext } = await fetchPage(page);\n    for (const item of items) yield item;\n    if (!hasNext) break;\n    page++;\n  }\n}\n\n(async () => {\n  const source = {\n    1: { items: [1, 2], hasNext: true },\n    2: { items: [3, 4], hasNext: false }\n  };\n  const out = [];\n  for await (const v of paginate(async p => source[p])) out.push(v);\n  console.log(out);\n})();",
      "output": "[ 1, 2, 3, 4 ]",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "Architecture-grade Build safe JSON parser with validation and defaults.",
      "code": "function parseConfig(input, schema) {\n  let raw;\n  try { raw = JSON.parse(input); } catch { raw = {}; }\n  const out = {};\n  for (const [k, rule] of Object.entries(schema)) {\n    const v = raw[k];\n    if (v == null) out[k] = rule.default;\n    else if (typeof v === rule.type) out[k] = v;\n    else out[k] = rule.default;\n  }\n  return out;\n}\n\nconst schema = { retries: { type: 'number', default: 3 }, mode: { type: 'string', default: 'safe' } };\nconsole.log(parseConfig('{\"retries\":5,\"mode\":\"fast\"}', schema));",
      "output": "{ retries: 5, mode: 'fast' }",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "High-complexity Build binary search over sorted array of objects by key.",
      "code": "function binarySearchBy(arr, key, target) {\n  let l = 0, r = arr.length - 1;\n  while (l <= r) {\n    const m = (l + r) >> 1;\n    if (arr[m][key] === target) return m;\n    if (arr[m][key] < target) l = m + 1;\n    else r = m - 1;\n  }\n  return -1;\n}\n\nconst users = [{ id: 10 }, { id: 20 }, { id: 30 }, { id: 40 }];\nconsole.log(binarySearchBy(users, 'id', 30));",
      "output": "2",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "System-level Implement interval scheduler for maximum non-overlap jobs.",
      "code": "function maxNonOverlapping(intervals) {\n  intervals.sort((a, b) => a[1] - b[1]);\n  const selected = [];\n  let end = -Infinity;\n  for (const [s, e] of intervals) {\n    if (s >= end) {\n      selected.push([s, e]);\n      end = e;\n    }\n  }\n  return selected;\n}\n\nconsole.log(maxNonOverlapping([[1,3],[2,5],[4,6],[6,7]]));",
      "output": "[ [ 1, 3 ], [ 4, 6 ], [ 6, 7 ] ]",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "Scalable Build path matcher with params (`/users/:id/orders/:oid`).",
      "code": "function matchRoute(pattern, path) {\n  const p1 = pattern.split('/').filter(Boolean);\n  const p2 = path.split('/').filter(Boolean);\n  if (p1.length !== p2.length) return null;\n  const params = {};\n  for (let i = 0; i < p1.length; i++) {\n    if (p1[i].startsWith(':')) params[p1[i].slice(1)] = p2[i];\n    else if (p1[i] !== p2[i]) return null;\n  }\n  return params;\n}\n\nconsole.log(matchRoute('/users/:id/orders/:oid', '/users/42/orders/900'));",
      "output": "{ id: '42', oid: '900' }",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "Interview-hard Implement custom `Promise.any` polyfill.",
      "code": "function promiseAny(promises) {\n  return new Promise((resolve, reject) => {\n    let rejected = 0;\n    const errs = [];\n    promises.forEach((p, i) => {\n      Promise.resolve(p)\n        .then(resolve)\n        .catch(e => {\n          errs[i] = e;\n          rejected++;\n          if (rejected === promises.length) reject(new AggregateError(errs, 'All promises were rejected'));\n        });\n    });\n  });\n}\n\npromiseAny([Promise.reject('x'), Promise.resolve('ok'), Promise.reject('y')]).then(console.log);",
      "output": "ok",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "Architecture-grade Build LCS (longest common subsequence) dynamic programming.",
      "code": "function lcs(a, b) {\n  const dp = Array.from({ length: a.length + 1 }, () => Array(b.length + 1).fill(0));\n  for (let i = 1; i <= a.length; i++) {\n    for (let j = 1; j <= b.length; j++) {\n      if (a[i - 1] === b[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;\n      else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n    }\n  }\n  return dp[a.length][b.length];\n}\n\nconsole.log(lcs('ABCBDAB', 'BDCAB'));",
      "output": "4",
      "level": "Very Hard"
    },
    {
      "type": "program",
      "question": "High-complexity Implement rolling logger with max size and severity filter.",
      "code": "class RollingLogger {\n  constructor(max = 5) {\n    this.max = max;\n    this.rows = [];\n  }\n  log(level, msg) {\n    this.rows.push({ level, msg });\n    if (this.rows.length > this.max) this.rows.shift();\n  }\n  get(minLevel = 'debug') {\n    const order = { debug: 1, info: 2, warn: 3, error: 4 };\n    return this.rows.filter(r => order[r.level] >= order[minLevel]);\n  }\n}\n\nconst lg = new RollingLogger(3);\nlg.log('info', 'a'); lg.log('warn', 'b'); lg.log('error', 'c'); lg.log('debug', 'd');\nconsole.log(lg.get('warn'));",
      "output": "[ { level: 'warn', msg: 'b' }, { level: 'error', msg: 'c' } ]",
      "level": "Very Hard"
    }
  ]
}
