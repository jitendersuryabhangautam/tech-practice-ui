{
  "id": "reduce",
  "title": "Array.reduce()",
  "category": "Array Methods",
  "description": "Executes a reducer function on each element, resulting in a single output value.",
  "explanation": "Array.reduce() executes a reducer callback on each element, accumulating a single result. It's the most versatile array method — can implement map, filter, flatMap, and more.\n\nSyntax: array.reduce(callback(accumulator, currentValue, index, array), initialValue)\n\nHow it works:\n1. If initialValue is provided, accumulator starts as initialValue, iteration begins at index 0\n2. If no initialValue, accumulator = first element, iteration begins at index 1\n3. Each iteration: accumulator = callback(accumulator, currentValue)\n4. Final accumulator value is returned\n\nCritical rule — ALWAYS provide initialValue:\n- Without it, reduce on empty array throws TypeError\n- Without it, accumulator type depends on first element (error-prone)\n- Makes your intent explicit: 0 for sums, [] for arrays, {} for objects\n\nCommon patterns:\n- Sum: arr.reduce((sum, n) => sum + n, 0)\n- Flatten: arr.reduce((flat, sub) => flat.concat(sub), [])\n- Group by: arr.reduce((groups, item) => { ... }, {})\n- Frequency map: arr.reduce((freq, item) => { freq[item] = (freq[item] || 0) + 1; return freq; }, {})\n- Pipe/compose: fns.reduce((result, fn) => fn(result), initialVal)\n\nWhen NOT to use reduce:\n- Simple transformations (use map/filter for readability)\n- When the reducer becomes hard to read\n- When you need to break early (use for...of instead)",
  "implementation": "const numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((acc, curr) => acc + curr, 0);\n// 10",
  "example": "const cart = [\n  {item: 'book', price: 10},\n  {item: 'pen', price: 2}\n];\nconst total = cart.reduce((sum, item) => sum + item.price, 0);\n// 12",
  "useCase": "Calculating totals, flattening arrays, grouping data",
  "interviewQuestions": [
    {
      "question": "What is reduce used for?",
      "answer": "To fold an array into a single accumulated result such as number, object, map, or array."
    },
    {
      "question": "Why is initial value important in reduce?",
      "answer": "It avoids edge-case bugs on empty arrays and makes accumulator type explicit."
    },
    {
      "question": "Common reduce interview tasks?",
      "answer": "Sum, groupBy, flatten, frequency counter, composing pipelines."
    },
    {
      "question": "How to debug hard-to-read reduce logic?",
      "answer": "Name accumulator clearly, return immutable updates, and log intermediate accumulator states."
    },
    {
      "question": "When should reduce be avoided?",
      "answer": "When it harms readability for simple transformations where map/filter are clearer."
    },
    {
      "question": "What happens if you call reduce on an empty array without initialValue?",
      "answer": "Throws TypeError: 'Reduce of empty array with no initial value'. Always provide initialValue to avoid this — it's a common production bug."
    },
    {
      "question": "How does reduce differ from reduceRight?",
      "answer": "reduce iterates left-to-right (index 0 → end). reduceRight iterates right-to-left (end → index 0). Useful for right-to-left composition: fns.reduceRight((result, fn) => fn(result), initial)."
    },
    {
      "question": "How would you implement map using reduce?",
      "answer": "arr.reduce((result, element) => { result.push(transform(element)); return result; }, []). This shows reduce's versatility — it can implement any array method."
    },
    {
      "question": "What is function composition with reduce?",
      "answer": "const pipe = (...fns) => (x) => fns.reduce((result, fn) => fn(result), x). This creates a pipeline: pipe(add1, double, toString)(5) runs each function in sequence."
    },
    {
      "question": "Why is it important to always return the accumulator?",
      "answer": "If any branch of the callback doesn't return the accumulator, it becomes undefined in the next iteration, causing bugs. Always ensure every code path returns the accumulator value."
    }
  ],
  "exercises": [
    {
      "type": "output",
      "question": "Predict: [1,2,3].reduce((a,b)=>a+b,0)",
      "answer": "6",
      "output": "6"
    },
    {
      "type": "implement",
      "question": "Create frequency map from words array using reduce.",
      "code": "const freq = words.reduce((acc,w)=>{\n  acc[w]=(acc[w]||0)+1;\n  return acc;\n}, {});"
    },
    {
      "type": "debug",
      "question": "Reduce on empty array without initial value throws. Fix?",
      "answer": "Provide initial value based on accumulator type."
    },
    {
      "type": "refactor",
      "question": "Combine filter+map into one reduce for performance-sensitive path.",
      "answer": "Use conditional push inside reduce accumulator array."
    },
    {
      "type": "output",
      "question": "Predict output: ['a','b','c'].reduce((acc, val) => ({...acc, [val]: val.toUpperCase()}), {})",
      "answer": "{ a: 'A', b: 'B', c: 'C' }",
      "output": "{ a: 'A', b: 'B', c: 'C' }"
    },
    {
      "type": "output",
      "question": "Predict output: [1,2,3].reduce((a,b)=>a*b)",
      "answer": "6",
      "output": "6"
    },
    {
      "type": "implement",
      "question": "Implement sum(arr) using reduce."
    },
    {
      "type": "implement",
      "question": "Implement groupBy(arr, key) using reduce."
    },
    {
      "type": "debug",
      "question": "Reduce callback doesn't return accumulator in one branch of an if/else. What happens?",
      "answer": "Accumulator becomes undefined in the next iteration, causing a runtime error or incorrect result. Always return accumulator from every branch."
    },
    {
      "type": "debug",
      "question": "Accumulator returns undefined in one branch. Impact?",
      "answer": "Next iteration receives undefined, causing runtime bugs."
    }
  ],
  "programExercises": [
    {
      "type": "program",
      "question": "Program 1: Sum array using reduce.",
      "code": "const nums=[10,20,30];\nconst total=nums.reduce((a,b)=>a+b,0);\nconsole.log(total);",
      "output": "60"
    },
    {
      "type": "program",
      "question": "Program 2: Multiply all numbers using reduce.",
      "code": "const nums=[2,3,4];\nconsole.log(nums.reduce((a,b)=>a*b,1));",
      "output": "24"
    },
    {
      "type": "program",
      "question": "Program 3: Find max value using reduce.",
      "code": "const nums=[8,3,15,9];\nconst max=nums.reduce((m,n)=>n>m?n:m);\nconsole.log(max);",
      "output": "15"
    },
    {
      "type": "program",
      "question": "Program 4: Flatten nested array one level using reduce.",
      "code": "const nested=[[1,2],[3,4],[5]];\nconst flat=nested.reduce((acc,c)=>acc.concat(c),[]);\nconsole.log(flat);",
      "output": "[ 1, 2, 3, 4, 5 ]"
    },
    {
      "type": "program",
      "question": "Program 5: Build frequency map of characters.",
      "code": "const str=\"aabca\";\nconst freq=[...str].reduce((acc,ch)=>{acc[ch]=(acc[ch]||0)+1;return acc;},{});\nconsole.log(freq);",
      "output": "{ a: 3, b: 1, c: 1 }"
    },
    {
      "type": "program",
      "question": "Program 6: Group users by role using reduce.",
      "code": "const users=[{n:\"A\",r:\"dev\"},{n:\"B\",r:\"qa\"},{n:\"C\",r:\"dev\"}];\nconst grouped=users.reduce((acc,u)=>{(acc[u.r]??=[]).push(u.n);return acc;},{});\nconsole.log(grouped);",
      "output": "{ dev: [ \"A\", \"C\" ], qa: [ \"B\" ] }"
    },
    {
      "type": "program",
      "question": "Program 7: Convert object entries array to object using reduce.",
      "code": "const entries=[[\"a\",1],[\"b\",2]];\nconst obj=entries.reduce((acc,[k,v])=>{acc[k]=v;return acc;},{});\nconsole.log(obj);",
      "output": "{ a: 1, b: 2 }"
    },
    {
      "type": "program",
      "question": "Program 8: Count total cart value.",
      "code": "const cart=[{p:100,q:2},{p:50,q:1}];\nconst total=cart.reduce((sum,i)=>sum+i.p*i.q,0);\nconsole.log(total);",
      "output": "250"
    },
    {
      "type": "program",
      "question": "Program 9: Remove duplicates with reduce.",
      "code": "const arr=[1,2,2,3,1];\nconst uniq=arr.reduce((acc,n)=>acc.includes(n)?acc:[...acc,n],[]);\nconsole.log(uniq);",
      "output": "[ 1, 2, 3 ]"
    },
    {
      "type": "program",
      "question": "Program 10: Compose sentence from words array.",
      "code": "const words=[\"JS\",\"is\",\"awesome\"];\nconst s=words.reduce((acc,w)=> acc ? `${acc} ${w}` : w, \"\");\nconsole.log(s);",
      "output": "JS is awesome"
    }
  ]
}
